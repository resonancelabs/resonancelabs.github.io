(function() { const DEBUG = 1; (function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.cruntime = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports={
    "name": "rl-cruntime-browser",
    "version": "0.4.4",
    "main": "cruntime_browser.js",
    "devDependencies": {
        "http-server": "^0.7.5"
    }
}
},{}],2:[function(require,module,exports){
(function() {
var crouton_thrift = {};
//
// Autogenerated by Thrift Compiler (0.9.2)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//


if (typeof crouton_thrift === 'undefined') {
  crouton_thrift = {};
}
crouton_thrift.KeyValue = function(args) {
  this.Key = null;
  this.Value = null;
  if (args) {
    if (args.Key !== undefined) {
      this.Key = args.Key;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field Key is unset!');
    }
    if (args.Value !== undefined) {
      this.Value = args.Value;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field Value is unset!');
    }
  }
};
crouton_thrift.KeyValue.prototype = {};
crouton_thrift.KeyValue.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.Key = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.Value = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

crouton_thrift.KeyValue.prototype.write = function(output) {
  output.writeStructBegin('KeyValue');
  if (this.Key !== null && this.Key !== undefined) {
    output.writeFieldBegin('Key', Thrift.Type.STRING, 1);
    output.writeString(this.Key);
    output.writeFieldEnd();
  }
  if (this.Value !== null && this.Value !== undefined) {
    output.writeFieldBegin('Value', Thrift.Type.STRING, 2);
    output.writeString(this.Value);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

crouton_thrift.NamedCounter = function(args) {
  this.Name = null;
  this.Value = null;
  if (args) {
    if (args.Name !== undefined) {
      this.Name = args.Name;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field Name is unset!');
    }
    if (args.Value !== undefined) {
      this.Value = args.Value;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field Value is unset!');
    }
  }
};
crouton_thrift.NamedCounter.prototype = {};
crouton_thrift.NamedCounter.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.Name = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.Value = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

crouton_thrift.NamedCounter.prototype.write = function(output) {
  output.writeStructBegin('NamedCounter');
  if (this.Name !== null && this.Name !== undefined) {
    output.writeFieldBegin('Name', Thrift.Type.STRING, 1);
    output.writeString(this.Name);
    output.writeFieldEnd();
  }
  if (this.Value !== null && this.Value !== undefined) {
    output.writeFieldBegin('Value', Thrift.Type.I64, 2);
    output.writeI64(this.Value);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

crouton_thrift.Runtime = function(args) {
  this.guid = null;
  this.start_micros = null;
  this.group_name = null;
  this.attrs = null;
  if (args) {
    if (args.guid !== undefined) {
      this.guid = args.guid;
    }
    if (args.start_micros !== undefined) {
      this.start_micros = args.start_micros;
    }
    if (args.group_name !== undefined) {
      this.group_name = args.group_name;
    }
    if (args.attrs !== undefined) {
      this.attrs = args.attrs;
    }
  }
};
crouton_thrift.Runtime.prototype = {};
crouton_thrift.Runtime.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.guid = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.start_micros = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.group_name = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.LIST) {
        var _size0 = 0;
        var _rtmp34;
        this.attrs = [];
        var _etype3 = 0;
        _rtmp34 = input.readListBegin();
        _etype3 = _rtmp34.etype;
        _size0 = _rtmp34.size;
        for (var _i5 = 0; _i5 < _size0; ++_i5)
        {
          var elem6 = null;
          elem6 = new crouton_thrift.KeyValue();
          elem6.read(input);
          this.attrs.push(elem6);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

crouton_thrift.Runtime.prototype.write = function(output) {
  output.writeStructBegin('Runtime');
  if (this.guid !== null && this.guid !== undefined) {
    output.writeFieldBegin('guid', Thrift.Type.STRING, 1);
    output.writeString(this.guid);
    output.writeFieldEnd();
  }
  if (this.start_micros !== null && this.start_micros !== undefined) {
    output.writeFieldBegin('start_micros', Thrift.Type.I64, 2);
    output.writeI64(this.start_micros);
    output.writeFieldEnd();
  }
  if (this.group_name !== null && this.group_name !== undefined) {
    output.writeFieldBegin('group_name', Thrift.Type.STRING, 3);
    output.writeString(this.group_name);
    output.writeFieldEnd();
  }
  if (this.attrs !== null && this.attrs !== undefined) {
    output.writeFieldBegin('attrs', Thrift.Type.LIST, 4);
    output.writeListBegin(Thrift.Type.STRUCT, this.attrs.length);
    for (var iter7 in this.attrs)
    {
      if (this.attrs.hasOwnProperty(iter7))
      {
        iter7 = this.attrs[iter7];
        iter7.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

crouton_thrift.LogRecord = function(args) {
  this.timestamp_micros = null;
  this.runtime_guid = null;
  this.span_guid = null;
  this.stable_name = null;
  this.message = null;
  this.level = null;
  this.thread_id = null;
  this.filename = null;
  this.line_number = null;
  this.stack_frames = null;
  this.payload_json = null;
  this.error_flag = null;
  if (args) {
    if (args.timestamp_micros !== undefined) {
      this.timestamp_micros = args.timestamp_micros;
    }
    if (args.runtime_guid !== undefined) {
      this.runtime_guid = args.runtime_guid;
    }
    if (args.span_guid !== undefined) {
      this.span_guid = args.span_guid;
    }
    if (args.stable_name !== undefined) {
      this.stable_name = args.stable_name;
    }
    if (args.message !== undefined) {
      this.message = args.message;
    }
    if (args.level !== undefined) {
      this.level = args.level;
    }
    if (args.thread_id !== undefined) {
      this.thread_id = args.thread_id;
    }
    if (args.filename !== undefined) {
      this.filename = args.filename;
    }
    if (args.line_number !== undefined) {
      this.line_number = args.line_number;
    }
    if (args.stack_frames !== undefined) {
      this.stack_frames = args.stack_frames;
    }
    if (args.payload_json !== undefined) {
      this.payload_json = args.payload_json;
    }
    if (args.error_flag !== undefined) {
      this.error_flag = args.error_flag;
    }
  }
};
crouton_thrift.LogRecord.prototype = {};
crouton_thrift.LogRecord.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I64) {
        this.timestamp_micros = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.runtime_guid = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.span_guid = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRING) {
        this.stable_name = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.STRING) {
        this.message = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.STRING) {
        this.level = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.I64) {
        this.thread_id = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 8:
      if (ftype == Thrift.Type.STRING) {
        this.filename = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 9:
      if (ftype == Thrift.Type.I64) {
        this.line_number = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 10:
      if (ftype == Thrift.Type.LIST) {
        var _size8 = 0;
        var _rtmp312;
        this.stack_frames = [];
        var _etype11 = 0;
        _rtmp312 = input.readListBegin();
        _etype11 = _rtmp312.etype;
        _size8 = _rtmp312.size;
        for (var _i13 = 0; _i13 < _size8; ++_i13)
        {
          var elem14 = null;
          elem14 = input.readString().value;
          this.stack_frames.push(elem14);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 11:
      if (ftype == Thrift.Type.STRING) {
        this.payload_json = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 12:
      if (ftype == Thrift.Type.BOOL) {
        this.error_flag = input.readBool().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

crouton_thrift.LogRecord.prototype.write = function(output) {
  output.writeStructBegin('LogRecord');
  if (this.timestamp_micros !== null && this.timestamp_micros !== undefined) {
    output.writeFieldBegin('timestamp_micros', Thrift.Type.I64, 1);
    output.writeI64(this.timestamp_micros);
    output.writeFieldEnd();
  }
  if (this.runtime_guid !== null && this.runtime_guid !== undefined) {
    output.writeFieldBegin('runtime_guid', Thrift.Type.STRING, 2);
    output.writeString(this.runtime_guid);
    output.writeFieldEnd();
  }
  if (this.span_guid !== null && this.span_guid !== undefined) {
    output.writeFieldBegin('span_guid', Thrift.Type.STRING, 3);
    output.writeString(this.span_guid);
    output.writeFieldEnd();
  }
  if (this.stable_name !== null && this.stable_name !== undefined) {
    output.writeFieldBegin('stable_name', Thrift.Type.STRING, 4);
    output.writeString(this.stable_name);
    output.writeFieldEnd();
  }
  if (this.message !== null && this.message !== undefined) {
    output.writeFieldBegin('message', Thrift.Type.STRING, 5);
    output.writeString(this.message);
    output.writeFieldEnd();
  }
  if (this.level !== null && this.level !== undefined) {
    output.writeFieldBegin('level', Thrift.Type.STRING, 6);
    output.writeString(this.level);
    output.writeFieldEnd();
  }
  if (this.thread_id !== null && this.thread_id !== undefined) {
    output.writeFieldBegin('thread_id', Thrift.Type.I64, 7);
    output.writeI64(this.thread_id);
    output.writeFieldEnd();
  }
  if (this.filename !== null && this.filename !== undefined) {
    output.writeFieldBegin('filename', Thrift.Type.STRING, 8);
    output.writeString(this.filename);
    output.writeFieldEnd();
  }
  if (this.line_number !== null && this.line_number !== undefined) {
    output.writeFieldBegin('line_number', Thrift.Type.I64, 9);
    output.writeI64(this.line_number);
    output.writeFieldEnd();
  }
  if (this.stack_frames !== null && this.stack_frames !== undefined) {
    output.writeFieldBegin('stack_frames', Thrift.Type.LIST, 10);
    output.writeListBegin(Thrift.Type.STRING, this.stack_frames.length);
    for (var iter15 in this.stack_frames)
    {
      if (this.stack_frames.hasOwnProperty(iter15))
      {
        iter15 = this.stack_frames[iter15];
        output.writeString(iter15);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.payload_json !== null && this.payload_json !== undefined) {
    output.writeFieldBegin('payload_json', Thrift.Type.STRING, 11);
    output.writeString(this.payload_json);
    output.writeFieldEnd();
  }
  if (this.error_flag !== null && this.error_flag !== undefined) {
    output.writeFieldBegin('error_flag', Thrift.Type.BOOL, 12);
    output.writeBool(this.error_flag);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

crouton_thrift.TraceJoinId = function(args) {
  this.TraceKey = null;
  this.Value = null;
  if (args) {
    if (args.TraceKey !== undefined) {
      this.TraceKey = args.TraceKey;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field TraceKey is unset!');
    }
    if (args.Value !== undefined) {
      this.Value = args.Value;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field Value is unset!');
    }
  }
};
crouton_thrift.TraceJoinId.prototype = {};
crouton_thrift.TraceJoinId.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.TraceKey = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.Value = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

crouton_thrift.TraceJoinId.prototype.write = function(output) {
  output.writeStructBegin('TraceJoinId');
  if (this.TraceKey !== null && this.TraceKey !== undefined) {
    output.writeFieldBegin('TraceKey', Thrift.Type.STRING, 1);
    output.writeString(this.TraceKey);
    output.writeFieldEnd();
  }
  if (this.Value !== null && this.Value !== undefined) {
    output.writeFieldBegin('Value', Thrift.Type.STRING, 2);
    output.writeString(this.Value);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

crouton_thrift.SpanRecord = function(args) {
  this.span_guid = null;
  this.runtime_guid = null;
  this.span_name = null;
  this.join_ids = null;
  this.oldest_micros = null;
  this.youngest_micros = null;
  this.attributes = null;
  this.error_flag = null;
  if (args) {
    if (args.span_guid !== undefined) {
      this.span_guid = args.span_guid;
    }
    if (args.runtime_guid !== undefined) {
      this.runtime_guid = args.runtime_guid;
    }
    if (args.span_name !== undefined) {
      this.span_name = args.span_name;
    }
    if (args.join_ids !== undefined) {
      this.join_ids = args.join_ids;
    }
    if (args.oldest_micros !== undefined) {
      this.oldest_micros = args.oldest_micros;
    }
    if (args.youngest_micros !== undefined) {
      this.youngest_micros = args.youngest_micros;
    }
    if (args.attributes !== undefined) {
      this.attributes = args.attributes;
    }
    if (args.error_flag !== undefined) {
      this.error_flag = args.error_flag;
    }
  }
};
crouton_thrift.SpanRecord.prototype = {};
crouton_thrift.SpanRecord.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.span_guid = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.runtime_guid = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.span_name = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.LIST) {
        var _size16 = 0;
        var _rtmp320;
        this.join_ids = [];
        var _etype19 = 0;
        _rtmp320 = input.readListBegin();
        _etype19 = _rtmp320.etype;
        _size16 = _rtmp320.size;
        for (var _i21 = 0; _i21 < _size16; ++_i21)
        {
          var elem22 = null;
          elem22 = new crouton_thrift.TraceJoinId();
          elem22.read(input);
          this.join_ids.push(elem22);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.I64) {
        this.oldest_micros = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.I64) {
        this.youngest_micros = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 8:
      if (ftype == Thrift.Type.LIST) {
        var _size23 = 0;
        var _rtmp327;
        this.attributes = [];
        var _etype26 = 0;
        _rtmp327 = input.readListBegin();
        _etype26 = _rtmp327.etype;
        _size23 = _rtmp327.size;
        for (var _i28 = 0; _i28 < _size23; ++_i28)
        {
          var elem29 = null;
          elem29 = new crouton_thrift.KeyValue();
          elem29.read(input);
          this.attributes.push(elem29);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 9:
      if (ftype == Thrift.Type.BOOL) {
        this.error_flag = input.readBool().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

crouton_thrift.SpanRecord.prototype.write = function(output) {
  output.writeStructBegin('SpanRecord');
  if (this.span_guid !== null && this.span_guid !== undefined) {
    output.writeFieldBegin('span_guid', Thrift.Type.STRING, 1);
    output.writeString(this.span_guid);
    output.writeFieldEnd();
  }
  if (this.runtime_guid !== null && this.runtime_guid !== undefined) {
    output.writeFieldBegin('runtime_guid', Thrift.Type.STRING, 2);
    output.writeString(this.runtime_guid);
    output.writeFieldEnd();
  }
  if (this.span_name !== null && this.span_name !== undefined) {
    output.writeFieldBegin('span_name', Thrift.Type.STRING, 3);
    output.writeString(this.span_name);
    output.writeFieldEnd();
  }
  if (this.join_ids !== null && this.join_ids !== undefined) {
    output.writeFieldBegin('join_ids', Thrift.Type.LIST, 4);
    output.writeListBegin(Thrift.Type.STRUCT, this.join_ids.length);
    for (var iter30 in this.join_ids)
    {
      if (this.join_ids.hasOwnProperty(iter30))
      {
        iter30 = this.join_ids[iter30];
        iter30.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.oldest_micros !== null && this.oldest_micros !== undefined) {
    output.writeFieldBegin('oldest_micros', Thrift.Type.I64, 5);
    output.writeI64(this.oldest_micros);
    output.writeFieldEnd();
  }
  if (this.youngest_micros !== null && this.youngest_micros !== undefined) {
    output.writeFieldBegin('youngest_micros', Thrift.Type.I64, 6);
    output.writeI64(this.youngest_micros);
    output.writeFieldEnd();
  }
  if (this.attributes !== null && this.attributes !== undefined) {
    output.writeFieldBegin('attributes', Thrift.Type.LIST, 8);
    output.writeListBegin(Thrift.Type.STRUCT, this.attributes.length);
    for (var iter31 in this.attributes)
    {
      if (this.attributes.hasOwnProperty(iter31))
      {
        iter31 = this.attributes[iter31];
        iter31.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.error_flag !== null && this.error_flag !== undefined) {
    output.writeFieldBegin('error_flag', Thrift.Type.BOOL, 9);
    output.writeBool(this.error_flag);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

crouton_thrift.Auth = function(args) {
  this.access_token = null;
  if (args) {
    if (args.access_token !== undefined) {
      this.access_token = args.access_token;
    }
  }
};
crouton_thrift.Auth.prototype = {};
crouton_thrift.Auth.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.access_token = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

crouton_thrift.Auth.prototype.write = function(output) {
  output.writeStructBegin('Auth');
  if (this.access_token !== null && this.access_token !== undefined) {
    output.writeFieldBegin('access_token', Thrift.Type.STRING, 1);
    output.writeString(this.access_token);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

crouton_thrift.Timing = function(args) {
  this.receive_micros = null;
  this.transmit_micros = null;
  if (args) {
    if (args.receive_micros !== undefined) {
      this.receive_micros = args.receive_micros;
    }
    if (args.transmit_micros !== undefined) {
      this.transmit_micros = args.transmit_micros;
    }
  }
};
crouton_thrift.Timing.prototype = {};
crouton_thrift.Timing.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I64) {
        this.receive_micros = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.transmit_micros = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

crouton_thrift.Timing.prototype.write = function(output) {
  output.writeStructBegin('Timing');
  if (this.receive_micros !== null && this.receive_micros !== undefined) {
    output.writeFieldBegin('receive_micros', Thrift.Type.I64, 1);
    output.writeI64(this.receive_micros);
    output.writeFieldEnd();
  }
  if (this.transmit_micros !== null && this.transmit_micros !== undefined) {
    output.writeFieldBegin('transmit_micros', Thrift.Type.I64, 2);
    output.writeI64(this.transmit_micros);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

crouton_thrift.SampleCount = function(args) {
  this.oldest_micros = null;
  this.youngest_micros = null;
  this.count = null;
  if (args) {
    if (args.oldest_micros !== undefined) {
      this.oldest_micros = args.oldest_micros;
    }
    if (args.youngest_micros !== undefined) {
      this.youngest_micros = args.youngest_micros;
    }
    if (args.count !== undefined) {
      this.count = args.count;
    }
  }
};
crouton_thrift.SampleCount.prototype = {};
crouton_thrift.SampleCount.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I64) {
        this.oldest_micros = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.youngest_micros = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I64) {
        this.count = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

crouton_thrift.SampleCount.prototype.write = function(output) {
  output.writeStructBegin('SampleCount');
  if (this.oldest_micros !== null && this.oldest_micros !== undefined) {
    output.writeFieldBegin('oldest_micros', Thrift.Type.I64, 1);
    output.writeI64(this.oldest_micros);
    output.writeFieldEnd();
  }
  if (this.youngest_micros !== null && this.youngest_micros !== undefined) {
    output.writeFieldBegin('youngest_micros', Thrift.Type.I64, 2);
    output.writeI64(this.youngest_micros);
    output.writeFieldEnd();
  }
  if (this.count !== null && this.count !== undefined) {
    output.writeFieldBegin('count', Thrift.Type.I64, 3);
    output.writeI64(this.count);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

crouton_thrift.ReportRequest = function(args) {
  this.runtime = null;
  this.span_records = null;
  this.log_records = null;
  this.timestamp_offset_micros = null;
  this.oldest_micros = null;
  this.youngest_micros = null;
  this.counters = null;
  if (args) {
    if (args.runtime !== undefined) {
      this.runtime = args.runtime;
    }
    if (args.span_records !== undefined) {
      this.span_records = args.span_records;
    }
    if (args.log_records !== undefined) {
      this.log_records = args.log_records;
    }
    if (args.timestamp_offset_micros !== undefined) {
      this.timestamp_offset_micros = args.timestamp_offset_micros;
    }
    if (args.oldest_micros !== undefined) {
      this.oldest_micros = args.oldest_micros;
    }
    if (args.youngest_micros !== undefined) {
      this.youngest_micros = args.youngest_micros;
    }
    if (args.counters !== undefined) {
      this.counters = args.counters;
    }
  }
};
crouton_thrift.ReportRequest.prototype = {};
crouton_thrift.ReportRequest.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.runtime = new crouton_thrift.Runtime();
        this.runtime.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.LIST) {
        var _size32 = 0;
        var _rtmp336;
        this.span_records = [];
        var _etype35 = 0;
        _rtmp336 = input.readListBegin();
        _etype35 = _rtmp336.etype;
        _size32 = _rtmp336.size;
        for (var _i37 = 0; _i37 < _size32; ++_i37)
        {
          var elem38 = null;
          elem38 = new crouton_thrift.SpanRecord();
          elem38.read(input);
          this.span_records.push(elem38);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.LIST) {
        var _size39 = 0;
        var _rtmp343;
        this.log_records = [];
        var _etype42 = 0;
        _rtmp343 = input.readListBegin();
        _etype42 = _rtmp343.etype;
        _size39 = _rtmp343.size;
        for (var _i44 = 0; _i44 < _size39; ++_i44)
        {
          var elem45 = null;
          elem45 = new crouton_thrift.LogRecord();
          elem45.read(input);
          this.log_records.push(elem45);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.I64) {
        this.timestamp_offset_micros = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.I64) {
        this.oldest_micros = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 8:
      if (ftype == Thrift.Type.I64) {
        this.youngest_micros = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 9:
      if (ftype == Thrift.Type.LIST) {
        var _size46 = 0;
        var _rtmp350;
        this.counters = [];
        var _etype49 = 0;
        _rtmp350 = input.readListBegin();
        _etype49 = _rtmp350.etype;
        _size46 = _rtmp350.size;
        for (var _i51 = 0; _i51 < _size46; ++_i51)
        {
          var elem52 = null;
          elem52 = new crouton_thrift.NamedCounter();
          elem52.read(input);
          this.counters.push(elem52);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

crouton_thrift.ReportRequest.prototype.write = function(output) {
  output.writeStructBegin('ReportRequest');
  if (this.runtime !== null && this.runtime !== undefined) {
    output.writeFieldBegin('runtime', Thrift.Type.STRUCT, 1);
    this.runtime.write(output);
    output.writeFieldEnd();
  }
  if (this.span_records !== null && this.span_records !== undefined) {
    output.writeFieldBegin('span_records', Thrift.Type.LIST, 3);
    output.writeListBegin(Thrift.Type.STRUCT, this.span_records.length);
    for (var iter53 in this.span_records)
    {
      if (this.span_records.hasOwnProperty(iter53))
      {
        iter53 = this.span_records[iter53];
        iter53.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.log_records !== null && this.log_records !== undefined) {
    output.writeFieldBegin('log_records', Thrift.Type.LIST, 4);
    output.writeListBegin(Thrift.Type.STRUCT, this.log_records.length);
    for (var iter54 in this.log_records)
    {
      if (this.log_records.hasOwnProperty(iter54))
      {
        iter54 = this.log_records[iter54];
        iter54.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.timestamp_offset_micros !== null && this.timestamp_offset_micros !== undefined) {
    output.writeFieldBegin('timestamp_offset_micros', Thrift.Type.I64, 5);
    output.writeI64(this.timestamp_offset_micros);
    output.writeFieldEnd();
  }
  if (this.oldest_micros !== null && this.oldest_micros !== undefined) {
    output.writeFieldBegin('oldest_micros', Thrift.Type.I64, 7);
    output.writeI64(this.oldest_micros);
    output.writeFieldEnd();
  }
  if (this.youngest_micros !== null && this.youngest_micros !== undefined) {
    output.writeFieldBegin('youngest_micros', Thrift.Type.I64, 8);
    output.writeI64(this.youngest_micros);
    output.writeFieldEnd();
  }
  if (this.counters !== null && this.counters !== undefined) {
    output.writeFieldBegin('counters', Thrift.Type.LIST, 9);
    output.writeListBegin(Thrift.Type.STRUCT, this.counters.length);
    for (var iter55 in this.counters)
    {
      if (this.counters.hasOwnProperty(iter55))
      {
        iter55 = this.counters[iter55];
        iter55.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

crouton_thrift.Command = function(args) {
  this.disable = null;
  if (args) {
    if (args.disable !== undefined) {
      this.disable = args.disable;
    }
  }
};
crouton_thrift.Command.prototype = {};
crouton_thrift.Command.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.BOOL) {
        this.disable = input.readBool().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

crouton_thrift.Command.prototype.write = function(output) {
  output.writeStructBegin('Command');
  if (this.disable !== null && this.disable !== undefined) {
    output.writeFieldBegin('disable', Thrift.Type.BOOL, 1);
    output.writeBool(this.disable);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

crouton_thrift.ReportResponse = function(args) {
  this.commands = null;
  this.timing = null;
  this.errors = null;
  if (args) {
    if (args.commands !== undefined) {
      this.commands = args.commands;
    }
    if (args.timing !== undefined) {
      this.timing = args.timing;
    }
    if (args.errors !== undefined) {
      this.errors = args.errors;
    }
  }
};
crouton_thrift.ReportResponse.prototype = {};
crouton_thrift.ReportResponse.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        var _size56 = 0;
        var _rtmp360;
        this.commands = [];
        var _etype59 = 0;
        _rtmp360 = input.readListBegin();
        _etype59 = _rtmp360.etype;
        _size56 = _rtmp360.size;
        for (var _i61 = 0; _i61 < _size56; ++_i61)
        {
          var elem62 = null;
          elem62 = new crouton_thrift.Command();
          elem62.read(input);
          this.commands.push(elem62);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.timing = new crouton_thrift.Timing();
        this.timing.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.LIST) {
        var _size63 = 0;
        var _rtmp367;
        this.errors = [];
        var _etype66 = 0;
        _rtmp367 = input.readListBegin();
        _etype66 = _rtmp367.etype;
        _size63 = _rtmp367.size;
        for (var _i68 = 0; _i68 < _size63; ++_i68)
        {
          var elem69 = null;
          elem69 = input.readString().value;
          this.errors.push(elem69);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

crouton_thrift.ReportResponse.prototype.write = function(output) {
  output.writeStructBegin('ReportResponse');
  if (this.commands !== null && this.commands !== undefined) {
    output.writeFieldBegin('commands', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRUCT, this.commands.length);
    for (var iter70 in this.commands)
    {
      if (this.commands.hasOwnProperty(iter70))
      {
        iter70 = this.commands[iter70];
        iter70.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.timing !== null && this.timing !== undefined) {
    output.writeFieldBegin('timing', Thrift.Type.STRUCT, 2);
    this.timing.write(output);
    output.writeFieldEnd();
  }
  if (this.errors !== null && this.errors !== undefined) {
    output.writeFieldBegin('errors', Thrift.Type.LIST, 3);
    output.writeListBegin(Thrift.Type.STRING, this.errors.length);
    for (var iter71 in this.errors)
    {
      if (this.errors.hasOwnProperty(iter71))
      {
        iter71 = this.errors[iter71];
        output.writeString(iter71);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};


//
// Autogenerated by Thrift Compiler (0.9.2)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//


//HELPER FUNCTIONS AND STRUCTURES

crouton_thrift.ReportingService_Report_args = function(args) {
  this.auth = null;
  this.request = null;
  if (args) {
    if (args.auth !== undefined) {
      this.auth = args.auth;
    }
    if (args.request !== undefined) {
      this.request = args.request;
    }
  }
};
crouton_thrift.ReportingService_Report_args.prototype = {};
crouton_thrift.ReportingService_Report_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.auth = new crouton_thrift.Auth();
        this.auth.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.request = new crouton_thrift.ReportRequest();
        this.request.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

crouton_thrift.ReportingService_Report_args.prototype.write = function(output) {
  output.writeStructBegin('ReportingService_Report_args');
  if (this.auth !== null && this.auth !== undefined) {
    output.writeFieldBegin('auth', Thrift.Type.STRUCT, 1);
    this.auth.write(output);
    output.writeFieldEnd();
  }
  if (this.request !== null && this.request !== undefined) {
    output.writeFieldBegin('request', Thrift.Type.STRUCT, 2);
    this.request.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

crouton_thrift.ReportingService_Report_result = function(args) {
  this.success = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
  }
};
crouton_thrift.ReportingService_Report_result.prototype = {};
crouton_thrift.ReportingService_Report_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRUCT) {
        this.success = new crouton_thrift.ReportResponse();
        this.success.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

crouton_thrift.ReportingService_Report_result.prototype.write = function(output) {
  output.writeStructBegin('ReportingService_Report_result');
  if (this.success !== null && this.success !== undefined) {
    output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
    this.success.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

crouton_thrift.ReportingServiceClient = function(input, output) {
    this.input = input;
    this.output = (!output) ? input : output;
    this.seqid = 0;
};
crouton_thrift.ReportingServiceClient.prototype = {};
crouton_thrift.ReportingServiceClient.prototype.Report = function(auth, request, callback) {
  this.send_Report(auth, request, callback); 
  if (!callback) {
    return this.recv_Report();
  }
};

crouton_thrift.ReportingServiceClient.prototype.send_Report = function(auth, request, callback) {
  this.output.writeMessageBegin('Report', Thrift.MessageType.CALL, this.seqid);
  var args = new crouton_thrift.ReportingService_Report_args();
  args.auth = auth;
  args.request = request;
  args.write(this.output);
  this.output.writeMessageEnd();
  if (callback) {
    var self = this;
    this.output.getTransport().flush(true, function() {
      var result = null;
      try {
        result = self.recv_Report();
      } catch (e) {
        result = e;
      }
      callback(result);
    });
  } else {
    return this.output.getTransport().flush();
  }
};

crouton_thrift.ReportingServiceClient.prototype.recv_Report = function() {
  var ret = this.input.readMessageBegin();
  var fname = ret.fname;
  var mtype = ret.mtype;
  var rseqid = ret.rseqid;
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(this.input);
    this.input.readMessageEnd();
    throw x;
  }
  var result = new crouton_thrift.ReportingService_Report_result();
  result.read(this.input);
  this.input.readMessageEnd();

  if (null !== result.success) {
    return result.success;
  }
  throw 'Report failed: unknown result';
};

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/*jshint evil:true*/

/**
 * The Thrift namespace houses the Apache Thrift JavaScript library 
 * elements providing JavaScript bindings for the Apache Thrift RPC 
 * system. End users will typically only directly make use of the 
 * Transport (TXHRTransport/TWebSocketTransport) and Protocol 
 * (TJSONPRotocol/TBinaryProtocol) constructors.
 * 
 * Object methods beginning with a __ (e.g. __onOpen()) are internal 
 * and should not be called outside of the object's own methods.
 * 
 * This library creates one global object: Thrift
 * Code in this library must never create additional global identifiers,
 * all features must be scoped within the Thrift namespace.
 * @namespace
 * @example
 *     var transport = new Thrift.Transport("http://localhost:8585");
 *     var protocol  = new Thrift.Protocol(transport);
 *     var client = new MyThriftSvcClient(protocol);
 *     var result = client.MyMethod();
 */
var Thrift = {
    /**
     * Thrift JavaScript library version.
     * @readonly
     * @const {string} Version
     * @memberof Thrift
     */
    Version: '1.0.0-dev',

    /**
     * Thrift IDL type string to Id mapping.
     * @readonly
     * @property {number}  STOP   - End of a set of fields.
     * @property {number}  VOID   - No value (only legal for return types).
     * @property {number}  BOOL   - True/False integer.
     * @property {number}  BYTE   - Signed 8 bit integer.
     * @property {number}  I08    - Signed 8 bit integer.     
     * @property {number}  DOUBLE - 64 bit IEEE 854 floating point.
     * @property {number}  I16    - Signed 16 bit integer.
     * @property {number}  I32    - Signed 32 bit integer.
     * @property {number}  I64    - Signed 64 bit integer.
     * @property {number}  STRING - Array of bytes representing a string of characters.
     * @property {number}  UTF7   - Array of bytes representing a string of UTF7 encoded characters.
     * @property {number}  STRUCT - A multifield type.
     * @property {number}  MAP    - A collection type (map/associative-array/dictionary).
     * @property {number}  SET    - A collection type (unordered and without repeated values).
     * @property {number}  LIST   - A collection type (unordered).
     * @property {number}  UTF8   - Array of bytes representing a string of UTF8 encoded characters.
     * @property {number}  UTF16  - Array of bytes representing a string of UTF16 encoded characters.
     */
    Type: {
        'STOP' : 0,
        'VOID' : 1,
        'BOOL' : 2,
        'BYTE' : 3,
        'I08' : 3,
        'DOUBLE' : 4,
        'I16' : 6,
        'I32' : 8,
        'I64' : 10,
        'STRING' : 11,
        'UTF7' : 11,
        'STRUCT' : 12,
        'MAP' : 13,
        'SET' : 14,
        'LIST' : 15,
        'UTF8' : 16,
        'UTF16' : 17
    },

    /**
     * Thrift RPC message type string to Id mapping.
     * @readonly
     * @property {number}  CALL      - RPC call sent from client to server.
     * @property {number}  REPLY     - RPC call normal response from server to client.
     * @property {number}  EXCEPTION - RPC call exception response from server to client.
     * @property {number}  ONEWAY    - Oneway RPC call from client to server with no response.
     */
    MessageType: {
        'CALL' : 1,
        'REPLY' : 2,
        'EXCEPTION' : 3,
        'ONEWAY' : 4
    },

    /**
     * Utility function returning the count of an object's own properties.
     * @param {object} obj - Object to test.
     * @returns {number} number of object's own properties
     */
    objectLength: function(obj) {
        var length = 0;
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                length++;
            }
        }
        return length;
    },

    /**
     * Utility function to establish prototype inheritance.
     * @see {@link http://javascript.crockford.com/prototypal.html|Prototypal Inheritance}
     * @param {function} constructor - Contstructor function to set as derived.
     * @param {function} superConstructor - Contstructor function to set as base.
     * @param {string} [name] - Type name to set as name property in derived prototype.
     */
    inherits: function(constructor, superConstructor, name) {
      function F() {}
      F.prototype = superConstructor.prototype;
      constructor.prototype = new F();
      constructor.prototype.name = name || "";
    }
};

/**
 * Initializes a Thrift TException instance.
 * @constructor
 * @augments Error
 * @param {string} message - The TException message (distinct from the Error message).
 * @classdesc TException is the base class for all Thrift exceptions types.
 */
Thrift.TException = function(message) {
    this.message = message;
};
Thrift.inherits(Thrift.TException, Error, 'TException');

/**
 * Returns the message set on the exception.
 * @readonly
 * @returns {string} exception message
 */
Thrift.TException.prototype.getMessage = function() {
    return this.message;
};

/**
 * Thrift Application Exception type string to Id mapping.
 * @readonly
 * @property {number}  UNKNOWN                 - Unknown/undefined.
 * @property {number}  UNKNOWN_METHOD          - Client attempted to call a method unknown to the server.
 * @property {number}  INVALID_MESSAGE_TYPE    - Client passed an unknown/unsupported MessageType.
 * @property {number}  WRONG_METHOD_NAME       - Unused.
 * @property {number}  BAD_SEQUENCE_ID         - Unused in Thrift RPC, used to flag proprietary sequence number errors.
 * @property {number}  MISSING_RESULT          - Raised by a server processor if a handler fails to supply the required return result.
 * @property {number}  INTERNAL_ERROR          - Something bad happened.
 * @property {number}  PROTOCOL_ERROR          - The protocol layer failed to serialize or deserialize data.
 * @property {number}  INVALID_TRANSFORM       - Unused.
 * @property {number}  INVALID_PROTOCOL        - The protocol (or version) is not supported.
 * @property {number}  UNSUPPORTED_CLIENT_TYPE - Unused.
 */
Thrift.TApplicationExceptionType = {
    'UNKNOWN' : 0,
    'UNKNOWN_METHOD' : 1,
    'INVALID_MESSAGE_TYPE' : 2,
    'WRONG_METHOD_NAME' : 3,
    'BAD_SEQUENCE_ID' : 4,
    'MISSING_RESULT' : 5,
    'INTERNAL_ERROR' : 6,
    'PROTOCOL_ERROR' : 7,
    'INVALID_TRANSFORM' : 8,
    'INVALID_PROTOCOL' : 9,
    'UNSUPPORTED_CLIENT_TYPE' : 10
};

/**
 * Initializes a Thrift TApplicationException instance.
 * @constructor
 * @augments Thrift.TException
 * @param {string} message - The TApplicationException message (distinct from the Error message).
 * @param {Thrift.TApplicationExceptionType} [code] - The TApplicationExceptionType code.
 * @classdesc TApplicationException is the exception class used to propagate exceptions from an RPC server back to a calling client.
*/
Thrift.TApplicationException = function(message, code) {
    this.message = message;
    this.code = typeof code === "number" ? code : 0;
};
Thrift.inherits(Thrift.TApplicationException, Thrift.TException, 'TApplicationException');

/**
 * Read a TApplicationException from the supplied protocol.
 * @param {object} input - The input protocol to read from.
 */
Thrift.TApplicationException.prototype.read = function(input) {
    while (1) {
        var ret = input.readFieldBegin();

        if (ret.ftype == Thrift.Type.STOP) {
            break;
        }

        var fid = ret.fid;

        switch (fid) {
            case 1:
                if (ret.ftype == Thrift.Type.STRING) {
                    ret = input.readString();
                    this.message = ret.value;
                } else {
                    ret = input.skip(ret.ftype);
                }
                break;
            case 2:
                if (ret.ftype == Thrift.Type.I32) {
                    ret = input.readI32();
                    this.code = ret.value;
                } else {
                    ret = input.skip(ret.ftype);
                }
                break;
           default:
                ret = input.skip(ret.ftype);
                break;
        }

        input.readFieldEnd();
    }

    input.readStructEnd();
};

/**
 * Wite a TApplicationException to the supplied protocol.
 * @param {object} output - The output protocol to write to.
 */
Thrift.TApplicationException.prototype.write = function(output) {
    output.writeStructBegin('TApplicationException');

    if (this.message) {
        output.writeFieldBegin('message', Thrift.Type.STRING, 1);
        output.writeString(this.getMessage());
        output.writeFieldEnd();
    }

    if (this.code) {
        output.writeFieldBegin('type', Thrift.Type.I32, 2);
        output.writeI32(this.code);
        output.writeFieldEnd();
    }

    output.writeFieldStop();
    output.writeStructEnd();
};

/**
 * Returns the application exception code set on the exception.
 * @readonly
 * @returns {Thrift.TApplicationExceptionType} exception code
 */
Thrift.TApplicationException.prototype.getCode = function() {
    return this.code;
};

/**
 * Constructor Function for the XHR transport.
 * If you do not specify a url then you must handle XHR operations on
 * your own. This type can also be constructed using the Transport alias
 * for backward compatibility.
 * @constructor
 * @param {string} [url] - The URL to connect to.
 * @classdesc The Apache Thrift Transport layer performs byte level I/O 
 * between RPC clients and servers. The JavaScript TXHRTransport object 
 * uses Http[s]/XHR. Target servers must implement the http[s] transport
 * (see: node.js example server_http.js).
 * @example
 *     var transport = new Thrift.TXHRTransport("http://localhost:8585");
 */
Thrift.Transport = Thrift.TXHRTransport = function(url, options) {
    this.url = url;
    this.wpos = 0;
    this.rpos = 0;
    this.useCORS = (options && options.useCORS);
    this.send_buf = '';
    this.recv_buf = '';
};

Thrift.TXHRTransport.prototype = {
    /**
     * Gets the browser specific XmlHttpRequest Object.
     * @returns {object} the browser XHR interface object
     */
    getXmlHttpRequestObject: function() {
        try { return new XMLHttpRequest(); } catch (e1) { }
        try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch (e2) { }
        try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch (e3) { }

        throw "Your browser doesn't support XHR.";
    },

    /**
     * Sends the current XRH request if the transport was created with a URL 
     * and the async parameter is false. If the transport was not created with
     * a URL, or the async parameter is True and no callback is provided, or 
     * the URL is an empty string, the current send buffer is returned.
     * @param {object} async - If true the current send buffer is returned.
     * @param {object} callback - Optional async completion callback 
     * @returns {undefined|string} Nothing or the current send buffer.
     * @throws {string} If XHR fails.
     */
    flush: function(async, callback) {
        var self = this;
        if ((async && !callback) || this.url === undefined || this.url === '') {
            return this.send_buf;
        }

        var xreq = this.getXmlHttpRequestObject();

        if (xreq.overrideMimeType) {
            xreq.overrideMimeType('application/json');
        }

        if (callback) {
            //Ignore XHR callbacks until the data arrives, then call the
            //  client's callback
            xreq.onreadystatechange = 
              (function() {
                var clientCallback = callback;    
                return function() {
                  if (this.readyState == 4 && this.status == 200) {
                    self.setRecvBuffer(this.responseText);
                    clientCallback();
                  }
                };
              }());
        }

        xreq.open('POST', this.url, !!async);
        xreq.send(this.send_buf);
        if (async && callback) {
            return;
        }

        if (xreq.readyState != 4) {
            throw 'encountered an unknown ajax ready state: ' + xreq.readyState;
        }

        if (xreq.status != 200) {
            throw 'encountered a unknown request status: ' + xreq.status;
        }

        this.recv_buf = xreq.responseText;
        this.recv_buf_sz = this.recv_buf.length;
        this.wpos = this.recv_buf.length;
        this.rpos = 0;
    },

    /**
     * Creates a jQuery XHR object to be used for a Thrift server call.
     * @param {object} client - The Thrift Service client object generated by the IDL compiler.
     * @param {object} postData - The message to send to the server.
     * @param {function} args - The original call arguments with the success call back at the end.
     * @param {function} recv_method - The Thrift Service Client receive method for the call.
     * @returns {object} A new jQuery XHR object.
     * @throws {string} If the jQuery version is prior to 1.5 or if jQuery is not found.
     */
    jqRequest: function(client, postData, args, recv_method) {
        if (typeof jQuery === 'undefined' ||
            typeof jQuery.Deferred === 'undefined') {
            throw 'Thrift.js requires jQuery 1.5+ to use asynchronous requests';
        }

        var thriftTransport = this;

        var jqXHR = jQuery.ajax({
            url: this.url,
            data: postData,
            type: 'POST',
            cache: false,
            contentType: 'application/json',
            dataType: 'text thrift',
            converters: {
                'text thrift' : function(responseData) {
                    thriftTransport.setRecvBuffer(responseData);
                    var value = recv_method.call(client);
                    return value;
                }
            },
            context: client,
            success: jQuery.makeArray(args).pop()
        });

        return jqXHR;
    },

    /**
     * Sets the buffer to provide the protocol when deserializing.
     * @param {string} buf - The buffer to supply the protocol.
     */
    setRecvBuffer: function(buf) {
        this.recv_buf = buf;
        this.recv_buf_sz = this.recv_buf.length;
        this.wpos = this.recv_buf.length;
        this.rpos = 0;
    },

    /**
     * Returns true if the transport is open, XHR always returns true.
     * @readonly
     * @returns {boolean} Always True.
     */    
    isOpen: function() {
        return true;
    },

    /**
     * Opens the transport connection, with XHR this is a nop.
     */    
    open: function() {},

    /**
     * Closes the transport connection, with XHR this is a nop.
     */    
    close: function() {},

    /**
     * Returns the specified number of characters from the response
     * buffer.
     * @param {number} len - The number of characters to return.
     * @returns {string} Characters sent by the server.
     */
    read: function(len) {
        var avail = this.wpos - this.rpos;

        if (avail === 0) {
            return '';
        }

        var give = len;

        if (avail < len) {
            give = avail;
        }

        var ret = this.read_buf.substr(this.rpos, give);
        this.rpos += give;

        //clear buf when complete?
        return ret;
    },

    /**
     * Returns the entire response buffer.
     * @returns {string} Characters sent by the server.
     */
    readAll: function() {
        return this.recv_buf;
    },

    /**
     * Sets the send buffer to buf.
     * @param {string} buf - The buffer to send.
     */    
    write: function(buf) {
        this.send_buf = buf;
    },

    /**
     * Returns the send buffer.
     * @readonly
     * @returns {string} The send buffer.
     */ 
    getSendBuffer: function() {
        return this.send_buf;
    }

};


/**
 * Constructor Function for the WebSocket transport.
 * @constructor
 * @param {string} [url] - The URL to connect to.
 * @classdesc The Apache Thrift Transport layer performs byte level I/O 
 * between RPC clients and servers. The JavaScript TWebSocketTransport object 
 * uses the WebSocket protocol. Target servers must implement WebSocket.
 * (see: node.js example server_http.js).
 * @example
 *   var transport = new Thrift.TWebSocketTransport("http://localhost:8585");
 */
Thrift.TWebSocketTransport = function(url) {
    this.__reset(url);
};

Thrift.TWebSocketTransport.prototype = {
    __reset: function(url) {
      this.url = url;             //Where to connect
      this.socket = null;         //The web socket
      this.callbacks = [];        //Pending callbacks
      this.send_pending = [];     //Buffers/Callback pairs waiting to be sent
      this.send_buf = '';         //Outbound data, immutable until sent
      this.recv_buf = '';         //Inbound data
      this.rb_wpos = 0;           //Network write position in receive buffer
      this.rb_rpos = 0;           //Client read position in receive buffer
    },

    /**
     * Sends the current WS request and registers callback. The async 
     * parameter is ignored (WS flush is always async) and the callback 
     * function parameter is required.
     * @param {object} async - Ignored.
     * @param {object} callback - The client completion callback.
     * @returns {undefined|string} Nothing (undefined) 
     */
    flush: function(async, callback) {
      var self = this;
      if (this.isOpen()) {
        //Send data and register a callback to invoke the client callback
        this.socket.send(this.send_buf); 
        this.callbacks.push((function() {
          var clientCallback = callback;    
          return function(msg) {
            self.setRecvBuffer(msg);
            clientCallback();
          };
        }()));
      } else {
        //Queue the send to go out __onOpen
        this.send_pending.push({
          buf: this.send_buf,
          cb:  callback
        });
      }
    },

    __onOpen: function() { 
       var self = this;
       if (this.send_pending.length > 0) {
          //If the user made calls before the connection was fully 
          //open, send them now
          this.send_pending.forEach(function(elem) {
             this.socket.send(elem.buf);
             this.callbacks.push((function() {
               var clientCallback = elem.cb;    
               return function(msg) {
                  self.setRecvBuffer(msg);
                  clientCallback();
               };
             }()));
          });
          this.send_pending = [];
       }
    },
    
    __onClose: function(evt) { 
      this.__reset(this.url);
    },
     
    __onMessage: function(evt) {
      if (this.callbacks.length) {
        this.callbacks.shift()(evt.data);
      }
    },
     
    __onError: function(evt) { 
      console.log("Thrift WebSocket Error: " + evt.toString());
      this.socket.close();
    },

    /**
     * Sets the buffer to use when receiving server responses.
     * @param {string} buf - The buffer to receive server responses.
     */
    setRecvBuffer: function(buf) {
        this.recv_buf = buf;
        this.recv_buf_sz = this.recv_buf.length;
        this.wpos = this.recv_buf.length;
        this.rpos = 0;
    },

    /**
     * Returns true if the transport is open
     * @readonly
     * @returns {boolean} 
     */    
    isOpen: function() {
        return this.socket && this.socket.readyState == this.socket.OPEN;
    },

    /**
     * Opens the transport connection
     */    
    open: function() {
      //If OPEN/CONNECTING/CLOSING ignore additional opens
      if (this.socket && this.socket.readyState != this.socket.CLOSED) {
        return;
      }
      //If there is no socket or the socket is closed:
      this.socket = new WebSocket(this.url);
      this.socket.onopen = this.__onOpen.bind(this); 
      this.socket.onmessage = this.__onMessage.bind(this); 
      this.socket.onerror = this.__onError.bind(this); 
      this.socket.onclose = this.__onClose.bind(this); 
    },

    /**
     * Closes the transport connection
     */    
    close: function() {
      this.socket.close();
    },

    /**
     * Returns the specified number of characters from the response
     * buffer.
     * @param {number} len - The number of characters to return.
     * @returns {string} Characters sent by the server.
     */
    read: function(len) {
        var avail = this.wpos - this.rpos;

        if (avail === 0) {
            return '';
        }

        var give = len;

        if (avail < len) {
            give = avail;
        }

        var ret = this.read_buf.substr(this.rpos, give);
        this.rpos += give;

        //clear buf when complete?
        return ret;
    },

    /**
     * Returns the entire response buffer.
     * @returns {string} Characters sent by the server.
     */
    readAll: function() {
        return this.recv_buf;
    },

    /**
     * Sets the send buffer to buf.
     * @param {string} buf - The buffer to send.
     */    
    write: function(buf) {
        this.send_buf = buf;
    },

    /**
     * Returns the send buffer.
     * @readonly
     * @returns {string} The send buffer.
     */ 
    getSendBuffer: function() {
        return this.send_buf;
    }

};

/**
 * Initializes a Thrift JSON protocol instance.
 * @constructor
 * @param {Thrift.Transport} transport - The transport to serialize to/from.
 * @classdesc Apache Thrift Protocols perform serialization which enables cross 
 * language RPC. The Protocol type is the JavaScript browser implementation 
 * of the Apache Thrift TJSONProtocol.
 * @example
 *     var protocol  = new Thrift.Protocol(transport);
 */
Thrift.TJSONProtocol = Thrift.Protocol = function(transport) {
    this.tstack = [];
    this.tpos = [];
    this.transport = transport;
};

/**
 * Thrift IDL type Id to string mapping.
 * @readonly
 * @see {@link Thrift.Type}
 */
Thrift.Protocol.Type = {};
Thrift.Protocol.Type[Thrift.Type.BOOL] = '"tf"';
Thrift.Protocol.Type[Thrift.Type.BYTE] = '"i8"';
Thrift.Protocol.Type[Thrift.Type.I16] = '"i16"';
Thrift.Protocol.Type[Thrift.Type.I32] = '"i32"';
Thrift.Protocol.Type[Thrift.Type.I64] = '"i64"';
Thrift.Protocol.Type[Thrift.Type.DOUBLE] = '"dbl"';
Thrift.Protocol.Type[Thrift.Type.STRUCT] = '"rec"';
Thrift.Protocol.Type[Thrift.Type.STRING] = '"str"';
Thrift.Protocol.Type[Thrift.Type.MAP] = '"map"';
Thrift.Protocol.Type[Thrift.Type.LIST] = '"lst"';
Thrift.Protocol.Type[Thrift.Type.SET] = '"set"';

/**
 * Thrift IDL type string to Id mapping.
 * @readonly
 * @see {@link Thrift.Type}
 */
Thrift.Protocol.RType = {};
Thrift.Protocol.RType.tf = Thrift.Type.BOOL;
Thrift.Protocol.RType.i8 = Thrift.Type.BYTE;
Thrift.Protocol.RType.i16 = Thrift.Type.I16;
Thrift.Protocol.RType.i32 = Thrift.Type.I32;
Thrift.Protocol.RType.i64 = Thrift.Type.I64;
Thrift.Protocol.RType.dbl = Thrift.Type.DOUBLE;
Thrift.Protocol.RType.rec = Thrift.Type.STRUCT;
Thrift.Protocol.RType.str = Thrift.Type.STRING;
Thrift.Protocol.RType.map = Thrift.Type.MAP;
Thrift.Protocol.RType.lst = Thrift.Type.LIST;
Thrift.Protocol.RType.set = Thrift.Type.SET;

/**
 * The TJSONProtocol version number.
 * @readonly
 * @const {number} Version
 * @memberof Thrift.Protocol
 */
 Thrift.Protocol.Version = 1;

Thrift.Protocol.prototype = {
    /**
     * Returns the underlying transport.
     * @readonly
     * @returns {Thrift.Transport} The underlying transport.
     */ 
    getTransport: function() {
        return this.transport;
    },

    /**
     * Serializes the beginning of a Thrift RPC message.
     * @param {string} name - The service method to call.
     * @param {Thrift.MessageType} messageType - The type of method call.
     * @param {number} seqid - The sequence number of this call (always 0 in Apache Thrift).
     */
    writeMessageBegin: function(name, messageType, seqid) {
        this.tstack = [];
        this.tpos = [];

        this.tstack.push([Thrift.Protocol.Version, '"' +
            name + '"', messageType, seqid]);
    },

    /**
     * Serializes the end of a Thrift RPC message.
     */
    writeMessageEnd: function() {
        var obj = this.tstack.pop();

        this.wobj = this.tstack.pop();
        this.wobj.push(obj);

        this.wbuf = '[' + this.wobj.join(',') + ']';

        this.transport.write(this.wbuf);
     },


    /**
     * Serializes the beginning of a struct.
     * @param {string} name - The name of the struct.
     */
    writeStructBegin: function(name) {
        this.tpos.push(this.tstack.length);
        this.tstack.push({});
    },

    /**
     * Serializes the end of a struct.
     */
    writeStructEnd: function() {

        var p = this.tpos.pop();
        var struct = this.tstack[p];
        var str = '{';
        var first = true;
        for (var key in struct) {
            if (first) {
                first = false;
            } else {
                str += ',';
            }

            str += key + ':' + struct[key];
        }

        str += '}';
        this.tstack[p] = str;
    },

    /**
     * Serializes the beginning of a struct field.
     * @param {string} name - The name of the field.
     * @param {Thrift.Protocol.Type} fieldType - The data type of the field.
     * @param {number} fieldId - The field's unique identifier.
     */
    writeFieldBegin: function(name, fieldType, fieldId) {
        this.tpos.push(this.tstack.length);
        this.tstack.push({ 'fieldId': '"' +
            fieldId + '"', 'fieldType': Thrift.Protocol.Type[fieldType]
        });

    },

    /**
     * Serializes the end of a field.
     */
    writeFieldEnd: function() {
        var value = this.tstack.pop();
        var fieldInfo = this.tstack.pop();

        this.tstack[this.tstack.length - 1][fieldInfo.fieldId] = '{' +
            fieldInfo.fieldType + ':' + value + '}';
        this.tpos.pop();
    },

    /**
     * Serializes the end of the set of fields for a struct.
     */
    writeFieldStop: function() {
        //na
    },

    /**
     * Serializes the beginning of a map collection.
     * @param {Thrift.Type} keyType - The data type of the key.
     * @param {Thrift.Type} valType - The data type of the value.
     * @param {number} [size] - The number of elements in the map (ignored).
     */
    writeMapBegin: function(keyType, valType, size) {
        this.tpos.push(this.tstack.length);
        this.tstack.push([Thrift.Protocol.Type[keyType],
            Thrift.Protocol.Type[valType], 0]);
    },

    /**
     * Serializes the end of a map.
     */
    writeMapEnd: function() {
        var p = this.tpos.pop();

        if (p == this.tstack.length) {
            return;
        }

        if ((this.tstack.length - p - 1) % 2 !== 0) {
            this.tstack.push('');
        }

        var size = (this.tstack.length - p - 1) / 2;

        this.tstack[p][this.tstack[p].length - 1] = size;

        var map = '}';
        var first = true;
        while (this.tstack.length > p + 1) {
            var v = this.tstack.pop();
            var k = this.tstack.pop();
            if (first) {
                first = false;
            } else {
                map = ',' + map;
            }

            if (! isNaN(k)) { k = '"' + k + '"'; } //json "keys" need to be strings
            map = k + ':' + v + map;
        }
        map = '{' + map;

        this.tstack[p].push(map);
        this.tstack[p] = '[' + this.tstack[p].join(',') + ']';
    },

    /**
     * Serializes the beginning of a list collection.
     * @param {Thrift.Type} elemType - The data type of the elements.
     * @param {number} size - The number of elements in the list.
     */
    writeListBegin: function(elemType, size) {
        this.tpos.push(this.tstack.length);
        this.tstack.push([Thrift.Protocol.Type[elemType], size]);
    },

    /**
     * Serializes the end of a list.
     */
    writeListEnd: function() {
        var p = this.tpos.pop();

        while (this.tstack.length > p + 1) {
            var tmpVal = this.tstack[p + 1];
            this.tstack.splice(p + 1, 1);
            this.tstack[p].push(tmpVal);
        }

        this.tstack[p] = '[' + this.tstack[p].join(',') + ']';
    },

    /**
     * Serializes the beginning of a set collection.
     * @param {Thrift.Type} elemType - The data type of the elements.
     * @param {number} size - The number of elements in the list.
     */
    writeSetBegin: function(elemType, size) {
        this.tpos.push(this.tstack.length);
        this.tstack.push([Thrift.Protocol.Type[elemType], size]);
    },

    /**
     * Serializes the end of a set.
     */
    writeSetEnd: function() {
        var p = this.tpos.pop();

        while (this.tstack.length > p + 1) {
            var tmpVal = this.tstack[p + 1];
            this.tstack.splice(p + 1, 1);
            this.tstack[p].push(tmpVal);
        }

        this.tstack[p] = '[' + this.tstack[p].join(',') + ']';
    },

    /** Serializes a boolean */
    writeBool: function(value) {
        this.tstack.push(value ? 1 : 0);
    },

    /** Serializes a number */
    writeByte: function(i8) {
        this.tstack.push(i8);
    },

    /** Serializes a number */
    writeI16: function(i16) {
        this.tstack.push(i16);
    },

    /** Serializes a number */
    writeI32: function(i32) {
        this.tstack.push(i32);
    },

    /** Serializes a number */
    writeI64: function(i64) {
        this.tstack.push(i64);
    },

    /** Serializes a number */
    writeDouble: function(dbl) {
        this.tstack.push(dbl);
    },

    /** Serializes a string */
    writeString: function(str) {
        // We do not encode uri components for wire transfer:
        if (str === null) {
            this.tstack.push(null);
        } else {
            // concat may be slower than building a byte buffer
            var escapedString = '';
            for (var i = 0; i < str.length; i++) {
                var ch = str.charAt(i);      // a single double quote: "
                if (ch === '\"') {
                    escapedString += '\\\"'; // write out as: \"
                } else if (ch === '\\') {    // a single backslash
                    escapedString += '\\\\'; // write out as double backslash 
                } else if (ch === '\b') {    // a single backspace: invisible
                    escapedString += '\\b';  // write out as: \b"
                } else if (ch === '\f') {    // a single formfeed: invisible
                    escapedString += '\\f';  // write out as: \f"
                } else if (ch === '\n') {    // a single newline: invisible
                    escapedString += '\\n';  // write out as: \n"
                } else if (ch === '\r') {    // a single return: invisible
                    escapedString += '\\r';  // write out as: \r"
                } else if (ch === '\t') {    // a single tab: invisible
                    escapedString += '\\t';  // write out as: \t"
                } else {
                    escapedString += ch;     // Else it need not be escaped
                }
            }
            this.tstack.push('"' + escapedString + '"');
        }
    },

    /** Serializes a string */
    writeBinary: function(str) {
        this.writeString(str);
    },

    /**
       @class
       @name AnonReadMessageBeginReturn
       @property {string} fname - The name of the service method.
       @property {Thrift.MessageType} mtype - The type of message call.
       @property {number} rseqid - The sequence number of the message (0 in Thrift RPC).
     */
    /** 
     * Deserializes the beginning of a message. 
     * @returns {AnonReadMessageBeginReturn}
     */
    readMessageBegin: function() {
        this.rstack = [];
        this.rpos = [];

        if (typeof JSON !== 'undefined' && typeof JSON.parse === 'function') {
            this.robj = JSON.parse(this.transport.readAll());
        } else if (typeof jQuery !== 'undefined') {
            this.robj = jQuery.parseJSON(this.transport.readAll());
        } else {
            this.robj = eval(this.transport.readAll());
        }

        var r = {};
        var version = this.robj.shift();

        if (version != Thrift.Protocol.Version) {
            throw 'Wrong thrift protocol version: ' + version;
        }

        r.fname = this.robj.shift();
        r.mtype = this.robj.shift();
        r.rseqid = this.robj.shift();


        //get to the main obj
        this.rstack.push(this.robj.shift());

        return r;
    },

    /** Deserializes the end of a message. */
    readMessageEnd: function() {
    },

    /** 
     * Deserializes the beginning of a struct. 
     * @param {string} [name] - The name of the struct (ignored)
     * @returns {object} - An object with an empty string fname property
     */    
    readStructBegin: function(name) {
        var r = {};
        r.fname = '';

        //incase this is an array of structs
        if (this.rstack[this.rstack.length - 1] instanceof Array) {
            this.rstack.push(this.rstack[this.rstack.length - 1].shift());
        }

        return r;
    },

    /** Deserializes the end of a struct. */
    readStructEnd: function() {
        if (this.rstack[this.rstack.length - 2] instanceof Array) {
            this.rstack.pop();
        }
    },

    /**
       @class
       @name AnonReadFieldBeginReturn
       @property {string} fname - The name of the field (always '').
       @property {Thrift.Type} ftype - The data type of the field.
       @property {number} fid - The unique identifier of the field.
     */
    /** 
     * Deserializes the beginning of a field. 
     * @returns {AnonReadFieldBeginReturn}
     */
    readFieldBegin: function() {
        var r = {};

        var fid = -1;
        var ftype = Thrift.Type.STOP;

        //get a fieldId
        for (var f in (this.rstack[this.rstack.length - 1])) {
            if (f === null) {
              continue;
            }

            fid = parseInt(f, 10);
            this.rpos.push(this.rstack.length);

            var field = this.rstack[this.rstack.length - 1][fid];

            //remove so we don't see it again
            delete this.rstack[this.rstack.length - 1][fid];

            this.rstack.push(field);

            break;
        }

        if (fid != -1) {

            //should only be 1 of these but this is the only
            //way to match a key
            for (var i in (this.rstack[this.rstack.length - 1])) {
                if (Thrift.Protocol.RType[i] === null) {
                    continue;
                }

                ftype = Thrift.Protocol.RType[i];
                this.rstack[this.rstack.length - 1] =
                    this.rstack[this.rstack.length - 1][i];
            }
        }

        r.fname = '';
        r.ftype = ftype;
        r.fid = fid;

        return r;
    },

    /** Deserializes the end of a field. */
    readFieldEnd: function() {
        var pos = this.rpos.pop();

        //get back to the right place in the stack
        while (this.rstack.length > pos) {
            this.rstack.pop();
        }

    },

    /**
       @class
       @name AnonReadMapBeginReturn
       @property {Thrift.Type} ktype - The data type of the key.
       @property {Thrift.Type} vtype - The data type of the value.
       @property {number} size - The number of elements in the map.
     */
    /** 
     * Deserializes the beginning of a map. 
     * @returns {AnonReadMapBeginReturn}
     */
    readMapBegin: function() {
        var map = this.rstack.pop();
        var first = map.shift();
        if (first instanceof Array) {
          this.rstack.push(map);
          map = first;
          first = map.shift();
        }

        var r = {};
        r.ktype = Thrift.Protocol.RType[first];
        r.vtype = Thrift.Protocol.RType[map.shift()];
        r.size = map.shift();


        this.rpos.push(this.rstack.length);
        this.rstack.push(map.shift());

        return r;
    },

    /** Deserializes the end of a map. */
    readMapEnd: function() {
        this.readFieldEnd();
    },

    /**
       @class
       @name AnonReadColBeginReturn
       @property {Thrift.Type} etype - The data type of the element.
       @property {number} size - The number of elements in the collection.
     */
    /** 
     * Deserializes the beginning of a list. 
     * @returns {AnonReadColBeginReturn}
     */
    readListBegin: function() {
        var list = this.rstack[this.rstack.length - 1];

        var r = {};
        r.etype = Thrift.Protocol.RType[list.shift()];
        r.size = list.shift();

        this.rpos.push(this.rstack.length);
        this.rstack.push(list);

        return r;
    },

    /** Deserializes the end of a list. */
    readListEnd: function() {
        this.readFieldEnd();
    },

    /** 
     * Deserializes the beginning of a set. 
     * @returns {AnonReadColBeginReturn}
     */
    readSetBegin: function(elemType, size) {
        return this.readListBegin(elemType, size);
    },

    /** Deserializes the end of a set. */
    readSetEnd: function() {
        return this.readListEnd();
    },

    /** Returns an object with a value property set to 
     *  False unless the next number in the protocol buffer 
     *  is 1, in which case the value property is True */
    readBool: function() {
        var r = this.readI32();

        if (r !== null && r.value == '1') {
            r.value = true;
        } else {
            r.value = false;
        }

        return r;
    },

    /** Returns the an object with a value property set to the 
        next value found in the protocol buffer */
    readByte: function() {
        return this.readI32();
    },

    /** Returns the an object with a value property set to the 
        next value found in the protocol buffer */
    readI16: function() {
        return this.readI32();
    },

    /** Returns the an object with a value property set to the 
        next value found in the protocol buffer */
    readI32: function(f) {
        if (f === undefined) {
            f = this.rstack[this.rstack.length - 1];
        }

        var r = {};

        if (f instanceof Array) {
            if (f.length === 0) {
                r.value = undefined;
            } else {
                r.value = f.shift();
            }
        } else if (f instanceof Object) {
           for (var i in f) {
                if (i === null) {
                  continue;
                }
                this.rstack.push(f[i]);
                delete f[i];

                r.value = i;
                break;
           }
        } else {
            r.value = f;
            this.rstack.pop();
        }

        return r;
    },

    /** Returns the an object with a value property set to the 
        next value found in the protocol buffer */
    readI64: function() {
        return this.readI32();
    },

    /** Returns the an object with a value property set to the 
        next value found in the protocol buffer */
    readDouble: function() {
        return this.readI32();
    },

    /** Returns the an object with a value property set to the 
        next value found in the protocol buffer */
    readString: function() {
        var r = this.readI32();
        return r;
    },

    /** Returns the an object with a value property set to the 
        next value found in the protocol buffer */
    readBinary: function() {
        return this.readString();
    },

    /** 
     * Method to arbitrarily skip over data */
    skip: function(type) {
        var ret, i;
        switch (type) {
            case Thrift.Type.STOP:
                return null;

            case Thrift.Type.BOOL:
                return this.readBool();

            case Thrift.Type.BYTE:
                return this.readByte();

            case Thrift.Type.I16:
                return this.readI16();

            case Thrift.Type.I32:
                return this.readI32();

            case Thrift.Type.I64:
                return this.readI64();

            case Thrift.Type.DOUBLE:
                return this.readDouble();

            case Thrift.Type.STRING:
                return this.readString();

            case Thrift.Type.STRUCT:
                this.readStructBegin();
                while (true) {
                    ret = this.readFieldBegin();
                    if (ret.ftype == Thrift.Type.STOP) {
                        break;
                    }
                    this.skip(ret.ftype);
                    this.readFieldEnd();
                }
                this.readStructEnd();
                return null;

            case Thrift.Type.MAP:
                ret = this.readMapBegin();
                for (i = 0; i < ret.size; i++) {
                    if (i > 0) {
                        if (this.rstack.length > this.rpos[this.rpos.length - 1] + 1) {
                            this.rstack.pop();
                        }
                    }
                    this.skip(ret.ktype);
                    this.skip(ret.vtype);
                }
                this.readMapEnd();
                return null;

            case Thrift.Type.SET:
                ret = this.readSetBegin();
                for (i = 0; i < ret.size; i++) {
                    this.skip(ret.etype);
                }
                this.readSetEnd();
                return null;

            case Thrift.Type.LIST:
                ret = this.readListBegin();
                for (i = 0; i < ret.size; i++) {
                    this.skip(ret.etype);
                }
                this.readListEnd();
                return null;
        }
    }
};


/**
 * Initializes a MutilplexProtocol Implementation as a Wrapper for Thrift.Protocol
 * @constructor
 */
Thrift.MultiplexProtocol = function (srvName, trans, strictRead, strictWrite) {
    Thrift.Protocol.call(this, trans, strictRead, strictWrite);
    this.serviceName = srvName;
};
Thrift.inherits(Thrift.MultiplexProtocol, Thrift.Protocol, 'multiplexProtocol');

/** Override writeMessageBegin method of prototype*/
Thrift.MultiplexProtocol.prototype.writeMessageBegin = function (name, type, seqid) {

    if (type === Thrift.MessageType.CALL || type === Thrift.MessageType.ONEWAY) {
        Thrift.Protocol.prototype.writeMessageBegin.call(this, this.serviceName + ":" + name, type, seqid);
    } else {
        Thrift.Protocol.prototype.writeMessageBegin.call(this, name, type, seqid);
    }
};

Thrift.Multiplexer = function () {
    this.seqid = 0;
};

/** Instantiates a multiplexed client for a specific service
 * @constructor
 * @param {String} serviceName - The transport to serialize to/from.
 * @param {Thrift.ServiceClient} SCl - The Service Client Class
 * @param {Thrift.Transport} transport - Thrift.Transport instance which provides remote host:port
 * @example
 *    var mp = new Thrift.Multiplexer();
 *    var transport = new Thrift.Transport("http://localhost:9090/foo.thrift");
 *    var protocol = new Thrift.Protocol(transport);
 *    var client = mp.createClient('AuthService', AuthServiceClient, transport);
*/
Thrift.Multiplexer.prototype.createClient = function (serviceName, SCl, transport) {
    if (SCl.Client) {
        SCl = SCl.Client;
    }
    var self = this;
    SCl.prototype.new_seqid = function () {
        self.seqid += 1;
        return self.seqid;
    };
    var client = new SCl(new Thrift.MultiplexProtocol(serviceName, transport));

    return client;
};




//
// Intended for inclusion after the base, external thrift.js source and generated code.  
// This overrides the flat-out incorrect thrift code that needs to be repaired.
//
// Note: it would be better if these fixes could be integrated directly into the 
// thrift repo, but the overhead and turn-around time of doing this properly is, 
// at the moment, not a good fit to the our development process.
//


// Override TXHRTransport.flush
//
// The transport flush method is *broken*.  It violates the basic rule than 
// asynchronous functions must *always* call the callback, even on errors and 
// exceptions.  The base 0.9.2 implementation only calls the callback on 
// status 200 and never invokes the client callback on HTTP status errors.
// 
Thrift.TXHRTransport.prototype.flush = function(async, callback) {
    var self = this;
    if ((async && !callback) || this.url === undefined || this.url === '') {
        return this.send_buf;
    }

    var xreq = this.getXmlHttpRequestObject();

    if (xreq.overrideMimeType) {
        xreq.overrideMimeType('application/json');
    }

    if (callback) {
        //Ignore XHR callbacks until the data arrives, then call the
        //  client's callback
        //========
        // BEGIN CODE PATCH 
        //========
        /*
          xreq.onreadystatechange = 
          (function() {
            var clientCallback = callback;    
            return function() {
              if (this.readyState == 4 && this.status == 200) {
                self.setRecvBuffer(this.responseText);
                clientCallback();
              }
            };
          }());
        */
        //========
        // MODIFIED CODE
        //========
        xreq.onreadystatechange = function() {
            if (this.readyState == 4) {
                //
                // The incoming callback doesn't actually take an error object
                // (another limitation of the thrift code) so there's no way
                // to properly move the status code error back to client callback.
                //
                // To workaround this, short of making signficant patches to the
                // Thrift library, we *rely on the fact that we're using a JSON
                // protocol* and set the buffer to invalid JSON.  The true error
                // gets lost, but at least the client is informed of *a* failure
                // rather than radio silence.
                //
                var err = (this.status == 200) ? false : true;
                self.setRecvBuffer(err ? "http_status_not_200" : this.responseText);
                callback();
            }
        };
        //========
        // END CODE PATCH
        //========
    }

    xreq.open('POST', this.url, !!async);
    xreq.send(this.send_buf);
    if (async && callback) {
        return;
    }

    if (xreq.readyState != 4) {
        throw 'encountered an unknown ajax ready state: ' + xreq.readyState;
    }

    if (xreq.status != 200) {
        throw 'encountered a unknown request status: ' + xreq.status;
    }

    this.recv_buf = xreq.responseText;
    this.recv_buf_sz = this.recv_buf.length;
    this.wpos = this.recv_buf.length;
    this.rpos = 0;
};

module.exports.crouton_thrift = crouton_thrift;
module.exports.Thrift = Thrift;
})();
},{}],3:[function(require,module,exports){
// Provide an HTML debug overlay DIV with status information about the running
// cruntime.
//
module.exports = function(cr) {
    cr.on("options.set_debug", function(cr, enabled) {
        updateDebugOverlay(cr, enabled);
    });
};

var gDebugOverlayEnabled = false;

function updateDebugOverlay(cr, enabled) {
    
    // Ignore the case of debugging being enabled then disabled for
    // reasons of engineering prioritization (not correctness!).
    if (!enabled) {
        return;
    }
    if (gDebugOverlayEnabled) {
        return;
    }

    gDebugOverlayEnabled = true;

    cr.on("spans_recorded", function(spans) {
        var i, link, div;
        var opts = cr.options();

        // For now assume http and assume the port of the web
        // server.
        var host = opts.service_host;
        if (host.match(/^api[.-]/)) {
            host = host.replace(/^api[.-]/, "");
        }
        var url = "http://" + host + ":10001/" + opts.access_token + "/";

        // Check if the element is there, as some in-page script might have
        // cleared the BODY, etc.
        var overlay = document.getElementById("traceguide_overlay");
        if (!overlay) {
            overlay = document.createElement("div");
            overlay.id = "traceguide_overlay";
            overlay.style.position = "fixed";
            overlay.style.bottom = "0";
            overlay.style.right = "0";
            overlay.style.width = "240px";
            overlay.style.height = "120px";
            overlay.style.padding = "4px";
            overlay.style.border = "solid 1px #FFF";
            overlay.style.backgroundColor = "#0060a2";
            overlay.style.color = "#FFF";
            overlay.style.fontSize = "12px";
            overlay.style.fontFamily = "sans-serif";
            overlay.style.opacity = "0.7";

            var close = document.createElement("div");
            close.style.float = "right";
            close.style.cursor = "pointer";
            close.style.color = "#FFF";
            close.onclick = function(evt) {
                overlay.style.display = "none";
            };
            close.innerHTML = "X";
            overlay.appendChild(close);

            link = document.createElement("a");
            link.href = url;
            link.style.color = "#FFF";
            link.style.fontWeight = "bold";
            link.appendChild( document.createTextNode("traceguide.io") );
            var title = document.createElement("div");
            title.appendChild(link);
            overlay.appendChild(title);

            document.body.appendChild(overlay);
        }

        var kMaxSpans = 4;
        var totalLinks = 0;

        for (i = 0; i < overlay.childNodes.length; i++) {
            var child = overlay.childNodes[i];
            if (child.className == "traceguide_span") {
                totalLinks++;
            }
        }
        // If we've already added kMaxSpans+1 lines below the
        // 'header', then don't add anything else.
        if (totalLinks > kMaxSpans) {
            return;
        }

        // Do a primitive trace joining here: only show one link per
        // trace (i.e. one link per set of spans that will be
        // combined). We make the (possibly not true) assumption that
        // all spans in a trace will arrive in the same event (just to
        // keep things simple).
        var joinedSpans = [];
        for (i = 0; i < spans.length; i++) {
            joinedSpans.push({
                join_ids : spans[i].join_ids,
                summary : spans[i].span_name,
                oldest_micros : spans[i].oldest_micros,
                youngest_micros : spans[i].youngest_micros,
            });
        }
        for (i = 0; i < joinedSpans.length; i++) {
            for (var j = i + 1; j < joinedSpans.length; j++) {
                if ((joinedSpans[j].oldest_micros <= joinedSpans[i].youngest_micros &&
                     joinedSpans[j].youngest_micros >= joinedSpans[i].oldest_micros)) {
                    if (joinedSpans[j].oldest_micros < joinedSpans[i].oldest_micros) {
                        joinedSpans[i].summary = joinedSpans[j].summary + ", " + joinedSpans[i].summary;
                        joinedSpans[i].oldest_micros = joinedSpans[j].oldest_micros;
                    } else {
                        joinedSpans[i].summary += ", " + joinedSpans[j].summary;
                    }
                    if (joinedSpans[j].youngest_micros > joinedSpans[i].youngest_micros) {
                        joinedSpans[i].youngest_micros = joinedSpans[j].youngest_micros;
                    }
                    joinedSpans[j] = joinedSpans[joinedSpans.length - 1];
                    joinedSpans = joinedSpans.slice(0, joinedSpans.length - 1);
                    j = i;
                }
            }
        }
        
        for (i = 0; i < joinedSpans.length && totalLinks <= kMaxSpans; i++) {
            var join_key = "";
            var join_url_val = "";
            for (var key in joinedSpans[i].join_ids) {
                if (joinedSpans[i].join_ids.hasOwnProperty(key)) {
                    // Prefer end_user_id if it exists
                    if (join_key === "" || key == "end_user_id") {
                        join_key = key;
                        join_url_val = encodeURIComponent(joinedSpans[i].join_ids[key]);
                    }
                }
            }
            if (join_key === "") {
                continue;
            }

            div = document.createElement("div");
            div.className = "traceguide_span";

            link = document.createElement("a");
            // Use the halfway point between the endpoints in case
            // some further time correction happens.
            var micros = Math.round(joinedSpans[i].youngest_micros / 2 +
                                    joinedSpans[i].oldest_micros / 2);
            link.href = url + "trace/" + join_key +
                "?join_val=" + join_url_val +
                "&at_micros=" + micros;
            link.style.color = "#FFF";
            link.style.whiteSpace = "nowrap";
            link.appendChild(document.createTextNode(joinedSpans[i].summary));
            div.appendChild(link);

            overlay.appendChild(div);
            totalLinks++;
        }
    });
}

},{}],4:[function(require,module,exports){
// Collect relevant info about the environment we're running in
//
module.exports = function(cr) {

    var attrs = {};

    attrs.navigator_available = navigator ? "true" : "false";
    if (navigator) {
        attrs.navigator_app_code_name = navigator.appCodeName;
        attrs.navigator_app_name      = navigator.appName;
        attrs.navigator_app_version   = navigator.appVersion;
        attrs.navigator_do_not_track  = navigator.doNotTrack;
        attrs.navigator_language      = navigator.language;
        attrs.navigator_languages     = navigator.languages;
        attrs.navigator_platform      = navigator.platform;
        attrs.navigator_product       = navigator.product;
        attrs.navigator_product_sub   = navigator.productSub;
        attrs.navigator_user_agent    = navigator.userAgent;
        attrs.navigator_vendor        = navigator.vendor;
        attrs.navigator_vendor_sub    = navigator.vendorSub;
    }

    attrs.screen_available = screen ? "true" : "false";
    if (screen) {
        attrs.screen_width  = screen.width;
        attrs.screen_height = screen.height;
    }

    attrs.window_available = window ? "true" : "false";
    if (window) {
        attrs.window_inner_width  = window.innerWidth;
        attrs.window_inner_height = window.innerHeight;
    }

    attrs.document_available = document ? "true" : "false";
    if (document) {
        attrs.document_domain       = document.domain;
        attrs.document_uri          = document.documentURI;
        attrs.document_referrer     = document.referrer;
        attrs.document_doctype      = document.doctype;
    }


    var memoryAvailable = (window && window.performance && window.performance.memory);
    attrs.performance_memory_available = memoryAvailable ? "true" : "false";
    if (memoryAvailable) {
        var mem = performance.memory;
        attrs.performance_memory_js_heap_size_limit = mem.jsHeapSizeLimit;
        attrs.performance_memory_total_js_heap_size = mem.totalJSHeapSize;
        attrs.performance_memory_used_js_heap_size  = mem.usedJSHeapSize;
    }

    cr.attributes(attrs);
};

},{}],5:[function(require,module,exports){
// Auto-instrument AJAX calls.
//
// Chrome 41 (at least), does not allow the XMLHttpRequest object
// to be used in a typical JS prototype inheritance pattern: i.e. 
// inheriting and overriding functions doesn't "just work" for XMLHttpRequest.
// Given the XHR versions and behavioral / property differences
// between browsers for this object, reimplementing a full proxy via
// composition is a bit of nightmare.
//
// The approach here is to proxy on the global prototype and attach
// new properties to the objects as the calls come through. Slightly
// less elegant, but works.
// 
// Useful:
// - https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest
// - http://stackoverflow.com/questions/9181090/is-onload-equal-to-readystate-4-in-xmlhttprequest
// - https://github.com/jquery/jquery/blob/master/src/ajax/xhr.js
// - https://github.com/jquery/jquery/blob/master/src/ajax.js
//

var kMaxURLSnippetLength = 64;

module.exports = function (cr) {
    if (!window.XMLHttpRequest) {
        return;
    }

    var proxied = {
        open : XMLHttpRequest.prototype.open,
        send : XMLHttpRequest.prototype.send,
    };

    XMLHttpRequest.prototype.open = function(method, url) {
        if (skipInstrumentation(cr)) {
            return proxied.open.apply(this, arguments);
        }

        var span = cr.span("XMLHttpRequest");
        cr.spanForObject(this, span);
        this.__cr_url = url;

        if (url) {
            var baseURL = url.split("?")[0];
            span.event("cr/span_attributes", {
                short_url : baseURL,
            });
        }

        var openPayload = {
            arguments : Array.prototype.slice.call(arguments),
        };

        // Record document cookies if there are any
        if (document && document.cookie) {
            var cookies = document.cookie.split(";");
            var data = {};
            var count = 0;
            for (var i = 0; i < cookies.length; i++) {
                var parts = cookies[i].split("=", 2);
                if (parts.length === 2) {
                    var key = parts[0].replace(/^\s+/,"").replace(/\s+$/, "");
                    data[key] = decodeURIComponent(parts[1]);
                    count++;
                }
            }
            if (count > 0) {
                openPayload.cookies = data;
            }
        }

        // Record the URL of the AJAX request as the message.
        var message = arguments[1];
        if (message && message.length > kMaxURLSnippetLength) {
            message = message.substr(0, kMaxURLSnippetLength - 1) + "";
        }

        span.event("XMLHttpRequest.open", message, openPayload);

        this.addEventListener("readystatechange", function() {
            if (this.readyState == 4) {
                // Do *ALL* browsers send readyState 4 even on error?  If not,
                // the span will never close.

                var responseType = this.responseType;
                var payload = {
                    url          : url,
                    method       : method,
                    headers      : getResponseHeaders(this),
                    status       : this.status,
                    statusText   : this.statusText,
                    responseType : responseType,
                };

                // The responseText property is only valid if the responseType is 
                // '' or 'text'.  There are other types like 'arraybuffer' for which
                // attempting to read responseText will through an exception.
                var validResponseType = (responseType === "" || responseType == "text");
                if (validResponseType && this.responseText) {
                    // Display the payload as JSON if it's parseable as such
                    try {
                        payload.responseJSON = JSON.parse(this.responseText);
                    } catch (e) {
                        payload.responseText = this.responseText;
                    }
                } else {
                    payload.response = this.response;
                }

                if (this.status != 200) {
                    span.error("HTTP status error", this.status);
                }

                span.event("XMLHttpRequest.readystate.done", payload);
                span.end();

            } else if (this.readyState == 2) {

                span.event("XMLHttpRequest.readystate.headers_received", {
                    headers : getResponseHeaders(this),
                });
            }
        });
        
        var result = proxied.open.apply(this, arguments);

        // TODO: check the headers to see if we have an instrumented server on the
        // backend? Or if it's not going to be a CORS request?
        //
        // Unfortunately, the server needs to set explicitly set 
        // "Access-Control-Allow-Headers" to allow these on any CORS request 
        // or else an error is generated.
        
        //    this.setRequestHeader("X-Traceguide-Runtime-GUID", cr.guid());
        //    this.setRequestHeader("X-Traceguide-Span-GUID", span.guid());

        return result;
    };

    XMLHttpRequest.prototype.send = function(arg) {
        if (skipInstrumentation(cr)) {
            return proxied.send.apply(this, arguments);
        }

        var data = Array.prototype.slice.call(arguments);
        
        // If it's a single argument that can be parsed as JSON, then 
        // parse as JSON.
        if (data.length == 1) {
            try {
                data = JSON.parse(data[0]);
            } catch (e) {
                // Ignore the error
            }
        }
        cr.spanForObject(this).event("XMLHttpRequest.send", {
            url  : this.__cr_url,
            data : data,
        });
        return proxied.send.apply(this, arguments);
    };
};

function skipInstrumentation(cr) {
    // Early out of the runtime is disabled or if the XMLHttpRequest
    // is the runtime's own buffer flush (i.e. avoid recursive payload
    // capture!).
    var status = cr.status();
    return (!status.enabled || status.flushActive);
}

// Normalize the getAllResponseHeaders output
function getResponseHeaders(xhr) {
    var raw = xhr.getAllResponseHeaders();
    return raw.replace(/\r/g, "").replace(/^\s+/,"").replace(/\s+$/,"").split(/\n/);
}

},{}],6:[function(require,module,exports){
//===========================================================================//
// Standard event hooks
//===========================================================================//
//
// Note: "standard" web anything is always a mess. A conscious choice needs 
// to be made here between breadth of support for different configurations
// via polyfilling, etc. and keeping the runtime footprint tiny.  
// 
// For the near term, the latest version of Chrome is being assumed and any 
// polyfill and compatibility issues are being deferred to a later date.
// Despite just saying that Chrome is the target, the Mozilla Developer Network
// currently has the best reference on events that can be hooked into:
//
// https://developer.mozilla.org/en-US/docs/Web/Events

var kCreatePageViewSpan = false;

module.exports = function (cr) {

    // Might happen if invoked, for example, inside a web worker
    if (!document) {
        cr.error("No document object available to cruntime");
        return;
    }
    if (!window) {
        cr.error("No window object available to cruntime");
        return;
    }    

    if (kCreatePageViewSpan) {
        var spanPageView = cr.span("cr/page_view");
        spanPageView.event("cr/page_view", {
            url  : document.URL,
        });
    }

    document.addEventListener("DOMContentLoaded", function(event) {
        cr.event("cr/dom_events/DOMContentLoaded", {
            url     : document.URL,
        });
    });

    document.addEventListener("readystatechange", function () {
        cr.event("cr/dom_events/readystatechange", {
            ready_state     : document.readyState,
        });
        if (document.readyState === "complete") {
            if (performance && performance.timing) {
                // Retroactively create spans and log records for the page load times
                // http://stackoverflow.com/questions/13045767/page-load-time-with-javascript
                cr.spanManual("browser/time_to_first_byte",
                        performance.timing.requestStart * 1000.0,
                        performance.timing.responseStart * 1000.0);
                cr.spanManual("browser/response_transfer",
                        performance.timing.responseStart * 1000.0,
                        performance.timing.responseEnd * 1000.0);
                cr.spanManual("browser/dom_loading",
                        performance.timing.domLoading * 1000.0,
                        performance.timing.domInteractive * 1000.0);
                var pageLoadSpanGUID = cr.spanManual("browser/page_load",
                    performance.timing.navigationStart * 1000.0,
                    Date.now() * 1000.0);
                if (window.location && window.location.pathname) {
                    var baseURL = window.location.pathname.split("?")[0];
                    cr.logRecord({
                        span_guid           : pageLoadSpanGUID,
                        stable_name         : "cr/span_attributes",
                        payload             : {
                            short_url       : baseURL,
                        }
                    });
                }

                // Per the spec, JSON.stringify(performance.timing) == "{}", manually build
                // the payload. (https://bugzilla.mozilla.org/show_bug.cgi?id=769173)
                var timingPayload = {};
                var key;
                for (key in performance.timing) {
                    var value = performance.timing[key];
                    if (value) {
                        timingPayload[key] = value;
                    }
                }
                // Store the values relative to the start to increase the readability.
                // There's an argument that the payload values should be 1:1 to the documented
                // performance.timing structure -- which is right probably depends on what
                // we eventually want customers to be able to do with payloads.
                var offset = timingPayload.fetchStart;
                for (key in timingPayload) {
                    if (timingPayload[key] > 0) {
                        timingPayload[key] -= offset;
                    }
                }

                cr.logRecord({
                    timestamp_micros    : (performance.timing.domInteractive * 1000.0),
                    span_guid           : pageLoadSpanGUID,
                    stable_name         : "cr/performance/timing_ms",
                    message             : "browser page load timing offsets in milliseconds",
                    payload             : timingPayload,
                });
            }
        }
    });

    // NOTE: this is likely gratuitous -- capture any mouse click that we
    // can. This is not as useful as it might seem since the event cascading
    // model likely filters out the clicks of interest (buttons, links) and
    // thus leaves the actual inverse set of what we'd really like to know.
    // Could scan the document for "a", "button", ".btn" -- there are 
    // probe effect risks in that approach, but it's a possibility.  Perhaps
    // it could be an opt-in.
    document.addEventListener("click", function(evt) {
        // TODO: we can't just pass in the evt object as it has circular 
        // references and the JS cruntime doesn't marshal those correctly yet.
        var payload = {
            clientX     : evt.clientX,
            clientY     : evt.clientY,
        };
        if (evt.target) {
            payload.target_id  = evt.target.id;
            payload.class_name = evt.target.className;
            payload.tag_name   = evt.target.tagName;

            // Get the DOM path to the clicked element
            var path = [ payload.tag_name ];
            var elem = evt.target.parentNode;
            while (elem) {
                if (elem.tagName) {
                    path.push(elem.tagName);
                }
                elem = elem.parentNode;
            }
            payload.path = path.reverse().join(">");
        }
        cr.event("cr/dom_events/click", payload);
    });

    // Page unload events...
    //
    // For the record, Chrome doesn't allow you to override 
    // window.location.reload() -- so we can't intercept that and flush.
    //
    window.addEventListener("beforeunload", function () {
        cr.event("cr/dom_events/beforeunload");
        if (kCreatePageViewSpan) {
            spanPageView.end();
        }

        // NOTE: the buffer is flushed *synchronously* here.
        cr.shutdown();
    });

    window.addEventListener("unload", function () {
        cr.event("cr/dom_events/unload");
    });
};





},{}],7:[function(require,module,exports){
// Platform-specific functions to encapsulate the differences from crutinme-common

//===========================================================================//
// Constants
//===========================================================================//

var kCookieTimeToLiveSeconds = 7 * 24 * 60 * 60;
var kTraceguideSessionIdKey  = "traceguide_session_id";

//===========================================================================//
// Exports
//===========================================================================//

var lib = {};

lib._traceguideSessionId = cookie(kTraceguideSessionIdKey);

lib.isNode = false;

lib.console = console;

lib.nowMicros = (function() {
    // Is a hi-res timer available?
    if (performance &&
        performance.now &&
        performance.timing &&
        performance.timing.navigationStart) {

        var start = performance.timing.navigationStart;
        return function() {
            return Math.floor((start + performance.now()) * 1000.0);
        };
    } else {
        // The low-res timer is the best we can do
        return function() {
            return Date.now() * 1000.0;
        };
    }
})();

// Low-quality GUID: this is just a 53-bit random integer! (53 bits since the
// backing store for the number is a 64-bit float).
lib.generateGUID = function() {
    return Math.floor(Math.random() * 9007199254740992).toString(10);
};

lib.getTraceguideSessionId = function() {
    return lib._traceguideSessionId;
};

// Generate or reuse the existing runtime GUID
lib.runtimeGUID = function(groupName) {

    // The browser needs to account for the groupName for the case that multiple
    // logical apps/services/runtime groups may be hosted on the same domain, meaning
    // they *should not* share the same runtime GUID.
    var cookieKey = "traceguide_guid";
    if (groupName) {
        cookieKey += "/" + groupName;
    }

    var runtimeGUID = cookie(cookieKey);

    // A special global __cr_override_runtime_guid exists for test environments
    // where cookies and localStorage are not available.
    if (!runtimeGUID && window && window.__cr_override_runtime_guid) {
        runtimeGUID = window.__cr_override_runtime_guid;
    }

    // Check for a GUID from the existing session and create the runtime
    // GUID based off of that (i.e. keep the same runtime GUID for all 
    // browser instances in the same session).
    //
    // If there is no existing session, create a new random GUID.
    if (!runtimeGUID) {
        var sessionGUID = cookie("traceguide_session_guid");
        if (sessionGUID) {
            runtimeGUID = sessionGUID;
        } else {
            runtimeGUID = lib.generateGUID();
        }
    }

    // Always write back the cookie to renew the TTL
    cookie(cookieKey, runtimeGUID, kCookieTimeToLiveSeconds, "/");

    // Also, while we're here, check the status of a well-known key
    // that can be used to coordinate with the server to set a join ID.
    // The server may have already set this key -- or if it hasn't, the
    // browser can generate one.
    //
    // Note that it's ok that this might be used for different
    // runtime groups in different projects: the goal here is only to
    // set an id for this session. This convention is also used in
    // state.js.
    var traceguideSessionId = lib.getTraceguideSessionId();
    if (!traceguideSessionId) {
        traceguideSessionId = "rt-" + runtimeGUID;
    }
    cookie(kTraceguideSessionIdKey, traceguideSessionId, kCookieTimeToLiveSeconds, "/");

    // Record the session ID now that we've figured out if there was an
    // existing one or if we needed to generate new one.
    //
    // The not-so-well-defined point at which this variable is initialized is
    // unfortunate, but the initialization order is a bit complex: we need the 
    // groupName before the runtime GUID can be determined -- that's up to the 
    // user to specify at some point -- and the runtime GUID is needed to 
    // generate the session ID (TODO: does it have to be?).
    lib._traceguideSessionId = traceguideSessionId;

    return runtimeGUID;
};

// Doesn't need to be long-lived storage... just longer than a page load.
lib.localStore = function(key, value) {
    if (arguments.length == 2) {
        localStorage.setItem("traceguide/" + key, value);
        return;
    }
    return localStorage.getItem("traceguide/" + key);
};

var _console_obj   = console;
var _console_log   = console.log;
var _console_warn  = console.warn;
var _console_error = console.error;

var base = {
    log   : function(args) { return _console_log.apply(_console_obj, args); },
    warn  : function(args) { return _console_warn.apply(_console_obj, args); },
    error : function(args) { return _console_error.apply(_console_obj, args); },
};

lib.logger = {
    info  : base.log,
    warn  : base.warn,
    error : base.error,
    fatal : base.error,
};

lib.abort = function() {
    throw new Error("Fatal exception");
};

// TODO: support the skip & unfiltered args
lib.stackTrace = function(skip, unfiltered) {
    // This approach only works on a subset of browsers!
    var stack = new Error().stack;
    if (typeof stack === "string") {
        stack = stack.split("\n").slice(3);
        for (var i = 0; i < stack.length; i++) {
            stack[i] = stack[i].replace(/^\s*at\s+/, "");
        }
        return stack;
    } else {
        return undefined;
    }
};

var proxyFilename = "<browser>";

lib.setSourceUrl = function (url) {
    if (typeof url === "string") {
        var parts = url.split("/");
        proxyFilename = parts[parts.length - 1];
    }
};

// Returns the placeholder for the filename in a log record.
lib.defaultLogFilename = function() {
    return proxyFilename;
};

module.exports = lib;

//===========================================================================//
// Helpers
//===========================================================================//

// This function is copied directly from https://github.com/litejs/browser-cookie-lite.
// It is licensed under the MIT License and authored by Lauri Rooden.
function cookie(name, value, ttl, path, domain, secure) {
    if (arguments.length > 1) {
        var newCookie = name + "=" + encodeURIComponent(value) +
            (ttl ? "; expires=" + new Date(+new Date()+(ttl*1000)).toUTCString() : "") +
            (path   ? "; path=" + path : "") +
            (domain ? "; domain=" + domain : "") +
            (secure ? "; secure" : "");
        document.cookie = newCookie;
        return newCookie;
    }
    return decodeURIComponent((("; "+document.cookie).split("; "+name+"=")[1]||"").split(";")[0]);
}


},{}],8:[function(require,module,exports){
//===========================================================================//
// Polyfills
//===========================================================================//
// 
// Does not fill polygons; normalizes the JS environment across browsers.
// There are libraries for this sort of thing. This is just a cut & paste of
// the subset needed.
//

// See:
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create
// http://stackoverflow.com/questions/11488540/copy-prototype-for-inheritance
if (typeof Object.create != 'function') {
    Object.create = (function() {
        var Temp = function() {};
        return function (prototype) {
            if (arguments.length > 1) {
                throw Error('Second argument not supported');
            }
            if (typeof prototype != 'object') {
                throw TypeError('Argument must be an object');
            }
            Temp.prototype = prototype;
            var result = new Temp();
            Temp.prototype = null;
            return result;
        };
    })();
}
},{}],9:[function(require,module,exports){
//===========================================================================//
// Export
//===========================================================================//

var thrift_wrapper  = require("./src/generated/crouton_thrift_all.js"),
    common          = require("node/packages/rl-cruntime-common"),
    packageObject   = require("./package.json"),
    platform        = require("./src/platform_browser.js"),
    polyfill        = require("./src/polyfill.js");

var options = {
    paused              : false,
    cruntime_platform   : packageObject.name,
    cruntime_version    : packageObject.version,
    debug               : false,
};

// Check initialization options on the actual script element that included
// this.  E.g.
//
// <script src="mypath/rlcruntime-browser.min.js" data-paused="true"></script>
//
// The last script known about in the DOM should be the currently running
// script as scripts execute as soon as the browser hits the <script> tag.
var scripts = document.getElementsByTagName("SCRIPT");
var script = null;
if (scripts.length > 0) {
    script = scripts[scripts.length - 1];

    var dataPaused = script.dataset.paused;
    switch (dataPaused) {
        case "true":
        case 1:
            options.paused = true;
            break;
    }

    var accessToken = script.dataset.access_token;
    if (typeof accessToken === "string" && accessToken.length > 0) {
        options.access_token = accessToken;
    }
    var groupName = script.dataset.group_name;
    if (typeof groupName === "string" && groupName.length > 0) {
        options.group_name = groupName;
    }
    var serviceHost = script.dataset.service_host;
    if (typeof serviceHost === "string" && serviceHost.length > 0) {
        options.service_host = serviceHost;
    }
    var servicePort = script.dataset.service_port;
    if (servicePort) {
        options.service_port = parseInt(servicePort);
    }
    
    // Special case the "end_user_id" since that is by far the most likely
    // join ID to be set globally by browser instrumentation
    var endUserId = script.dataset.end_user_id;
    if (endUserId) {
        options.join_ids = { end_user_id : endUserId };
    }
    var joinIds = script.dataset.join_ids;
    if (joinIds) {
        try {
            var joinIds = JSON.parse(joinIds);
            // Handle the case that both data-end_user_id and data-join_ids are
            // used.
            if (endUserId) {
                joinIds.end_user_id = endUserId;
            }
            options.join_ids = joinIds;
        } catch (e) {
            console.error("Could not parse join_ids string:", joinIds);
        }
    }

    var enable = script.dataset.enable;
    if (typeof enable == "string") {
        if (enable == "true") {
            options.enable = true;
        } else if (enable == "false") {
            options.enable = false;
        }
    }
    var debug = script.dataset.debug;
    if (typeof debug == "string" && debug == "true") {
        options.debug = true;
    }
}

var state = common.createState({
    thriftTypes     : thrift_wrapper.crouton_thrift, 
    thriftLibrary   : thrift_wrapper.Thrift,
    platform        : platform,
    events          : {
        "preinitialize" : function(cr) {
            require("./src/initialize_debug_overlay.js")(cr);
        },
        "postinitialize" : function(cr) {
            require("./src/initialize_runtime_attributes.js")(cr);
            require("./src/instrument_ajax.js")(cr);
            require("./src/instrument_document.js")(cr);
        },
        "options.set_group_name" : function(cr) {
            // Set a default join ID based on the session ID.  Server
            // instrumentation (should) look at the traceguide_session_id cookie as
            // well to create connected traces via this join ID.
            var sessionId = platform.getTraceguideSessionId();
            if (sessionId) {
                cr.options({
                    join_ids: {
                        traceguide_session_id : sessionId,
                    },
                });
            }
        },
    }
});

var api = common.api(state);

if (script) {
    // Let the cruntime (and platform abstraction layer) know the name of the
    // current source script (which may not be cruntime-*.js if the cruntime
    // code is bundled in container script).
    api.attributes({
        cruntime_source_url : script.src,
    });
    platform.setSourceUrl(script.src.replace(/\?.*$/, ""));

    // Set the global name after the API object is created
    var globalName = script.dataset.global_name;
    if (typeof globalName === "string" && globalName.length > 0) {
        window[globalName] = api;
    }    
}
api.initialize(options);

module.exports = api;

},{"./package.json":1,"./src/generated/crouton_thrift_all.js":2,"./src/initialize_debug_overlay.js":3,"./src/initialize_runtime_attributes.js":4,"./src/instrument_ajax.js":5,"./src/instrument_document.js":6,"./src/platform_browser.js":7,"./src/polyfill.js":8,"node/packages/rl-cruntime-common":10}],10:[function(require,module,exports){
//===========================================================================//
// Dependencies
//===========================================================================//

var State = require("./src/state.js");

//===========================================================================//
// Exported API
//===========================================================================//

var lib = {};

// Creates the "state" object which contains the core functionality of the 
// client library including the buffering and all raw/low-level logging and 
// span calls which the platform-dependent code can call.  The platform 
// libraries are intended to be slim wrappers on this State object.
//
// The "opts" argument passes in all the platform-dependent hooks and 
// information.
//
lib.createState = function(opts) {
    
    // Check that the necessary thrift connection points are there
    if (!opts.thriftTypes) {
        throw new Error("opts.thriftTypes required");
    }
    if (!opts.thriftLibrary) {
        throw new Error("opts.thriftLibrary required");
    }

    // Check that our pal, the platform abstraction layer, is fully 
    // specified.
    if (!opts.platform) {
        throw new Error("opt.platform required");
    }
    if (typeof opts.platform.nowMicros !== "function") {
        throw new Error("nowMicros is a required platform function");
    }
    if (typeof opts.platform.generateGUID !== "function") {
        throw new Error("generateGUID is a required platform function");
    }
    if (typeof opts.platform.console !== "object") {
        throw new Error("console is not a valid platform object");
    }
    if (typeof opts.platform.console.log !== "function") {
        throw new Error("console.log is not a valid platform function");
    }
    if (typeof opts.platform.console.warn !== "function") {
        throw new Error("console.warn is not a valid platform function");
    }
    if (typeof opts.platform.console.error !== "function") {
        throw new Error("console.error is not a valid platform function");
    }
    if (typeof opts.platform.localStore !== "function") {
        throw new Error("console.localStore is not a valid platform function");
    }

    return new State(
        opts.thriftTypes, 
        opts.thriftLibrary, 
        opts.platform, 
        opts.events
    );
};

lib.api = require("./src/api.js");

module.exports = lib;

},{"./src/api.js":11,"./src/state.js":15}],11:[function(require,module,exports){
// Defines the common, client-facing API for cruntime. The platform-specific API 
// may be a slight variation of this depending on platform capabilities.
//
// The code herein is intended to a slim syntactic layer over the implementation
// provided by the State object.

var imp = null;

//===========================================================================//
// Initialization & Configuration
//===========================================================================//

/**
    The Traceguide runtime object.

    This object is normally exposed to the code as a singleton accessible
    via the ``cr`` variable.


    ```js
    var cr = require("rl-cruntime-node");

    cr.initialize({
        access_token : "<your access token here>",
        group_name   : "my_service_name",
    });

    cr.log("The current time is:", new Date());
    ```
 */
function Runtime() {
} 

/**
    @group Initialization
    @brief initialize and begin instrumentation reporting
    @signature  initialize (opts)

    Initializes the runtime library and starts the reporting loop.

    * `opts` object - see the `options()` method for details on the valid
    set of options

    *Example*

    ```js
    cr.initialize({
        access_token : "<your access token here>",
        group_name   : "my_service_name",
    });
    ```

    For convenience, making multiple calls to `initialize()` is valid: all
    calls will be treated as equivalent to a call to `options()` with the
    sole difference that the reporting loop will begin on the first call that
    provides it with sufficient information to begin reporting.  This
    behavior can be helpful for library code that may not a clear, single 
    entry-point.
 */
Runtime.prototype.initialize = function () { 
    return imp.initialize.apply(imp, arguments); 
};

/**
    @group Initialization
    @brief disconnect and clean-up instrumentation reporting
    @signature shutdown ()

    Explicitly shuts down the runtime library.  

    This stops the reporting loop. Any information recorded after
    shutdown has been called will be ignored.

    The runtime will automatically shut down when the process exits; this
    method is available if explicit control over the shutdown is desired.
 */
Runtime.prototype.shutdown = function() { 
    return imp.shutdown.apply(imp, arguments); 
};

/**
    @group Configuration
    @brief set instrumentation options
    @signature options (opts)

    Sets the options for the runtime library.

    ::: mark
    Scrubber documentation is needed!
    :::

    * `opts` object 
        * `access_token` string - sets the project access token for the runtime
        * `group_name` string - sets the group name for the runtime
        * `enable` bool - if set to false, will disable the runtime reporting and
            turn all runtime calls into no-ops. Note: it is currently *not* possible to 
            re-enable the runtime once it is disabled.
        * `scrubber` object - sets the data scrubbing options
        * `end_user_id` string - sets the `end_user_id` join id. See note below.
        * `join_ids` object - sets global join IDs that will be included on all spans
            created by the runtime.
        * `log_to_stdio` bool - echos `log`, `warn`, and `error` to `stdout` and `stderr`.
            In the case of the browser, this will enabling echoing to the web browser
            console. Default false.
        * `override_console` bool - if true, `console.log`, `console.warn`, and `console.error`
            calls will automatically created log records. Default true.
        * `refresh_interval_millis` int - sets the reporting loop interval in milliseconds.
            Default 2500.
        * `max_log_records` int - sets the maximum number of log records the runtime
            will buffer between reports; only a sub-sample of the records will be
            kept beyond this maximum. Defaults to 1024.
        * `max_span_records` int - sets the maximum number of span records the runtime
            will buffer between reports; only a sub-sample of the records will be
            kept beyond this maximum. Defaults to 1024.
        * `service_host` string - explicitly sets the service hostname.
        * `service_port` [int|string] - explicitly sets the service port
        * `certificate_verification` bool - if false, https communication will not
            verify SSL certificates. This is intended for development environments
            only. Default true.

    **`access_token` and `group_name`**

    `access_token` and `group_name` are the only two required configuration
    options. They must be specified as part of a call to `initialize()` for
    the runtime to begin reporting.

    **`end_user_id`**

    The `end_user_id` is useful only in the context of the browser runtime,
    where all opertations will be made on behalf of a single user.
    If the web server is rendering the served page as a template and has access
    to the current user id, it may be convenient to set this as part of the
    script initialization.

    *Example*

    This example assumes a Handlebars-like template rendering syntax:
    
    ```html
    <script type="text/javascript" 
        src="scripts/rl-cruntime-browser.min.js"
        data-access_token="{{ config.access_token }}" 
        data-group_name="my_web_app" 
        data-end_user_id="{{ user_profile.username }}"
        data-global_name="cr"></script>
    ```

    **`scrubber`**

    The data scrubbing allows a set of custom rules which will be run against 
    any log record data and payloads being set to the Traceguide server.  This 
    allows personal-identifying information or otherwise security-sensitive 
    data to be removed or replace before any data is sent to Traceguide.

    The scrubbing rules are general and flexible. See the  full data scrubbing 
    documentation for details (coming soon!).

    *Example*

    ```json
    {
        "scrubber" : {
            "rules" : [
                {
                    "match" : [ "keys", "url_query_string" ],
                    "op"    : "remove",
                    "keys"  : [ "password", "client_secret", "refresh_token" ]
                },
                {
                    "match" : "keys",
                    "op"    : "replace",
                    "keys"  : [ "api_token", "home_address", "phone_number" ],
                    "value" : "<hidden>"
                }
            ]
        }
    }
    ```
 */
Runtime.prototype.options = function() { 
    return imp.options.apply(imp, arguments); 
};

/**
    @group Configuration
    @brief sets attributes on the runtime
    @signature attributes () -> object
    @signature attributes (attrs)

    ::: mark
    As far as the customer is concerned, what are attributes for...?
    :::

    If called with no arguments returns a map of the current attributes
    as a set of key-value pairs.

    Merges into additional attributes that describe 
    the runtime.  Replaces existing attributes if the key-value pair already exists.

    * `attrs` object - key-value pairs to merge into the runtime attributes
 */
Runtime.prototype.attributes = function() { 
    return imp.runtimeAttributes.apply(imp, arguments); 
};

/**
    @group Configuration
    @brief returns the runtime's globally unique indentifier 
    @signature guid () -> string

    Returns the runtime's GUID

    * `return` string - the runtime GUID
 */
Runtime.prototype.guid = function() { 
    return imp.runtimeGUID(); 
};

/**
    @group Configuration
    @brief returns true if instrumentation is currently enabled
    @signature enabled () -> bool

    Returns whether the runtime is enabled.

    * `return` bool - returns whether the runtime is currently enabled.
 */
Runtime.prototype.enabled = function() { 
    return imp.getEnabled(); 
};

/** 
    @group Configuration
    @brief returns true if the runtime is in verbose mode
    @signature verbose () -> bool

    Returns whether the current runtime is in verbose mode.

    In this mode, additional spans and logs are recorded. Intended for
    debugging purposes.

    * `return` bool - returns whether the runtime is currently enabled.
 */
Runtime.prototype.verbose = function() { 
    return imp.getVerbose(); 
};

/*
    EXPERIMENTAL 
    Returns a status object describing the current state of the runtime.
 */
Runtime.prototype.status = function() { return imp.getStatus(); };

//===========================================================================//
// Logging
//===========================================================================//

// -- console object compatible API --- 
//
// Takes variable numbers of arguments, logging them as a space-separated 
// list.
//

/**
    @group Logging
    @brief create a normal log record and optional payload information
    @signature log (any...)

    Records a log statement. The call signature is intended to be the same
    as `console.log`.

    Log statements are *not* echoed to `stdout` (or the web browser console) by 
    default.  Use the `log_to_stdio` option in `initalize()` or `option()` to 
    enable echoing.
 */
Runtime.prototype.log     = function() { return imp.logArgumentsInfo(arguments); };

/**
    @group Logging
    @brief create a normal log record and optional payload information
    @signature info (any...)

    Records a log statement. The call signature is intended to be the same
    as `console.log`.  `info()` is an alias for `log()`.

    Log statements are *not* echoed to `stdout` (or the web browser console) by 
    default.  Use the `log_to_stdio` option in `initalize()` or `option()` to 
    enable echoing.
 */
Runtime.prototype.info    = function() { 
    return imp.logArgumentsInfo(arguments); 
};

/**
    @group Logging
    @brief log a warning and optional payload information
    @signature warn (any...)

    Records a log statement. The call signature is intended to be the same
    as `console.warn`.

    Log statements are *not* echoed to `stdout` (or the web browser console) by 
    default.  Use the `log_to_stdio` option in `initalize()` or `option()` to 
    enable echoing.
 */
Runtime.prototype.warn    = function() { 
    return imp.logArgumentsWarn(arguments); 
};

/**
    @group Logging
    @brief log an error and optional payload information
    @signature error (any...)

    Records a log statement. The call signature is intended to be the same
    as `console.error`.

    Log statements are *not* echoed to `stderr` (or the web browser console) by 
    default.  Use the `log_to_stdio` option in `initalize()` or `option()` to 
    enable echoing.
 */
Runtime.prototype.error   = function() { return imp.logArgumentsError(arguments); };

/**
    @group Logging
    @brief log a fatal error and optional payload information
    @signature fatal (any...)

    Records a log statement and exits the process. The call signature is intended 
    to be the same as `console.error` with the addition the call will terminate
    the process after the log statement is made.

    The runtime *will* attempt a final flush of buffered data before process
    termination.

    On the browser, this function is equivalent to a call to `error` as there
    is no process to terminate in the context of a browser.
 */
Runtime.prototype.fatal   = function() { 
    return imp.logArgumentsFatal(arguments); 
};

// -- glog / sprintf compatible API --- //
//
// Takes sprintf-like format string as a first argument followed by a series
// of data objects.
//

Runtime.prototype.logf    = function() { return imp.logFormattedInfo(arguments); };
Runtime.prototype.infof   = function() { return imp.logFormattedInfo(arguments); };
Runtime.prototype.warnf   = function() { return imp.logFormattedWarn(arguments); };
Runtime.prototype.errorf  = function() { return imp.logFormattedError(arguments); };
Runtime.prototype.fatalf  = function() { return imp.logFormattedFatal(arguments); };

// -- logging directly to console without instrumentation -- //

Runtime.prototype.plain = {};
Runtime.prototype.plain.log   = function() { return imp.plainLog.apply(imp, arguments); };
Runtime.prototype.plain.warn  = function() { return imp.plainWarn.apply(imp, arguments); };
Runtime.prototype.plain.error = function() { return imp.plainError.apply(imp, arguments); };

// -- logging active only in verbose mode -- //

Runtime.prototype.v1 = {};
Runtime.prototype.v1.log   = function() { return imp.verbose() ? lib.log.apply(lib, arguments) : undefined; };
Runtime.prototype.v1.info  = function() { return imp.verbose() ? lib.info.apply(lib, arguments) : undefined; };
Runtime.prototype.v1.warn  = function() { return imp.verbose() ? lib.warn.apply(lib, arguments) : undefined; };
Runtime.prototype.v1.error = function() { return imp.verbose() ? lib.error.apply(lib, arguments) : undefined; };

// -- miscellaneous -- //

/**
    @group Logging
    @brief log an exception object with error information
    @signature exception(err)

    A special-case log call that will log exception objects in a consistent 
    manner that also captures as much aggregate information as possible.

    * `err` any - any exception-like object
 */
Runtime.prototype.exception = function(e) { 
    return imp.logException(e); 
};

/*EXPERIMENTAL
    Create a detailed log record field-by-field
 */
Runtime.prototype.logRecord = function() { return imp.logRecord.apply(imp, arguments); };

//===========================================================================//
// Events
//===========================================================================//

Runtime.prototype.event     = function() { return imp.logEvent.apply(imp, arguments); };
Runtime.prototype.eventWrap = function() { return imp.eventWrap.apply(imp, arguments); };

//===========================================================================//
// Spans
//===========================================================================//

/**
    @group Spans
    @brief create a new span for an operation
    @signature span (operation) -> SpanHandle
    @signature span (operation, joinIdKeyValues) -> SpanHandle
    @signature span (operation, callthrough) -> any
    @signature span (operation, joinIdKeyValues, callthrough) -> any

    Creates a handle object to a new span.

    * `operation` string - the string name of the operation that represents
    * `joinIdKeyValues` object - a map of key-value pairs that will be added to
        the span handle
    * `callthrough` f(handle) - 
        * a function that will be invoked with a single argument
        of the span handle
        * The span is automaticalled `end()`'ed upon return of the
        callthrough
        * Any exceptions throw by the callthrough will be logged and passed onto
        the caller
        * The return value of the call through will become the return value of the
        `span()` call
    * `return` any
        * If `callthrough` is *not* specified, the return value will be a
        handle to the newly created span
        * If `callthrough` is specified, the return value will be the return
        value of the callthrough
 */
Runtime.prototype.span        = function() { 
    return imp.span.apply(imp, arguments); 
};

/**
    @group Spans
    @brief wrap a synchronous function call in an operation
    @signature callSync (operation, f, [self], [arg0], [arg1], ...) -> any
    @signature callSync (operation, joinIds, f, [self], [arg0], [arg1], ...) -> any

    Invokes a function similarly to the native `call` function but also wraps
    the call inside a span with the given operation name.  It will automatically
    log call arguments, return values, and any exceptions; the span itself is
    automatically begun and ended scoped to the call.

    The invoked function must be a synchronous function.

    * `operation` string - the operation name to assign to the created span
    * `joinIds` object - join IDs to set on the created span
    * `f` function - the function to invoke
    * `self` object - the `this` value to use when invoking `f`
    * `arg...` any - the arguments to pass when invoking `f`
    * `return` any - returns the value of the invoked function `f`


    *Example*

    ```js
    function add (a, b) { 
        return a + b;
    }

    // Create an operation named "my_add_operation" for the call to the
    // add function.
    var result = cr.callSync("my_add_operation", add, null, 40, 2);
    console.log(result);    // prints "42"
    ```
 */
Runtime.prototype.callSync = function() {
    return imp.callSync.apply(imp, arguments);
};

/**
    @group Spans
    @brief wrap a synchronous function call in an operation
    @signature applySync (operation, f, [self], [args]) -> any
    @signature applySync (operation, joinIds, f, [self], [args]) -> any

    Behaves exactly the same `callSync` but the function arguments are passed
    as an array.
 */
Runtime.prototype.applySync = function() {
    return imp.applySync.apply(imp, arguments);
};

/**
    @group Spans
    @brief wrap an asynchronous function call in an operation
    @signature callAsync (operation, f, [self], [arg0], [arg1], ..., callback) -> any
    @signature callAsync (operation, joinIds, f, [self], [arg0], [arg1], ..., callback) -> any

    The asynchronous version of `callSync`. This assumes the final argument
    to `f` will be a callback function that is invoked when the asynchronous
    function is complete and that the first argument to the callback function
    is an optional error argument.


    *Example*

    ```js
    function add (a, b, done) { 
        setTimeout(function() {
            // The first argument is the error, if one occurred
            done(null, a + b);
        }, 50);
    }

    // Create an operation named "my_add_operation" for the call to the
    // add function.
    cr.callAsync("my_add_operation", add, null, 40, 2, function(err, result) {
        console.log(result);    // prints "42"
    });
    ```    
 */
Runtime.prototype.callAsync = function() {
    return imp.callAsync.apply(imp, arguments);
};

/**
    @group Spans
    @brief wrap an asynchronous function call in an operation
    @signature applyAsync (operation, f, [self], [args]) -> any
    @signature applyAsync (operation, joinIds, f, [self], [args]) -> any

    Behaves exactly as `callAsync` with the exception that the arguments to the
    invoked function are passed as an array. The final element of the array is
    expected to be the callback function.
 */
Runtime.prototype.applyAsync = function() {
    return imp.applyAsync.apply(imp, arguments);
};



Runtime.prototype.spanWrap    = function() { return imp.spanWrap.apply(imp, arguments); };
Runtime.prototype.spanSection = function() { return imp.spanSection.apply(imp, arguments); };
Runtime.prototype.spanManual  = function() { return imp.spanManual.apply(imp, arguments); };

Runtime.prototype.setActiveSpanName = function() { return imp.setActiveSpanName.apply(imp, arguments); };

/*EXPERIMENTAL

    If called with an object and a the span handle, that span handle will be
    associated with the object.

    If called with one argument. Return the span handle associated with the 
    given object (e.g. HTTP request  object) if there is one. If there is not
    a span handle for that object, the active span is return (if it is known).
    If no active span known, a valid span handle interface is returned, but 
    does not correspond to any particular span (e.g. all logs recorded using
    that interface globally).
 */
Runtime.prototype.spanForObject = function(obj, handle) { 
    return imp.spanForObject.apply(imp, arguments); 
};

// Library instrumentation helpers
Runtime.prototype.getActiveJoinIds = function() { return imp.getActiveJoinIds.apply(imp, arguments); };
Runtime.prototype.setActiveJoinIds = function() { return imp.setActiveJoinIds.apply(imp, arguments); };
Runtime.prototype.setActiveSpan    = function() { 
    if (arguments.length === 2) {
        return imp.setActiveSpan.call(imp, arguments[0], null, [], arguments[1]);
    } else {
        return imp.setActiveSpan.apply(imp, arguments);
    }
};

//===========================================================================//
// Counters & Gauges 
//===========================================================================//

// TBD
Runtime.prototype.counter     = function(name, value) {};
Runtime.prototype.gauge       = function(name, value) {};

//===========================================================================//
// Buffer Control
//===========================================================================//

Runtime.prototype.pause   = function()            { throw new Error("NOT_YET_IMPLEMENTED"); };
Runtime.prototype.resume  = function()            { throw new Error("NOT_YET_IMPLEMENTED"); };
Runtime.prototype.flush   = function(synchronous, done) {
    return imp.flushBuffer(synchronous, done);
};
Runtime.prototype.discard = function()            { imp.discardBuffers(); };

//===========================================================================//
// Reporting
//===========================================================================//

Runtime.prototype.stats = function() { return imp.reportBufferStats(); };

//===========================================================================//
// EventEmitter-style listeners
//===========================================================================//

Runtime.prototype.on             = function () { return imp.on.apply(imp, arguments); };
Runtime.prototype.removeListener = function () { return imp.removeListener.apply(imp, arguments); };
Runtime.prototype.once           = function () { return imp.once.apply(imp, arguments); };

//===========================================================================//
// Exports
//===========================================================================//

// Singleton
var lib = new Runtime();

module.exports = function (implObject) {
    imp = implObject;
    imp.api = lib;

    // TODO: Remove this field. The implementation object should *never* need
    // to be accessed directly. It's here for development to allow inspection
    // of the values during debugging.
    lib.__imp = imp;
    
    return lib;
};

},{}],12:[function(require,module,exports){
var kLocalStoreKey = "clock_state";
// How many updates before a sample is considered old. This happens to
// be one less than the number of samples in our buffer but that's
// somewhat arbitrary.
var kMaxOffsetAge = 7;

function ClockState(platform, state) {
    this.platform = platform;
    this.state = state;
    // The last eight samples, computed from timing information in
    // RPCs.
    this.samples = [];
    this.currentOffsetMicros = 0;
    // How many updates since we've updated currentOffsetMicros.
    this.currentOffsetAge = kMaxOffsetAge + 1;

    // Try to load samples from the local store.
    var storedData;
    try {
        if (this.state.options().service_host) {
            storedData = JSON.parse(platform.localStore(
                kLocalStoreKey + "/" + state.options().service_host));
        }
    } catch (e) {}
    // Only use the data if it's recent.
    var kStoredSamplesTTLMicros = 60 * 60 * 1000 * 1000; // 1 hour
    if (storedData &&
        storedData.timestamp_micros &&
        storedData.timestamp_micros > platform.nowMicros() - kStoredSamplesTTLMicros) {
        // Make sure there are no more than (kMaxOffsetAge+1) elements
        this.samples = storedData.samples.slice(-(kMaxOffsetAge+1));
    }
    // Update the current offset based on these data.
    this.update();
}

// Add a new timing sample and update the offset.
ClockState.prototype.addSample = function(originMicros,
                                          receiveMicros,
                                          transmitMicros,
                                          destinationMicros) {
    var latestDelayMicros = Number.MAX_NUMBER;
    var latestOffsetMicros = 0;
    // Ensure that all of the data are valid before using them. If
    // not, we'll push a {0, MAX} record into the queue.
    if (originMicros > 0 && receiveMicros > 0 &&
        transmitMicros > 0 && destinationMicros > 0) {
        latestDelayMicros = (destinationMicros - originMicros) -
            (transmitMicros - receiveMicros);
        latestOffsetMicros = ((receiveMicros - originMicros) +
                       (transmitMicros - destinationMicros)) / 2;
    }

    // Discard the oldest sample and push the new one.
    if (this.samples.length == kMaxOffsetAge+1) {
        this.samples.shift();
    }
    this.samples.push({
        delayMicros : latestDelayMicros,
        offsetMicros : latestOffsetMicros,
    });
    this.currentOffsetAge++;

    // Update the local store with this new sample.
    if (this.state.options().service_host) {
        this.platform.localStore(
            kLocalStoreKey + "/" + this.state.options().service_host,
            JSON.stringify({
                timestamp_micros : this.platform.nowMicros(),
                samples : this.samples,
            })
        );
    }
    this.update();
};

// Update the time offset based on the current samples.
ClockState.prototype.update = function() {
    // This is simplified version of the clock filtering in Simple
    // NTP. It ignores precision and dispersion (frequency error). In
    // brief, it keeps the 8 (kMaxOffsetAge+1) most recent
    // delay-offset pairs, and considers the offset with the smallest
    // delay to be the best one. However, it only uses this new offset
    // if the change (relative to the last offset) is small compared
    // to the estimated error.
    //
    // See:
    // https://tools.ietf.org/html/rfc5905#appendix-A.5.2
    // http://books.google.com/books?id=pdTcJBfnbq8C
    //   esp. section 3.5
    // http://www.eecis.udel.edu/~mills/ntp/html/filter.html
    // http://www.eecis.udel.edu/~mills/database/brief/algor/algor.pdf
    // http://www.eecis.udel.edu/~mills/ntp/html/stats.html

    // TODO: Consider huff-n'-puff if we think the delays are highly
    // asymmetric.
    // http://www.eecis.udel.edu/~mills/ntp/html/huffpuff.html

    // Find the sample with the smallest delay; the corresponding
    // offset is the "best" one.
    var minDelayMicros = Number.MAX_VALUE;
    var bestOffsetMicros = 0;
    for (var i = 0; i < this.samples.length; i++) {
        if (this.samples[i].delayMicros < minDelayMicros) {
            minDelayMicros = this.samples[i].delayMicros;
            bestOffsetMicros = this.samples[i].offsetMicros;
        }
    }

    // No update.
    if (bestOffsetMicros == this.currentOffsetMicros) {
        return;
    }

    // Now compute the jitter, i.e. the error relative to the new
    // offset were we to use it.
    var jitter = 0;
    for (i = 0; i < this.samples.length; i++) {
        jitter += Math.pow(bestOffsetMicros - this.samples[i].offsetMicros, 2);
    }
    jitter = Math.sqrt(jitter / this.samples.length);

    // Ignore spikes: only use the new offset if the change is not too
    // large... unless the current offset is too old. The "too old"
    // condition is also triggered when update() is called from the
    // constructor.
    var kSGATE = 3; // See RFC 5905
    if (this.currentOffsetAge > kMaxOffsetAge ||
        Math.abs(this.currentOffsetMicros - bestOffsetMicros) < kSGATE * jitter) {
        this.currentOffsetMicros = bestOffsetMicros;
        this.currentOffsetAge = 0;
    }
};

// Returns the difference in microseconds between the server's clock
// and our clock. This should be added to any local timestamps before
// sending them to the server. Note that a negative offset means that
// the local clock is ahead of the server's.
ClockState.prototype.offsetMicros = function() {
    return this.currentOffsetMicros | 0;
};

// Returns true if we've performed enough measurements to be confident
// in the current offset.
ClockState.prototype.isReady = function() {
    return this.samples.length > 3;
};

ClockState.prototype.activeSamples = function() {
    return this.samples.length;
};

module.exports = ClockState;

},{}],13:[function(require,module,exports){
// The build process will override this to false in minified distributions
// and strip any dead code that results.
var DEBUG = true; 

//===========================================================================//
// Memory Management
//===========================================================================//

function ObjectPool(opts) {
    var reserveCount = opts.reserve || 32;

    this._ctor = opts.constructor;
    this._reset = opts.object_reset;
    this._pop_front = opts.pop_front || false;

    this.allocationCount = 0;
    this.acquireCount = 0;
    this.releaseCount = 0;
    this.freeList = new Array(reserveCount);

    for (var i = 0; i < reserveCount; i++) {
        this.freeList[i] = this.newObject();
    }
}

ObjectPool.prototype.newObject = function() {
    this.allocationCount++;
    return new (this._ctor)();
};

ObjectPool.prototype.acquire = function(args) {
    this.acquireCount ++;
    var obj;
    if (this.freeList.length) {
        obj = this.freeList.pop();
    } else {
        obj = this.newObject();
    }
    this._reset(obj, args);
    return obj;
};

ObjectPool.prototype.release = function(obj) {
    if (obj === undefined || obj === null) {
        if (DEBUG) {
            console.assert(false, "Attempt to release an invalid object.");
        }
        return;
    }

    if (DEBUG) {
        console.assert(this.acquireCount >= this.releaseCount, "Imbalance in acquire/release counts!");
    }
    this.releaseCount ++;
    this._reset(obj);
    this.freeList.push(obj);
};

// Effectively reinitializes the pool by reseting counters and reseting
// the free list.  Existing objects, of course, still exist and will
// be GC'ed normally.
ObjectPool.prototype.reset = function() {
    this.allocationCount = 0;
    this.acquireCount = 0;
    this.releaseCount = 0;
    this.freeList = [];
};

module.exports = ObjectPool;

},{}],14:[function(require,module,exports){
// The build process will override this to false in minified distributions
// and strip any dead code that results.
var DEBUG = true;

//===========================================================================//
// Memory Management
//===========================================================================//

var kSpanHandlesPoolInitialSize = 32;

var ObjectPool = require("./object_pool.js");

var pool = {
    spanHandles : new ObjectPool({
        constructor  : SpanHandle,
        initial_size : kSpanHandlesPoolInitialSize,
        object_reset : function(obj, args) {
            this._record = null;
            this._state = null;
            this._id = 0;
        },
    }),
};

var gIdCounter = 1;         // Start at 1 so 0 means not a valid, active handle
var gActiveSpansById = {};

//===========================================================================//
// SpanHandle
//===========================================================================//
//
// A handle exposing an active span to the client.
//
// Terminology: the "span record" is the data associated with a completed
// span and the "span handle" is the interface for interacting with an active
// span.
//
// Dev note: this interface should mirror the cruntime API (where common sense
// applies).
//

/**
    Interface for manipulating an active span object.
 */
function SpanHandle(state, record) {
    // Don't call release() on _record as this is non-owning reference.
    this._record = record;
    this._state = state;

    // Internal identifier; useful for tracking unclosed spans
    this._id = gIdCounter++;
}


/**
    @group Properties
    @signature guid() -> string

    * `return` string - the globally unique identifier for the span instance.
 */
SpanHandle.prototype.guid = function() {
    if (!this._record) {
        logUserError(this._state, "Invalid span handle", arguments);
        return 0;
    } else {
        return this._record.span_guid;
    }
};


/**
    @group Properties
    @signature valid() -> bool

    Returns true if the span handle is valid; false if `end()` has already been
    called.

    * `return` bool - false if the span has already been ended
 */
SpanHandle.prototype.valid = function() {
    return !!this._record;
};

/**
    @group Configuration & Control
    @signature end()

    Ends the span.  This should be called exactly once for every created span
    object.
 */
SpanHandle.prototype.end = function() {
    if (!this._record) {
        logUserError(this._state, "Invalid span handle", arguments);
        return;
    }
    if (DEBUG) {
        console.assert(this._record.span_guid !== null, "Span requires a GUID");
        console.assert(this._record.youngest_micros === null, "span end() has already been called");
    }

    if (this._record.youngest_micros === null) {
        this._record.youngest_micros = this._state.nowMicros();
        this._state.pushSpanRecord(this._record);
        this._record = null;
        delete gActiveSpansById[this._id];
        pool.spanHandles.release(this);
    } else {
        logUserError(this._state, "Span closed twice");
    }
};



SpanHandle.prototype.name = function(newName) {
    if (!this._record) {
        logUserError(this._state, "Invalid span handle", arguments);
        return;
    } else {
        if (newName === undefined) {
            // accessor
            return this._record.span_name;
        } else {
            // mutator
            this._record.span_name = newName;
        }
    }
};

/**
    @group Configuration & Control
    @signature operation() -> string
    @signature operation(name)

    Accessor and mutator for the name of the span operation.

    * `name` string - name of the operation
    * `return` string - current name of the operation
 */
SpanHandle.prototype.operation = SpanHandle.prototype.name;


/**
    @group Configuration & Control
    @signature attributes() -> object
    @signature attributes(key, value) -> SpanHandle
    @signature attributes(attrs) -> SpanHandle

    Called with no arguments, returns the current set of span attributes
    as a key-value pair map.

    Called with two arguments, sets the given key value pair. Any existing
    key-value with that key will be replaced.

    Called with an object, the object will be treated as a set of
    key-value pairs to merge into the span attributes.

    All values will be converted to strings when stored as an attribute.
 */
SpanHandle.prototype.attributes = function() {
    var attrs;

    // Accessor
    if (arguments.length === 0) {
        if (!this._record) {
            logUserError(this._state, "Invalid span handle", arguments);
            return {};
        }
        attrs = {};
        for (var i = 0; i < this._record.attributes.length; i++) {
            var pair = this._record.attributes[i];
            attrs[pair.Key] = pair.Value;
        }
        return attrs;
    }

    // Mutator
    if (!this._record) {
        logUserError(this._state, "Invalid span handle", arguments);
        return {};
    }
    if (arguments.length === 1) {
        attrs = arguments[0];
    } else if (arguments.length === 2) {
        var keyType = typeof arguments[0];
        if (keyType !== "number" && keyType !== "string") {
            logUserError(this._state, "Invalid arguments", arguments);
            return this;
        }
        attrs = {};
        attrs[arguments[0]] = arguments[1];
    } else {
        logUserError(this._state, "Invalid arguments", arguments);
        return this;
    }
    if (typeof attrs !== "object" || !attrs) {
        logUserError(this._state, "Invalid arguments", arguments);
        return this;
    }
    this._state.mergeAttributesIntoSpanRecord(this._record, attrs);
};

// Wrap a function and end the span as soon as that function is invoked.
// Useful for asynchronous done/complete/next callbacks.
//
// Example:
//
// var span = cr.span("read_my_file")
// fs.readFile("my_file.txt", span.endWrap(function (err, buf) {
//     ...
// }));
//
SpanHandle.prototype.endWrap = function(f) {
    var self = this;
    return function() {
        self.end();
        var r;
        try {
            r = f.apply(this, arguments);
        } catch (e) {
            self.exception(e);
            throw e;
        }
        return r;
    };
};

/**
    @group Configuration & Control
    @signature joinIds () -> object
    @signature joinIds (joinIds)

    Accessor and mutator for the join IDs set on the span instance.
    When modifying the existing join IDs, the method will *merge*
    additional join IDs into the existing set of join IDs.

    If called with no arguments, it returns the current set of join IDs as
    an object.

    * `joinIds` object - the set of key-value pairs to merge into the existing
        join IDs
    * `return` object - the existing set of key-value pairs for the join IDs
 */
SpanHandle.prototype.joinIds = function (joinIds) {
    if (!this._record) {
        logUserError(this._state, "Invalid span handle", arguments);
        return {};
    }

    // Accessor
    if (joinIds === undefined) {
        var map = {};
        joinIds = this._record.join_ids;
        for (var i = 0; i < joinIds.length; i++) {
            var pair = joinIds[i];
            map[pair.TraceKey] = pair.Value;
        }
        return map;
    }

    // Mutator
    this._state.mergeJoinIdMapIntoSpanRecord(this._record, joinIds);
};

//===========================================================================//
// Spans
//===========================================================================//

/**
    @group Sub-spans
    @signature span(operation, joinIds, callthrough) -> any
    @signature span(operation, callthrough) -> any
    @signature span(operation, joinIds) -> SpanHandle
    @signature span(operation) -> SpanHandle

    Create a sub-span.  The newly created span inherits the join IDs of the
    outer span object.

    Note: the span does *not* inherit the "active" join IDs and instead trusts
    that the outer span object creating the new span has the intended join IDs.

    * `operation` string - name to assign to the span operation
    * `joinId` object - key-value pairs to use on the sub-span
    * `callthrough` function(spanHandle) : any - a function that will be
    called with the newly created spanHandle.  The return value of this
    callthrough will become the return value of the outer `span()` call.
    * `return` [any|SpanHandle] - if a callthrough is provided, the return
    value of span() will be the return value of the callthrough. Otherwise, the
    return value is the handle to the newly created span.

    :::mark
    The `callthrough` concept is confusing and the value is unclear. It does
    have value (it sets the span object as active in the internal active
    span set, which allows other instrumented code to "find" the current span
    without explicit knowledge of the caller) but this is difficult to explain
    without introducing new, non-trivial concepts.
    :::
*/
SpanHandle.prototype.span = function (name, joinIdKeyValues, callthrough) {

    if (arguments.length === 2 && typeof joinIdKeyValues === "function") {
        callthrough = joinIdKeyValues;
        joinIdKeyValues = null;
    }

    var inner;
    var handle;
    if (!this._record) {
        // If this is an invalid handle, still create a new handle even if it
        // isn't associated with the invalid parent.
        logUserError(this._state, "Invalid span handle", arguments);
        inner = this._state.rawSpanBegin(name, joinIdKeyValues);
        handle = this._state.createSpanHandle(inner);
    } else {
        var joinIds = mergeTraceIds(this._record.join_ids, joinIdKeyValues);
        inner = this._state.rawSpanBegin(name, joinIds);
        handle = this._state.createSpanHandle(inner);
        handle.attributes("parent_span_guid", this._record.span_guid);
    }

    if (callthrough) {
        return this._state.setActiveSpan(handle, null, [ handle ], callthrough);
    } else {
        return handle;
    }
};

SpanHandle.prototype.spanSection = function (name, joinIdKeyValues, f) {
    if (arguments.length === 2) {
        f = joinIdKeyValues;
        joinIdKeyValues = {};
    }
    var joinIds = mergeTraceIds(this._record.join_ids, joinIdKeyValues);
    return this._state.spanSection(name, joinIds, f);
};

//===========================================================================//
// console-style logging
//===========================================================================//

/**
    @group Logging

    Adds a log statement that is explicitly associated with the
    span instance.
 */
SpanHandle.prototype.log = function() {
    if (!this._record) {
        logUserError(this._state, "Invalid span handle", arguments);
    } else {
        this._state.logArgumentsInfo(arguments, this._record.span_guid);
    }
};

/**
    @group Logging

    Adds a log statement that is explicitly associated with the
    span instance.
 */
SpanHandle.prototype.info = SpanHandle.prototype.log;

/**
    @group Logging

    Adds a warning log statement that is explicitly associated with the
    span instance.
 */
SpanHandle.prototype.warn = function() {
    if (!this._record) {
        logUserError(this._state, "Invalid span handle", arguments);
    } else {
        this._state.logArgumentsWarn(arguments, this._record.span_guid);
    }
};

/**
    @group Logging

    Adds a error log statement that is explicitly associated with the
    span instance.
 */
SpanHandle.prototype.error = function() {
    if (!this._record) {
        logUserError(this._state, "Invalid span handle", arguments);
    } else {
        // Denote the span contains an error.
        this._record.error_flag = true;
        this._state.logArgumentsError(arguments, this._record.span_guid);
    }
};

/**
    @group Logging

    Adds a fatal log statement that is explicitly associated with the
    span instance.

    Note: `fatal` will cause the process to exit on a Node.js-like platform.
    On the browser, it is equivalent an error and processing is not explicitly
    stopped.
 */
SpanHandle.prototype.fatal = function() {
    // The implementation of fatal intentionally differs from info/warn/error
    // on a bad record: take the fatal seriously and pass it on to the state
    // object.
    var guid;
    if (this._record) {
        this._record.error_flag = true;
        guid = this._record.span_guid;
    } else {
        logUserError(this._state, "Invalid span handle", arguments);
    }
    this._state.logArgumentsFatal(arguments, guid);
};

//===========================================================================//
// glog-style logging
//===========================================================================//

SpanHandle.prototype.logf = function() {
    if (!this._record) {
        logUserError(this._state, "Invalid span handle", arguments);
    } else {
        this._state.logFormattedInfo(arguments, this._record.span_guid);
    }
};

SpanHandle.prototype.infof = SpanHandle.prototype.logf;

SpanHandle.prototype.warnf = function() {
    if (!this._record) {
        logUserError(this._state, "Invalid span handle", arguments);
    } else {
        this._state.logFormattedWarn(arguments, this._record.span_guid);
    }
};

SpanHandle.prototype.errorf = function() {
    if (!this._record) {
        logUserError(this._state, "Invalid span handle", arguments);
    } else {
        this._record.error_flag = true;
        this._state.logFormattedError(arguments, this._record.span_guid);
    }
};

SpanHandle.prototype.fatalf = function() {
    // The implementation of fatal intentionally differs from info/warn/error
    // on a bad record: take the fatal seriously and pass it on to the state
    // object.
    var guid;
    if (this._record) {
        guid = this._record.span_guid;
        this._record.error_flag = true;
    } else {
        logUserError(this._state, "Invalid span handle", arguments);
    }
    this._state.logFormattedFatal(arguments, guid);
};

SpanHandle.prototype.exception = function(e) {
    var guid;
    if (this._record) {
        guid = this._record.span_guid;
        this.error_flag = true;
    } else {
        logUserError(this._state, "Invalid span handle", arguments);
    }
    this._state.logException(arguments, guid);
};

SpanHandle.prototype.logRecord = function(fields) {
    if (this._record) {
        fields.span_guid = this._record.span_guid;
        if (fields.error_flag || fields.level == "E" || fields.level == "F") {
            this._record.error_flag = true;
        }
    } else {
        logUserError(this._state, "Invalid span handle", arguments);
    }
    this._state.logRecord(fields);
};

//===========================================================================//
// Events
//===========================================================================//

// Valid call signatures:
//
// event(name)
// event(name, message)
// event(name, payload)
// event(name, message, payload)
//
SpanHandle.prototype.event = function(name, message, payload) {
    if (!this._record) {
        logUserError(this._state, "Invalid span handle", arguments);
    } else {

        // The two-argument call signature is the only case that requires
        // parameter shuffling
        if (arguments.length === 2 && typeof message === "object") {
            payload = message;
            message = undefined;
        }
        this._state.logEventWithGUID(name, message, payload, this._record.span_guid);
    }
};

//===========================================================================//
// Helpers
//===========================================================================//

// For user-caused internal errors.
function logUserError (state, text, args) {
    state.rawLogRecord({
        level       : "E",
        error_flag  : true,
        filename    : "<span_handle>",
        message     : text,
        stack_frames: state.stackTrace(),
        payload     : {
            arguments : Array.prototype.slice.call(args),
        },
    });
}

// Merges the parent array representation with a map and returns a map.
// parentArray should an array; toMerge should be a map or may be undefined.
//
// TODO: fix this data structure ping-pong!
 function mergeTraceIds (parentArray, toMerge) {
    var map = {};
    for (var i = 0; i < parentArray.length; i++) {
        var pair = parentArray[i];
        map[pair.TraceKey] = pair.Value;
    }
    if (toMerge) {
        for (var key in toMerge) {
            map[key] = toMerge[key];
        }
    }
    return map;
}


//===========================================================================//
// NoOpHandle
//===========================================================================//
// Returned when the cruntime is disabled

function NoOpHandle() {
    // MUST have no state as the object is effectively used as a
    // singleton.
}

// Create true no-op functions as a default, then override the methods
// that need to do something beyond trace functionality.
for (var key in SpanHandle.prototype) {
    NoOpHandle.prototype[key] = function() {};
}

NoOpHandle.prototype.endWrap = function(f) {
    return f;
};

NoOpHandle.prototype.span = function (name, joinIdKeyValues, f) {
    if (arguments.length === 2 && typeof joinIdKeyValues === "function") {
        f = joinIdKeyValues;
        joinIdKeyValues = null;
    }

    if (f) {
        return f(this);
    }
    return this;
};

NoOpHandle.prototype.spanSection = function (name, joinIdKeyValues, f) {
    if (arguments.length === 2) {
        f = joinIdKeyValues;
    }
    return f();
};

//===========================================================================//
// Exports
//===========================================================================//

var lib = {};

lib.acquire = function(state, record) {
    var obj = pool.spanHandles.acquire();
    SpanHandle.call(obj, state, record);
    gActiveSpansById[obj._id] = obj;
    return obj;
};

lib.activeSpanHandles = function() {
    var active = [];
    for (var id in gActiveSpansById) {
        active.push(gActiveSpansById[id]);
    }
    return active;
};

lib.isSpanHandle = function(obj) {
    return (obj instanceof SpanHandle);
};

var gNoOpHandle = new NoOpHandle();
lib.getNoOpHandle = function() {
    return gNoOpHandle;
};

module.exports = lib;

},{"./object_pool.js":13}],15:[function(require,module,exports){
//===========================================================================//
// Dependencies & Consts
//===========================================================================//

var ObjectPool       = require("./object_pool.js"),
    span_handle      = require("./span_handle.js"),
    ClockState       = require("./clock_state.js"),
    TimestampSamples = require("./timestamp_samples.js"),
    makeInspectable  = require("node/packages/rl-inspectable-object"),
    scrubber         = require("node/packages/rl-scrubber"),
    EventEmitterMin  = require("node/packages/rl-eventemitter");

// The build process will override this to false in minified distributions
// and strip any dead code that results.
var DEBUG = true;

var kLogRecordsPoolInitialSize  = 128;
var kSpanRecordsPoolInitialSize = 32;
var kTraceJoinIdPoolInitialSize = 64;
var kKeyValuePoolInitialSize    = 64;

var kMaxLogRecordsDefault          = 1024;
var kMaxSpanRecordsDefault         = 1024;
var kRefreshIntervalMsDefault      = 2500;
var kClockSamplingIntervalMs       = 350;

// This should be *rare* or never occur, so a large number here makes
// some sense. While this comment will surely fall out of date,
// currently 32 implies discard once every 1.5 hours given the backoff
// and default refresh interval.
var kDiscardDataEveryNthFlushError = 32;

// Another precaution against a not well-defined case: recreate the thrift
// client objects after N errors, assuming somehow its internal state is
// blocking successful flushes.  The unreliable, unpredictable error handling
// of Thrift has given rise to this precaution.  Note: recreating the client
// appears to "safe" but wasteful operation in the 0.9.2 Thrift JS library.
var kResetConnectionEveryNthFlushError = 10;

// Rules that are always active in the scrubber -- intended for removing
// traceguide internal information.
var kBaselineScrubberRules = [
    {
        match        : [ "keys", "url_query_string" ],
        op           : "remove",
        key_prefixes : [ "traceguide_" ],
    }
];

// Intended as a reasonable set of defaults for scrubbing customer data.
var kDefaultScrubbersRules = [
    {
        match       : "keys",
        op          : "remove",
        keys        : [ "password", "api_key" ],
    },
];

// Returned in cases when the clock state is not ready (and the
// request should be retried).
var kClockStateNotReadyError = new Error("clock state not ready");

//===========================================================================//
// Globals
//===========================================================================//
// Use globals mostly for coding convenience.  No runtime is (currently)
// expected to have multiple State objects; this may change in the future.

// State object
var singleton       = null;

// Thrift
var crouton_thrift  = null;
var Thrift          = null;

// Memory management
var pool = {
    logRecords      : null,
    spanRecords     : null,
    traceJoinIds    : null,
};

// Platform abstraction layer
var platform        = null;

// Saved global state in case we're asked to override it
var originalConsole = console;
var originalConsole_log = originalConsole.log;
var originalConsole_warn = originalConsole.warn;
var originalConsole_error = originalConsole.error;

// Ensure a conditional occurs not more than once
_onceMap = {};
function _once(key) {
    var alreadySet = !!_onceMap[key];
    _onceMap[key] = true;
    return !alreadySet;
}

function _log()   { return originalConsole_log.apply(originalConsole, arguments); }
function _warn()  { return originalConsole_warn.apply(originalConsole, arguments); }
function _error() { return originalConsole_error.apply(originalConsole, arguments); }

function initializeGlobals(state, crouton_thrift_, Thrift_, platform_) {
    //
    // Singleton...
    //
    // This is mostly for coding convenience. In theory, we may want to
    // to have less global state when proxying different services so that
    // the runtime attributes, buffering strategies, etc. can vary between
    // those data sources.
    //
    if (singleton !== null) {
        throw new Error("State is intended to be a singleton.");
    }
    singleton = state;

    //
    // Platform...
    //
    platform = platform_;

    //
    // Thrift...
    //
    crouton_thrift = crouton_thrift_;
    Thrift         = Thrift_;

    //
    // Memory Pools...
    //
    // These rely on the thrift implementation to clear out all the fields.
    // Seems a bit fragile, but manually listing out the fields and clearing
    // them is also fragile if new fields are added.
    pool.logRecords = new ObjectPool({
        constructor  : crouton_thrift.LogRecord,
        initial_size : kLogRecordsPoolInitialSize,
        object_reset : function(obj, args) { crouton_thrift.LogRecord.call(obj, args); },
    });
    pool.spanRecords = new ObjectPool({
        constructor  : crouton_thrift.SpanRecord,
        initial_size : kSpanRecordsPoolInitialSize,
        object_reset : function(obj, args) { crouton_thrift.SpanRecord.call(obj, args); },
    });
    pool.traceJoinIds = new ObjectPool({
        constructor  : crouton_thrift.TraceJoinId,
        initial_size : kTraceJoinIdPoolInitialSize,
        object_reset : function(obj, args) { crouton_thrift.TraceJoinId.call(obj, args); },
    });
    pool.keyValue = new ObjectPool({
        constructor  : crouton_thrift.KeyValue,
        initial_size : kKeyValuePoolInitialSize,
        object_reset : function(obj, args) { crouton_thrift.KeyValue.call(obj, args); },
    });
}

function releaseSpanRecord (span) {
    if (DEBUG) {
        console.assert(span.span_guid !== null, "Invalid span being released.");
    }
    if (span.join_ids) {
        for (var j = 0; j < span.join_ids.length; j++) {
            pool.traceJoinIds.release(span.join_ids[j]);
        }
    }
    if (span.attributes) {
        for (var k = 0; k < span.attributes.length; k++) {
            pool.keyValue.release(span.attributes[k]);
        }
    }
    pool.spanRecords.release(span);
}

// Balance the acquire()'ed objects with release() calls.
function releaseArrays (logs, spans) {
    // Release log record objects
    for (var i = 0; i < logs.length; i++) {
        pool.logRecords.release(logs[i]);
    }
    // Release span record object and any contained join ids
    for (i = 0; i < spans.length; i++) {
        releaseSpanRecord(spans[i]);
    }
}

// TODO: this is intended to be a reasonable short-term solution, nothing more.
function defaultServiceHost() {
    return "api.traceguide.io";
}

function defaultServicePort() {
    // TODO: must be explicit about http/https.
    return 9997;
}

// Returns true if all elements in array "a" are of type string.
// Returns true for empty arrays.
function allElementsAreStrings(a) {
    for (var i = 0; i < a.length; i++) {
        if (typeof a[i] !== "string") {
            return false;
        }
    }
    return true;
}

//===========================================================================//
// State
//===========================================================================//

function State(thriftTypes, thriftLibrary, platform, eventHandlers) {
    EventEmitterMin.call(this);

    initializeGlobals(this, thriftTypes, thriftLibrary, platform);

    var now = platform.nowMicros();

    // Set up event handlers immediately, as some are invoked during creation
    for (var key in eventHandlers) {
        this.on(key, eventHandlers[key]);
    }

    // Handle to the client-api.  Set externally by the API creation code.
    this.api = null;

    // Configuration
    this.serviceHost = defaultServiceHost();
    this.servicePort = defaultServicePort();
    this.certificateVerification = true;
    this.bufferMaxSpanRecords    = kMaxSpanRecordsDefault;
    this.bufferMaxLogRecords     = kMaxLogRecordsDefault;
    this.refreshIntervalMs       = kRefreshIntervalMsDefault;
    this.logToStdio              = false;
    this.debug                   = false;  // "debug" relates to the HTML debug overlay
    this.verbose                 = false;  // "verbose" sets vastly increased internal logging
    this.handle_uncaught_excepton= false;  // See options() handle_uncaught_exception
    this.autoinstrument          = false;  // Inject instrumentation into common libraries.
                                           // This likely should be a library-by-library opt-in.
    this.automonitor             = false;  // Periodically poll & log system stats
    this.disableClockCorrection  = false;  // Don't try to adjust for client-service clock offset.

    // Thrift runtime object and client object
    this.runtime = new crouton_thrift.Runtime();
    this.runtime.guid = "";
    this.runtime.group_name = "";
    this.runtime.start_micros = now;

    // Thrift client object - initialized at the start of the refresh loop
    this.client     = null;
    this.auth       = new crouton_thrift.Auth();
    this.connection = null;  // <-- Only set for node.js (the asymmetry is not ideal, but needed)

    // Model of clock skew between client and server
    this.clockState = null;

    // Payload scrubber
    this.scrub      = null;         // Initialized in options()

    // Status
    this.initialized = false;
    this.shuttingDown = false;
    this.connectionOk = false;          // False if a reconnect is needed for any reason
    this.refreshLoopActive = false;
    this.flushActive = false;
    this.flushErrorCount = 0;           // Consecutive errors from report calls (for back-off purposes)
    this.flushNonConnectErrorCount = 0; // Consecutive errors *known* not to be connection errors
    this.flushTimer = null;

    // More general counter indicating that cruntime is currently in the call stack
    // doing work, such as scrubbing a log; used as a signal to avoid unintended
    // recursion such as logging a console.log() call that was (somehow) triggered
    // while creating a different log record.
    this.cruntimeActive = 0;

    // The cruntime allows the active span handle OR active join IDs to be
    // tracked. Both type of objects may be on this stack. The code does not
    // simply store the join IDs of a span being pushed here as, if the span
    // handle is stored it's possible check that if the span has been end()'ed,
    // which avoids some set of false positive trace joins.
    this.activeSpanOrJoinIDsStack = [];

    // Runtime info
    this.enabled    = true; // If false, turn the runtime into as close to a noop as possible
    this.joinIds    = {};   // Global join ids that will be inherited by all spans

    // Buffers
    this.reportOldestMicros   = now;
    this.reportYoungestMicros = now;
    this.spans                = [];
    this.logs                 = [];
    this.discardedLogSamples  = new TimestampSamples(100, 3);

    // Reusable objects / object pools to reduce gc thrashing
    this.reusable = {
        reportRequest       : new crouton_thrift.ReportRequest(),
        status              : {},
    };

    // Report counters - reset on every successful report.
    //
    // The field names have a correspondence to the Go instrument/client
    // counter name constants (i.e. known counter names will be exposed
    // in the UI). Sending "unknown" counters is fine as well as the
    // server may eventually expose these and the client does not require
    // an update.
    this.counters = {
        dropped_logs         : 0,
        dropped_spans        : 0,

        // These obviously rely on a report eventually getting through!
        flush_with_no_data   : 0,
        flush_errors         : 0,
        flush_exceptions     : 0,
    };

    // Adapters on the client RPCs (due to asymmetry in the node / browser
    // thrift calling conventions).
    this.invokeReport = null;
    this.thriftHttpErrorCallback = null;    // <-- workaround for thrift code

    // Make the State object into a Facade that hides the platform differences
    //
    // TODO: eventually hide the need for an explicit isNode bool!
    //
    this.platform           = platform;
    this.logger             = null;
    this.processAbort       = null;

    // Initialize the default options
    this.options({
        scrubber            : null,     // <-- forces the default scrubber
        override_console    : true,
        override_logger     : null,
        override_abort      : null,
    });
}

// Inherit from EventEmitter
State.prototype = new EventEmitterMin();

// See the API initialize() documentation for details.
State.prototype.initialize = function (opts) {
    // The multiple initialization rule above is intentional based on the assumption
    // that well-defined initialization order to *not* something the cruntime should
    // require from all clients as that makes the cruntime harder to integrate.  The
    // above rule lets customers be a little more careless and still have it "just work".
    // No points for elegance; points for convenience.
    if (this.initialized) {
        // Treat redundant initialize calls as options() calls to merge any
        // and all options.
        this.options(opts);
        this.startFlushBufferLoopIfPossible(opts);
        return;
    }

    //
    // First initialization
    //
    this.emit("preinitialize", this.api);

    this.options(opts);
    this.startFlushBufferLoopIfPossible(opts);

    this.initialized = true;
    this.emit("postinitialize", this.api);
};

State.prototype.startFlushBufferLoopIfPossible = function(opts) {
    // Only start the reporting loop if there's an access token set and
    // if not explicitly paused.
    var paused = opts ? opts.paused : false;
    if (this.auth.access_token && !paused) {
        this.ensureFlushBufferLoopStarted();
    }
};

// TODO: the code does not support re-initializing after shutdown. While not a
// necessary feature, if the code was set up more elegantly, that would work
// implicitly.
State.prototype.shutdown = function() {
    if (!this.enabled) {
        return;
    }

    this.shuttingDown = true;

    // Emit the message before the final flush in case the client code wants to
    // record any final data
    this.emit("shutdown");

    // "Forcibly" close all unclosed spans with an error
    var spans = span_handle.activeSpanHandles();
    for (var i = 0; i < spans.length; i++) {
        var span = spans[i];
        span.error("Active span not closed:", span.name());
        span.end();
    }

    this.flushBuffer(true);
};

// Sets options on the runtime.  Returns the subset of "user-visible" options
// if called with no arguments.
State.prototype.options = function (opts) {
    var self = this;
    var key;

    // Act as an accessor if there are no arguments.
    if (arguments.length === 0) {
        return {
            enable                   : this.enabled,
            access_token             : this.auth.access_token,
            service_host             : this.serviceHost,
            service_port             : this.servicePort,
            group_name               : this.runtime.group_name,
            join_ids                 : this.joinIds,
            max_log_records          : this.bufferMaxLogRecords,
            max_span_records         : this.bufferMaxSpanRecords,
            debug                    : this.debug,
            // XXX nothing reasonable (?) for override_console
            refresh_interval_millis  : this.refreshIntervalMs,

            handle_uncaught_excepton : this.handle_uncaught_excepton,
            autoinstrument           : this.autoinstrument,
            automonitor              : this.automonitor,
        };
    }

    if (typeof opts !== "object") {
        this.logArgumentsError(["options called with a non-object argument"]);
    }

    //
    // enable {boolean}
    //
    if (typeof opts.enable !== "undefined") {
        this.setEnabled(opts.enable);

        // Special case for disable: ensure the
        if (!this.enabled) {
            opts.override_console = false;
        }
    }

    //
    // access_token {string}
    //
    if (typeof opts.access_token === "string") {
        this.auth.access_token = opts.access_token;
    }

    //
    // service_host {string}
    //
    // Sets the host use for reporting.
    //
    if (typeof opts.service_host === "string") {
        this.serviceHost = opts.service_host;
    }

    //
    // service_port {int|string}
    //
    // Sets the port use for reporting.
    //
    if (opts.service_port) {
        var port = parseInt(opts.service_port);
        this.servicePort = port;
    }

    //
    // group_name {string}
    //
    // Sets the runtime's group_name.
    //
    if (typeof opts.group_name === "string") {
        this.runtime.group_name = opts.group_name;
        // Also, set the guid.
        this.runtime.guid = String(this.platform.runtimeGUID(opts.group_name));

        // Emit an event so add-ons like the session join id.
        this.emit("options.set_group_name", this.api, this.runtime.group_name);
    }

    //
    // join_ids {object}
    //
    // A set of string-to-string key-value pairs to be set globally for the
    // runtime.  All created spans will inherit these join ids.
    //
    if (opts.join_ids !== undefined) {
        for (key in opts.join_ids) {
            var value = opts.join_ids[key];
            if (value !== undefined) {
                this.joinIds[key] = value;
            } else {
                delete this.joinIds[key];
            }
        }
    }

    //
    // max_log_records {int}
    //
    // Maximum number of log records to buffer. If the current buffer already
    // exceeds this size, the buffer size will not reset until the next
    // report.
    //
    // Setting to null will reset to the default value.
    //
    if (typeof opts.max_log_records === "number") {
        // Always buffer at least 1; this simplifies the runtime logic and the
        // client can always set "enable" to false.
        this.bufferMaxLogRecords = Math.max(opts.max_log_records, 1);
    } else if (opts.max_log_records === null) {
        this.bufferMaxLogRecords = kMaxLogRecordsDefault;
    }

    //
    // max_span_records {int}
    //
    // Maximum number of log records to buffer. If the current buffer already
    // exceeds this size, the buffer size will not reset until the next
    // report.
    //
    // Setting to null will reset to the default value.
    //
    if (typeof opts.max_span_records === "number") {
        // Always buffer at least 1; this simplifies the runtime logic and the
        // client can always set "enable" to false.
        this.bufferMaxSpanRecords = Math.max(opts.max_span_records, 1);
    } else if (opts.max_span_records === null) {
        this.bufferMaxSpanRecords = kMaxSpanRecordsDefault;
    }

    //
    // debug {bool}
    //
    // Should the instrumentation offer a way to debug the current interaction.
    // TODO browser only?
    //
    if (typeof opts.debug === "boolean") {
        this.debug = opts.debug;

        // Emit an event so add-ons like the debug overlay window can know to display
        // themselves or not.
        this.emit("options.set_debug", this.api, this.debug);
    }

    //
    // verbose {bool}
    //
    // If true, greatly increases the amount of internal and instrumented logging.
    //
    if (typeof opts.verbose === "boolean") {
        this.verbose = opts.verbose;
    }

    //
    // log_to_stdio {bool}, default = false
    //
    // Indicates whether or not cr.log/warn/error calls should be echoed to standard
    // output.
    if (typeof opts.log_to_stdio === "boolean") {
        this.logToStdio = opts.log_to_stdio;
    }

    //
    // override_console {bool}
    //
    // Override the global window.console / global.console object and pipe the
    // input through cruntime.  A value of `false` will reset the console object.
    if (opts.override_console !== undefined) {
        if (opts.override_console === true) {
            console.log   = function() {
                if (self.enabled && !self.flushActive && !self.cruntimeActive) {
                    self.logArgumentsInfo.call(self, arguments, undefined, true);
                } else {
                    originalConsole_log.apply(originalConsole, arguments);
                }
            };
            console.warn  = function() {
                if (self.enabled && !self.flushActive && !self.cruntimeActive) {
                    self.logArgumentsWarn.call(self, arguments, undefined, true);
                } else {
                    originalConsole_warn.apply(originalConsole, arguments);
                }
            };
            console.error = function() {
                if (self.enabled && !self.flushActive && !self.cruntimeActive) {
                    self.logArgumentsError.call(self, arguments, undefined, true);
                } else {
                    originalConsole_error.apply(originalConsole, arguments);
                }
            };
        } else {
            console.log   = originalConsole_log;
            console.warn  = originalConsole_warn;
            console.error = originalConsole_error;
        }
    }

    //
    // refresh_interval_millis {number}
    //
    // Set how frequently the cruntime reports to the service, in milliseconds.
    // If set to null, the cruntime will reset the report interval to its
    // internal default.
    //
    if (typeof opts.refresh_interval_millis === "number") {
        this.refreshIntervalMs = Math.max(0, opts.refresh_interval_millis);
    } else if (opts.refresh_interval_millis === null) {
        this.refreshIntervalMs = kRefreshIntervalMsDefault;
    }

    //
    // scrubber {object}
    //
    // Sets the options on the payload data scrubber. See rl-scrubber for documentation
    // on the scrubber options. If set to null, the scrubber will be reset to the
    // default configuration.
    //
    if (opts.scrubber === null) {
        this.scrub = scrubber.make({
            rules : [].concat(kBaselineScrubberRules, kDefaultScrubbersRules),
        });
    } else if (typeof opts.scrubber === "object") {
        // Ensure the baseline rules are always included so that traceguide internal
        // information is stripped from the payloads
        var scrubberConfig = {};
        for (key in opts.scrubber) {
            scrubberConfig[key] = opts.scrubber[key];
        }
        scrubberConfig.rules = kBaselineScrubberRules.concat(scrubberConfig.rules || []);
        this.scrub = scrubber.make(scrubberConfig);
    }

    //
    // certificate_verification {boolean}
    //
    // If false, informs the node https libraries not to do certification verification.
    // Useful for development environments.
    //
    if (opts.certificate_verification !== undefined) {
        this.certificateVerification = !!opts.certificate_verification;
    }

    //
    // certificate_verification {boolean}
    //
    // If true, in Node.js a handler for the process.on('uncaughtException') event
    // will be added to log and rethrow the exception.
    //
    // Disabled by default due to a customer report of this having side-effects.
    //
    if (opts.handle_uncaught_excepton !== undefined) {
        this.handle_uncaught_excepton = !!opts.handle_uncaught_excepton;
    }

    //
    // autoinstrument {boolean}
    //
    if (opts.autoinstrument !== undefined) {
        this.autoinstrument = !!opts.autoinstrument;
    }

    //
    // automonitor {boolean}
    //
    if (opts.automonitor !== undefined) {
        this.automonitor = !!opts.automonitor;
    }


    //
    // -- internal use only --
    //
    // cruntime_platform {string}
    //
    // Platform of the cruntime itself (i.e. node or browser and a x.x.x semantic
    // version string).
    if (typeof opts.cruntime_platform === "string") {
        this.replaceOrAddRuntimeKeyValue("cruntime_platform", opts.cruntime_platform);
    }

    //
    // -- internal use only --
    //
    // cruntime_platform {string}
    //
    // Semantic version of the cruntime itself (i.e. x.x.x style version string,
    // http://semver.org/).
    //
    if (typeof opts.cruntime_version === "string") {
        this.replaceOrAddRuntimeKeyValue("cruntime_version", opts.cruntime_version);
    }


    //
    // -- internal use only --
    //
    // reset_object_pools {bool}
    //
    // Reset the object pools, for testing test the memory usage
    //
    if (opts.reset_object_pools) {
        this.resetObjectPools();
    }

    //
    // -- internal use only --
    //
    // override_abort {function()}
    //
    // Allow the platform abort() function to be overridden for testing.
    // Setting a value of `null` will revert back to the platform abort()
    // implementation.
    //
    if (opts.override_abort !== undefined) {
        if (typeof opts.override_abort === "function") {
            this.processAbort = opts.override_abort;
        } else {
            this.processAbort = function() { return this.platform.abort(); };
        }
    }

    //
    // -- internal use only --
    //
    // override_logger {object}
    //
    // Allow the platform console to be overridden for testing purposes.
    // The override is *not* a 1:1 mapping to the normal logger. Instead it
    // simplifies things down to a single function as this is for basic
    // testing.
    if (opts.override_logger !== undefined) {

        var f = opts.override_logger;
        if (typeof f == "function") {

            // Create a very simple logger proxy.
            var g = function(args) {
                return f(args.join(" "));
            };
            this.logger = {
                info  : g,
                warn  : g,
                error : g,
                fatal : g,
            };

        } else {
            this.logger = this.platform.logger;
        }
    }

    //
    // -- internal use only --
    //
    // override_report_rpc {function(synchornous, request, callback(err, response))}
    //
    // Allow the reporting function to be overridden for testing.
    if (opts.override_report_rpc !== undefined) {
        if (typeof opts.override_report_rpc === "function") {
            this.invokeReport = opts.override_report_rpc;
        } else if (this.client) {
            // If there's a thrift client, connect back to the RPC
            this.invokeReport = this.createAsyncRPCAdapter(this.client.Report, crouton_thrift.ReportResponse);
        } else {
            // Otherwise, leave in the unconnected state
            this.invokeReport = null;
        }
    }

    //
    // -- internal use only --
    //
    // disable_clock_correction {boolean}
    //
    // Turn off automatic clock correction.
    if (opts.disable_clock_correction !== undefined) {
        this.disableClockCorrection = !!opts.disable_clock_correction;
    }
};

State.prototype.nowMicros = function() {
    // Coerce the value to an integer by OR'ing with zero as a
    // precaution given various platform timer implementation differences.
    return Math.floor(this.platform.nowMicros());
};

State.prototype.generateGUID = function() {
    return this.platform.generateGUID();
};

State.prototype.stackTrace = function() {
    return this.platform.stackTrace();
};

State.prototype.defaultLogFilename = function() {
    return this.platform.defaultLogFilename();
};

State.prototype.replaceOrAddRuntimeKeyValue = function(key, value) {
    var keyValue = new crouton_thrift.KeyValue();
    keyValue.Key = "" + key;    // Coerce to a string
    if (typeof value !== "string") {
        try {
            value = JSON.stringify(value);
        }
        catch (e) {
            value = "" + value;
        }
    }
    keyValue.Value = value;

    if (!this.runtime.attrs) {
        this.runtime.attrs = [];
    }
    for (var i = 0; i < this.runtime.attrs.length; i++) {
        var attr = this.runtime.attrs[i];
        if (attr.Key == key) {
            break;
        }
    }

    // JS reminder: setting to array[length] is the same as array.push(),
    // so this works for both the replace and insert cases.
    this.runtime.attrs[i] = keyValue;
};

State.prototype.runtimeAttributes = function (attrs) {
    // Getter
    if (arguments.length === 0) {
        var map = {};
        for (var i = 0; i < this.runtime.attrs.length; i++) {
            var attr = this.runtime.attrs[i];
            map[attr.Key] = attr.Value;
        }
        return map;
    }

    // Setter
    if (typeof attrs !== "object") {
        // TODO: Some internal warning/error API is needed
        if (DEBUG) {
            console.assert(false, "Unexpected attrs value");
        }
        return;
    }
    for (var key in attrs) {
        this.replaceOrAddRuntimeKeyValue(key, attrs[key]);
    }
};

State.prototype.runtimeGUID = function() {
    return this.runtime.guid;
};

State.prototype.setEnabled = function(enable) {
    // Coerce into a bool
    enable = !(!enable || (enable === "false" ? true : false));
    if (this.enabled === enable) {
        return;
    }

    this.enabled = enable;

    if (!enable) {
        // Respect the "turn this off!" command ASAP. Don't try to flush the
        // buffers -- discard 'em.
        this.discardBuffers();
    }
};

State.prototype.getEnabled = function() {
    return this.enabled;
};

State.prototype.getVerbose = function() {
    return this.verbose;
};


State.prototype.getStatus = function() {
    var status = this.reusable.status;
    status.enabled = this.enabled;
    status.flushActive = this.flushActive;
    return status;
};

//===========================================================================//
// Buffer / refresh loop
//===========================================================================//

// TODO: localStorage -- currently trying to force the RPC through on the
// beforeunload event doesn't seem to be working consistently.  Another option
// might be to stash the pending buffer into localStorage, and for the case
// where they are navigating to another page on the same site, they new page
// could then pick up that buffer on load and send it along.
//
State.prototype.flushBuffer = function(synchronous, done) {
    var self = this;
    done = done || function(err) {};

    // Early out if there's nothing to do or waiting on an existing flush
    if (!this.enabled) {
        return done();
    }

    if (this.flushActive) {
        return done();
    }
    if (!this.runtime.group_name) {
        return done();
    }
    if (!this.runtime.guid) {
        if (DEBUG) {
            _error("runtime.group_name is set but runtime.guid is invalid!");
        }
        return done();
    }

    this.ensureClockStateInitialized();

    // Save the current offset in case we need to undo this correction
    // (i.e. if we were to put them back in the queue).
    var timeOffsetMicros = 0;
    var clockReady = this.disableClockCorrection || this.clockState.isReady();
    if (!this.disableClockCorrection) {
        timeOffsetMicros = this.clockState.offsetMicros();
        this.logEvent("cr/time_correction_state", {
            "offset_micros" : timeOffsetMicros,
            "active_samples" : this.clockState.activeSamples(),
            "ready" : clockReady,
        });
    }

    if (clockReady && this.logs.length === 0 && this.spans.length === 0) {
        this.counters.flush_with_no_data++;
        return done();
    }

    this.ensureClientConnectionStarted();
    var req = this.reusable.reportRequest;

    // Allow a synchronous request as an option for the unload case where
    // we really want to cram that data across the wire before the user
    // leaves the page!
    synchronous = synchronous || false;

    // Only send the data if the clock is corrected or if this is "synchronous."
    var sendLogsAndSpans = clockReady || synchronous;
    if (sendLogsAndSpans) {
        req.span_records = this.spans;
        req.log_records = this.logs;
    } else {
        req.span_records = [];
        req.log_records = [];
    }

    // Set the runtime_guid here as log records may come in during the
    // cruntime initialization, whereas the GUID is definitely set by the
    // first flush operation
    var guid = this.runtime.guid;
    var i;
    for (i = 0; i < req.log_records.length; i++) {
        req.log_records[i].runtime_guid = guid;
    }
    for (i = 0; i < req.span_records.length; i++) {
        req.span_records[i].runtime_guid = guid;
    }

    this.reportYoungestMicros = this.nowMicros();

    req.runtime = this.runtime;
    req.timestamp_offset_micros = timeOffsetMicros;
    req.oldest_micros = this.reportOldestMicros;
    req.youngest_micros = this.reportYoungestMicros;

    // Convert the discarded log record sample counts to thrift
    //
    // TODO: convert this code to use ReportRequest.counters
    //
    var key;
    var bucketMag = this.discardedLogSamples.magnitude;
    for (key in this.discardedLogSamples.buckets) {
        var thrift_bucket = new crouton_thrift.SampleCount();
        thrift_bucket.oldest_micros = key * bucketMag;
        thrift_bucket.youngest_micros = thrift_bucket.oldest_micros + bucketMag;
        thrift_bucket.count = this.discardedLogSamples.buckets[key];
    }

    if (DEBUG) {
        console.assert(req.runtime.guid, "Runtimes require a GUID");
        console.assert(req.runtime.group_name, "Runtimes require a group_name");
    }

    // Convert the counters
    //
    // TODO: would be nice to reuse objects to avoid the dynamic allocations
    // make here. Saving that optimization for a later day.
    var thriftCounters = [];
    for (key in this.counters) {
        var value = this.counters[key];
        if (value > 0) {
            thriftCounters.push(new crouton_thrift.NamedCounter({
                Name  : key,
                Value : value,
            }));
        }
    }
    if (thriftCounters.length > 0) {
        req.counters = thriftCounters;
    }


    // TL;DR: writing a custom thrift.js wouldn't be such a bad idea.
    //
    // CAREFUL #1: the object passed to the callback as arg 1 is either the
    // response object in the case of success, or the error which glancing at
    // the JS library is either a string or a Thrift.TApplicationException (or
    // conceivably any kind of random exception that could be thrown during
    // processing).  In other words, it's probably best to check that res
    // against the expected instanceof type rather than checking for an
    // error type.  Sigh, why didn't they just use the more standard
    // function(err, res) convention??
    //
    // CAREFUL #2: even if the callback is eventually a no-op, it still needs
    // to be passed into the call as the presence of the callback is how
    // thrift determines if it should be a synchronous or asychronous call.
    //
    // Both the above problems could be solved with minor modifications to
    // thrift.js but then means commiting to a forked version.
    //

    // Release the in-memory objects once the request goes through.
    if (DEBUG) {
        console.assert(!this.flushActive, "Flush already active!");
    }
    this.flushActive = true;

    try {
        var originMicros = self.nowMicros();

        this.invokeReport(synchronous, req, function (err, res) {

            if (err && err.code == "DEPTH_ZERO_SELF_SIGNED_CERT") {
                if (_once(err.code)) {
                    _error("Error sending runtime instrumentation report:", err);
                    _error("Consider setting the runtime option 'certificate_verification' to false if you wish to ignore this error.");
                }
            }

            var destination_micros = self.nowMicros();
            self.flushActive = false;
            if (!err) {
                if (res) {
                    self.reportOldestMicros = self.nowMicros();
                    self.reportYoungestMicros = self.reportOldestMicros;

                    // Counters are for the report interval and thus all values
                    // are reset after the successful report.
                    for (var key in self.counters) {
                        self.counters[key] = 0;
                    }

                    self.emitSpansRecordedEvent(req.span_records, timeOffsetMicros, synchronous);

                    if (res.commands) {
                        for (var i = 0; i < res.commands.length; i++) {
                            var cmd = res.commands[i];
                            if (!cmd) {
                                continue;
                            }
                            if (cmd.disable) {
                                self.options({ enable : false });
                            }
                        }
                    }

                    if (res.timing && res.timing.receive_micros && res.timing.transmit_micros) {
                        self.clockState.addSample(originMicros, res.timing.receive_micros,
                                                  res.timing.transmit_micros, destination_micros);
                    }
                }
                releaseArrays(req.log_records, req.span_records);
                if (!sendLogsAndSpans) {
                    // Return a special error so that we can retry more
                    // quickly (since we didn't send any real data).
                    done(kClockStateNotReadyError);
                    return;
                }
            } else {
                self.counters.flush_errors++;
                if (sendLogsAndSpans) {
                    // Only restore if we tried to send something in the first place.
                    self.restoreRecordsAfterError(req.log_records, req.span_records);
                }
            }

            done(err);
        });

        // Clear the current buffers.  Note: this is not the same releasing the
        // objects themselves which is handled by releaseArrays().
        if (sendLogsAndSpans) {
            this.logs = [];
            this.spans = [];
        }
        this.discardedLogSamples.clear();

    } catch (e) {
        self.counters.flush_exceptions++;

        if (this.flushActive) {
            this.flushActive = false;
        }

        return done(e);
    }
};

// Emit an event about the spans that were just recorded -- currently for
// the HTML debugging overlay.
State.prototype.emitSpansRecordedEvent = function(spans, timeOffsetMicros, synchronous) {
    if (!spans || spans.length === 0) {
        return;
    }

    var self = this;

    // Only do this if there is an actual listener, since the cloning is
    // relatively expensive.
    if (!EventEmitterMin.listenerCount(self, "spans_recorded")) {
        return;
    }

    // The span data is *cloned* here rather than reused, as the span objects
    // come from a reusable memory pool.  Passing those objects directly via
    // the event puts the objects outside the memory pool's control.
    var eventSpans = [];
    for (var i = 0; i < spans.length; i++) {
        var record = spans[i];
        var join_ids = {};
        for (var j = 0; j < record.join_ids.length; j++) {
            var joinId = record.join_ids[j];
            join_ids[joinId.TraceKey] = joinId.Value;
        }
        eventSpans.push({
            // This is cheating a little bit, but bake in an
            // assumption about how the downstream service is going to
            // apply the correction and add timeOffsetMicros here.
            oldest_micros   : record.oldest_micros + timeOffsetMicros,
            youngest_micros : record.youngest_micros + timeOffsetMicros,
            span_name       : record.span_name,
            span_guid       : record.span_guid,
            join_ids        : join_ids,
        });
    }

    // Really we should wait until the server has indexed this
    // span, instead of just until we think the server has
    // received it, but this is better than nothing.
    if (synchronous) {
        self.emit("spans_recorded", eventSpans);
    } else {
        setTimeout(function() {
            self.emit("spans_recorded", eventSpans);
        }, 0);
    }
};

// Intended to be called when a pair of span and log record arrays fail to
// report properly.  This adds them back into the internal buffer while
// respecting the buffer limits.
//
// TODO: some form sampling rather than discard would be nice here.
State.prototype.restoreRecordsAfterError = function(logs, spans) {

    function prependOffset(buffer, records, max) {
        var space = max - buffer.length;
        if (space > 0) {
            return Math.max(0, records.length - space);
        } else {
            return records.length;
        }
    }

    var discard = false;
    var logOffset = prependOffset(this.logs, logs, this.bufferMaxLogRecords);
    var logDiscard = [];
    if (logOffset < logs.length) {
        logDiscard = logs.slice(0, logOffset);
        this.logs = logs.slice(logOffset).concat(this.logs);
        discard = true;
    }

    var spanOffset = prependOffset(this.spans, spans, this.bufferMaxSpanRecords);
    var spanDiscard = [];
    if (spanOffset < spans.length) {
        spanDiscard = spans.slice(0, spanOffset);
        this.spans = spans.slice(spanOffset).concat(this.spans);
        discard = true;
    }

    if (discard) {
        releaseArrays(logDiscard, spanDiscard);
    }
};

// TODO: the connection initialization needs to be de-coupled from the looping
// logic as it is conceivable that a client might want to manual control the
// flush calls.
//
// TODO: Overlapping with the prior todo, this needs to check if the loop has
// already been started.
//
State.prototype.ensureFlushBufferLoopStarted = function() {

    // Ignore redundant requests
    if (this.refreshLoopActive) {
        return;
    }

    if (DEBUG) {
        console.assert(this.client === null, "Client already initialized");
    }

    var self = this;
    this.refreshLoopActive = true;

    (function loop() {
        self.flushBuffer(false, function(err) {
            // Exponentially back off on the refresh loop if errors are occurring.
            // Ignore the first couple errors; then exponentially back off up to a limit.
            if (err && err != kClockStateNotReadyError) {
                self.flushErrorCount++;

                // The conditional below is conservative. There's no "spec" on what err
                // might be for depending on the platform and where the error occurs in
                // Thrift.
                //
                // Also, sadly on the browser side there's no way to distinguish any kind
                // of error so we have to swallow all browser errors to prevent the browser
                // console being polluted if the connection can't be made to our server.
                if (self.isNode && err.code != "ECONNREFUSED") {
                    self.flushNonConnectErrorCount++;
                    if (DEBUG) {
                        _error("flushBuffer error:", err);
                    }
                }
            } else {
                self.flushErrorCount = 0;
                self.flushNonConnectErrorCount = 0;
            }

            if (!self.shuttingDown) {
                if (err == kClockStateNotReadyError) {
                    // Set a short timeout for this case.
                    self.flushTimer = setTimeout(loop, kClockSamplingIntervalMs);
                } else {
                    var backOff = Math.pow(2, Math.max(0, Math.min(8, self.flushErrorCount - 2)));
                    self.flushTimer = setTimeout(loop, backOff * self.refreshIntervalMs);
                }

                // Make the timer effectively "weak" in the sense that a pending callback will
                // not keep the process alive.
                // https://nodejs.org/api/timers.html#timers_unref
                if (typeof self.flushTimer.unref === "function") {
                    self.flushTimer.unref();
                }

                // As a precaution against the Thrift connection being in a zombie state,
                // recreate the client object after repeated failures.
                var limit = kResetConnectionEveryNthFlushError;
                if ((self.flushNonConnectErrorCount % (limit + 1)) == limit) {
                    _error("flushBuffer error limit reached: recreating client connection.");
                    self.connectionOk = false;
                }

                // As a precaution against the data itself somehow preventing the RPC from
                // going through, discard the buffers if A LOT of failures have occurred in
                // a row.
                limit = kDiscardDataEveryNthFlushError;
                if ((self.flushNonConnectErrorCount % (limit + 1)) == limit) {
                    _error("flushBuffer error limit reached: discarding buffers.");
                    self.discardBuffers();
                }

            } else {
                clearTimeout(self.flushTimer);
            }
        });
    })();
};

State.prototype.ensureClockStateInitialized = function() {
    if (!this.clockState) {
        this.clockState = new ClockState(this.platform, this);
    }
};

// Create the Thrift client object if it has not yet been created or if the
// connection has been indicated as being not okay.  In the case that the connection
// is ok, this is a no-op.
State.prototype.ensureClientConnectionStarted = function() {
    var self = this;

    if (this.connectionOk) {
        return;
    }

    // TODO: encapsulate all platform differences in a separate package
    // and get rid of these isNode checks.
    if (!this.platform.isNode) {

        // Note this is implicitly using the JSON protocol -- not the binary protocol.
        // That's the default (and only supported JS protocol in !isNode).
        var serviceUrl = "https://" + this.serviceHost + ":" + this.servicePort + "/_rpc/v1/reports/json";
        var transport = new Thrift.Transport(serviceUrl);
        var protocol  = new Thrift.Protocol(transport);
        this.client   = new crouton_thrift.ReportingServiceClient(protocol);

        // The connection is only set for Node.js as a means to force a synchronous RPC
        this.connection = null;

    } else {

        var options = {
            transport   : Thrift.TBufferedTransport,
            protocol    : Thrift.TBinaryProtocol,
            path        : "/_rpc/v1/reports/binary",
            https       : true,
            nodeOptions : {},
        };
        if (!this.certificateVerification) {
            // https://github.com/request/request/issues/418
            options.nodeOptions.rejectUnauthorized = false;
            options.nodeOptions.strictSSL = false;
        }

        this.connection = Thrift.createHttpConnection(this.serviceHost, this.servicePort, options);
        this.client = Thrift.createHttpClient(crouton_thrift.ReportingServiceClient, this.connection);

        // Patch thrift with support for, well, the name says it...
        self.platform.patchHttpConnectionForSynchronousRPC(this.connection);

        this.connection.on("error", function(err) {
            // See createAsyncRPCAdapter for details
            if (self.thriftHttpErrorCallback) {
                self.thriftHttpErrorCallback(err);
            } else {
                _error("Unhandled Thrift error:", err);
            }
        });
    }

    // The reporting function might be non-null already if it has been
    // manually overridden, e.g. for unit testing.  Don't clobber that
    // value.
    if (!this.invokeReport) {
        this.invokeReport = this.createAsyncRPCAdapter(this.client.Report, crouton_thrift.ReportResponse);
    }

    this.connectionOk = true;
};

// RPC adapters since thrift has different calling conventions for the
// browser and node.js. (This is *almost* sufficiently annoying to consider
// forking thrift and fixing this particular piece of poor design.)
//
// This normalizes on a function (err, res) { ... } style callback.
//
// TODO: it might be nice to hide this in the platform-dependent code, not
// here.  But it is less indirection to just do it here.
//
State.prototype.createAsyncRPCAdapter = function(rpc, respType) {
    var self = this;

    var callbackAdapter;
    if (!this.platform.isNode) {

        // Browser case.
        return function(synchronous, req, callback) {
            if (DEBUG) {
               console.assert(self.auth && self.auth.access_token, "Expected access_token");
            }

            // Thrift fun fact: as well as having multiple workarounds for the various
            // ways thrift does and doesn't return errors, it's also necessary to check
            // if it throws an exception.
            try {
                if (!synchronous) {
                    rpc.call(self.client, self.auth, req, function(res) {
                        // The thrift browser-side convention here is frustrating. Valid
                        // responses and errors are overloaded into the same variable and
                        // need to be differentiated by a type-check.
                        if (!(res instanceof respType)) {
                            callback(res, null);
                        } else {
                            callback(null, res);
                        }
                    });
                } else {
                    // So "synchronous" has evolved into a misnomer at this point....
                    //
                    // The real intent is what might be called a "tail flush" -- a
                    // flush before the runtime exits that should not be interrupted.
                    // On the browser side, what this means is setting up an async,
                    // deferred URI-encoded report that *is* async, but will not be
                    // interrupted as a normal async XHR might be when the page is
                    // navigated away from.

                    var authJSON   = JSON.stringify(self.auth);
                    var reportJSON = JSON.stringify(req);

                    var url = "https://" +
                        self.serviceHost +
                        ":" + self.servicePort +
                        "/_rpc/v1/reports/uri_encoded" +
                        "?auth=" + encodeURIComponent(authJSON) +
                        "&report=" + encodeURIComponent(reportJSON);

                    var elem = document.createElement("script");
                    elem.async = true;
                    elem.defer = true;
                    elem.src = url;
                    elem.type = "text/javascript";
                    var hostElem = document.getElementsByTagName("head")[0];
                    if (hostElem) {
                        hostElem.appendChild(elem);
                    }

                    // Reference code for making a synchronous Thrift call.  Note that
                    // this would block (not surprisingly) which was problematic if the
                    // Traceguide server was bogged down as the client had to wait for
                    // the timeout.
                    /*var res = rpc.call(self.client, self.auth, req);
                    if (!(res instanceof respType)) {
                        return callback(res, null);
                    } else {
                        return callback(null, res);
                    }*/
                }
            } catch (e) {
                return callback(e, null);
            }
        };

    } else {

        // Node.js case.
        return function(synchronous, req, callback) {
            if (DEBUG) {
                console.assert(self.auth && self.auth.access_token, "Expected access_token");
            }

            // ARGH: the Thrift Node HttpConnection does NOT call the callback on an
            // HTTP error (e.g. ECONNREFUSED).
            //
            // The workaround is fragile and depends on how the surrounding code works.
            // We do have a hook into *any* http error via the Thrift.HttpConnection
            // object, which in a totally serial req/resp chain is sufficient to
            // correctly call the callback; however, in the case of parallel calls where
            // two requests go out, how do we know which request triggered the error?
            //
            // The cruntime code however is currently serial in sending its reports
            // (it postpones subsequent reports until it hears back about the last
            // one) -- so we can take advantage of the error coming in serially as
            // well.
            //
            // For what it's worth, this is not trivial to fix in the thrift code as
            // the HttpConnection class has no knowledge of the incoming request and
            // where it would report the error to.
            //
            // <rant target="thrift_dev">Always call the callback if you write a function
            // that takes callback, otherwise you make it impossible for callers to
            // properly manage control flow!!!</rant>
            //
            var errorHandlingCallback = function() {
                self.thriftHttpErrorCallback = null;
                callback.apply(this, arguments);
            };
            self.thriftHttpErrorCallback = errorHandlingCallback;

            // Patch #2 for synchronous RPCs.  This is not vanilla thrift.
            self.connection.synchronousRPC = synchronous;

            rpc.call(self.client, self.auth, req, errorHandlingCallback);
        };
    }
};

// Discard any unflushed data currently in the buffers
State.prototype.discardBuffers = function() {
    releaseArrays(this.logs, this.spans);
    this.logs = [];
    this.spans = [];
};

// Intended for internal use only for debugging.
State.prototype.resetObjectPools = function() {
    this.logs = [];
    this.spans = [];
    pool.logRecords.reset();
    pool.spanRecords.reset();
    pool.traceJoinIds.reset();
};

//===========================================================================//
// Logs
//===========================================================================//

// "Plain" in the sense that it goes straight to the original console.log,
// regardless of the cruntime settings.
State.prototype.plainLog = function() {
    return originalConsole_log.apply(originalConsole, arguments);
};

// "Plain" in the sense that it goes straight to the original console.warn,
// regardless of the cruntime settings.
State.prototype.plainWarn = function() {
    return originalConsole_warn.apply(originalConsole, arguments);
};

// "Plain" in the sense that it goes straight to the original console.error,
// regardless of the cruntime settings.
State.prototype.plainError = function() {
    return originalConsole_error.apply(originalConsole, arguments);
};

function coerceString(obj, fieldName) {
    var type = typeof obj[fieldName];
    if (type === "undefined") {
        return;
    } else if (type !== "string") {
        obj[fieldName] = ("" + obj[fieldName]);
    }
}

function isNumberOrUndefined(val) {
    var type = typeof val;
    return (type === "undefined" || type === "number");
}
function isBooleanOrUndefined(val) {
    var type = typeof val;
    return (type === "undefined" || type === "boolean");
}
function isStringOrUndefined(val) {
    var type = typeof val;
    return (type === "undefined" || type === "string");
}


State.prototype.rawLogRecord = function (fields) {
    if (DEBUG) {
        console.assert(this.runtime, "Runtime has not been initialized properly");
    }
    if (!this.enabled) {
        return;
    }

    this.cruntimeActive++;

    // Thrift throws an exception on type mismatches and it's difficult to
    // determine what record or field contained the mismatch, so coerce them
    // all here. This code has to be kept in sync with changes to crouton.thrift,
    // sigh...

    // Be nice and coerce these fields which may be coming from the customer and
    // it's easy to convert them correctly to string form:
    coerceString(fields,  "runtime_guid");
    coerceString(fields,  "span_guid");
    coerceString(fields,  "stable_name");
    coerceString(fields,  "message");
    coerceString(fields,  "filename");

    // Coerce the timestamp micros to an integer. For example, Safari's
    // performance API implementation sometimes returns decimal values.
    //
    // A couple notes:
    // - parseInt() is not used here as timestamp_micros is supposed to be
    //   set internally; we're just being a little paranoid about decimals
    //   possibly sneaking in.
    if (typeof fields.timestamp_micros == "number") {
        fields.timestamp_micros = Math.floor(fields.timestamp_micros);
    }

    // Be less forgiving and reject records with mismatches on the fields that
    // really should be of the right type:
    if (!isStringOrUndefined(fields.level)) {
        _error("Invalid log record: level", fields);
        this.cruntimeActive--;
        return;
    }
    if (!isNumberOrUndefined(fields.thread_id)) {
        _error("Invalid log record: thread_id", fields);
        this.cruntimeActive--;
        return;
    }
    if (!isNumberOrUndefined(fields.line_number)) {
        _error("Invalid log record: line_number", fields);
        this.cruntimeActive--;
        return;
    }
    if (!isStringOrUndefined(fields.payload_json)) {
        _error("Invalid log record: payload_json", fields);
        this.cruntimeActive--;
        return;
    }
    // TODO:
    // if (!isListOrUndefined(fields.stack_frames)) { ... }
    //
    if (!isBooleanOrUndefined(fields.error_flag)) {
        _error("Invalid log record: error_flag", fields);
        this.cruntimeActive--;
        return;
    }

    // Surround the payload processing in an exception handler since we
    // have little control over the contents of the payload and don't
    // want exception leaking into customer code.
    //
    // TODO: in the future, it's undoubtedly possible that the inspect/scrub
    // process could be optimized to do less work for the common case of small
    // payloads that require no scrubbing.
    //
    try {
        // Check if the payload was passed in as a direct JSON string.  This
        // isn't really an expected case -- but handle it just in case by
        // converting it to an object so the truncation / scrubbing that follows
        // is applied.
        if (fields.payload_json) {
            if (DEBUG) {
                console.assert(!this.payload, "Both payload and payload_json specified");
            }
            try {
                fields.payload = JSON.parse(fields.payload_json);
            } catch (_ignored) {}
            delete fields.payload_json;
        }

        // The payload is both truncated (to cap max data transfer) and scrubbed
        // (to remove personal information, passwords, etc.) before being
        // transmitted as a JSON string.
        if (fields.payload !== null && fields.payload !== undefined) {
            var payload = makeInspectable(fields.payload);

            // Can be null if console.* is overridden and called during cruntime
            // initialization.
            if (this.scrub) {
                payload = this.scrub.modify(payload);
            }
            fields.payload_json = JSON.stringify(payload);
            fields.payload = null;
        }
    } catch (payloadException) {
        if (DEBUG) {
            originalConsole.error("rl-cruntime exception: " + payloadException);
            originalConsole.error(payloadException.stack);
        }
        delete fields.payload;
        delete fields.payload_json;
    }

    var record = pool.logRecords.acquire(fields);
    if (!record.timestamp_micros) {
        record.timestamp_micros = this.nowMicros();
    }

    if (this.logs.length >= this.bufferMaxLogRecords) {
        // Treat this like a random sampling and replace a record at random.
        // This is not truly random in mathematical sense for a number of reasons,
        // but the assumption this is provides more useful information than
        // dropping all records once the max is hit.
        var index = Math.floor(this.logs.length * Math.random());
        var recordToDiscard = this.logs[index];

        // discardedLogSamples keeps a fixed size buffer of how many log
        // records were discarded for a given time-period. It's a lightweight way
        // of letting the server know something about the data that *wasn't*
        // reported without taking up a lot of report bandwidth.
        this.discardedLogSamples.add(recordToDiscard.timestamp_micros);

        pool.logRecords.release(recordToDiscard);
        this.logs[index] = record;
        this.counters.dropped_logs++;
    } else {
        this.logs.push(record);
    }

    this.cruntimeActive--;
};

State.prototype.logArgumentsWithSpanGUID = function(spanGUID, level, error, args) {
    if (!this.enabled) {
        return;
    }

    // Normalize the arguments object into an Array (it might be an Arguments object
    // which does not have the same interface).
    args = Array.prototype.slice.call(args);

    // Record the payload as well since the message will likely insert things like
    // "[Object]" rather than an inspectable representation (given the use of
    // join("") below and that most objects do not provide toString() overrides).
    //
    // Skip this step if the args are empty or all the args are strings though, as
    // the payload will be conveying no new information in that case.
    var payload = {};
    var hasPayload = false;     // Don't record empty payloads
    if (args.length > 0 && !allElementsAreStrings(args)) {
        payload.arguments = args;
        hasPayload = true;
    }

    // args.join(" ") can complain about "TypeError: Cannot convert object to primitive value"
    // when the unrolled loop below does not.
    var message;
    if (args.length) {
        // Paranoid try-catch. Electron still manages to generate a TypeError on what appears
        // to be a valid empty object. Prefer an empty message to letting an exception creep
        // into the customer code.
        try {
            message = "" + args[0];
            for (var i = 1; i < args.length; i++) {
                message += " " + args[i];
            }
        } catch (e) {
            // TODO: an internal-only log of this would condition would be nice. But how do
            // you log info about an object that is causing an error when you're trying to
            // log info about it?!
        }
    }

    var record = {
        error_flag  : error ? true : false,
        level       : level,
        filename    : this.defaultLogFilename(),
        message     : message,
        span_guid   : spanGUID,
    };
    if (hasPayload) {
        record.payload = payload;
    }
    this.rawLogRecord(record);
};

State.prototype.logArgumentsInfo = function(args, spanGUID, echo) {
    if (!this.enabled) {
        return;
    }
    if (echo === undefined) {
        echo = this.logToStdio;
    }

    // Ensure args is a true Array, not an Arguments object
    args = Array.prototype.slice.call(args);
    this.logArgumentsWithSpanGUID(spanGUID, "I", false, args);

    if (echo) {
        this.logger.info(args);
    }
};

State.prototype.logArgumentsWarn = function(args, spanGUID, echo) {
    if (!this.enabled) {
        return;
    }
    if (echo === undefined) {
        echo = this.logToStdio;
    }

    // Ensure args is a true Array, not an Arguments object
    args = Array.prototype.slice.call(args);
    this.logArgumentsWithSpanGUID(spanGUID, "W", false, args);

    if (echo) {
        this.logger.warn(args);
    }
};

State.prototype.logArgumentsError = function(args, spanGUID, echo) {
    if (!this.enabled) {
        return;
    }
    if (echo === undefined) {
        echo = this.logToStdio;
    }

    // Ensure args is a true Array, not an Arguments object
    args = Array.prototype.slice.call(args);
    this.logArgumentsWithSpanGUID(spanGUID, "E", true, args);

    if (echo) {
        this.logger.error(args);
    }
};

State.prototype.logArgumentsFatal = function (args, spanGUID, echo)  {
    if (!this.enabled) {
        return;
    }
    if (echo === undefined) {
        echo = this.logToStdio;
    }

    // Ensure args is a true Array, not an Arguments object
    args = Array.prototype.slice.call(args);
    this.logArgumentsWithSpanGUID(spanGUID, "F", true, args);

    if (echo) {
        this.logger.fatal(args);
    }
    this.processAbort();
};

State.prototype.logFormattedInfo = function(args, spanGUID, echo) {
    if (!this.enabled) {
        return;
    }
    throw new Error("NOT_YET_IMPLEMENTED");
};

State.prototype.logFormattedWarn = function(args, spanGUID, echo) {
    if (!this.enabled) {
        return;
    }
    throw new Error("NOT_YET_IMPLEMENTED");
};
State.prototype.logFormattedError = function(args, spanGUID, echo) {
    if (!this.enabled) {
        return;
    }
    throw new Error("NOT_YET_IMPLEMENTED");
};
State.prototype.logFormattedFatal = function(args, spanGUID) {
    if (!this.enabled) {
        return;
    }
    throw new Error("NOT_YET_IMPLEMENTED");
    //this.processAbort();
};

// Javascript doesn't really have a very solid standard on exception objects.
// The code below tries to extract as much information as possible based
// on the common cases of what information may be available.
//
State.prototype.logException = function (e, spanGUID) {
    if (!this.enabled) {
        return;
    }
    if (this.cruntimeActive) {
        return;
    }
    this.cruntimeActive++;

    var stackFrames = [];
    var lineNumber;
    var filename;

    // Attempt to extract the call stack from the string (correct for
    // at least Chrome 40, Node.js v0.12).  Note: hooking into V8's
    // prepareCallStack is a more direct way to get this information but
    // involves overrriding default behaviors of V8-only APIs - may want
    // to do that eventually, but for now simple string parsing is used.
    // http://stackoverflow.com/questions/11386492/accessing-line-number-in-v8-javascript-chrome-node-js
    //
    if (typeof e.stack === "string") {
        stackFrames = e.stack.split("\n");

        // Assume the string has the form below and try to extract info:
        //      Error: This is an error
        //          at Context.<anonymous> (/.../test/shared_unittests.js:202:30)
        //          ...
        if (stackFrames.length >= 2) {
            var top = stackFrames[1];
            var m;
            if (top.match(/^\s+at\s/) && (m = top.match(/\((.+):([0-9]+):([0-9]+)\)$/))) {
                filename = m[1];
                try {
                    lineNumber = parseInt(m[2]);
                } catch (ignored) {
                }
            }
        }
    }


    // Be as specific as we can for the standard exception types:
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error
    //
    // This might be redundant as to what toString() will produce, but
    // that is unclear as what toString() produces is not standardized.
    var exceptionType = "Exception";
    if (e instanceof EvalError) {
        exceptionType = "EvalError";
    } else if (e instanceof RangeError) {
        exceptionType = "RangeError";
    } else if (e instanceof ReferenceError) {
        exceptionType = "ReferenceError";
    } else if (e instanceof SyntaxError) {
        exceptionType = "SyntaxError";
    } else if (e instanceof TypeError) {
        exceptionType = "TypeError";
    } else if (e instanceof URIError) {
        exceptionType = "URIError";
    } else if (e instanceof Error) {
        exceptionType = "Error";
    }

    this.rawLogRecord({
        span_guid       : spanGUID,       // May be undefined
        message         : e.toString(),
        error_flag      : true,
        level           : "E",
        filename        : filename,       // May be undefined
        line_number     : lineNumber,     // May be undefined
        payload         : {
            exceptionType : exceptionType,
        },
        stack_frames    : stackFrames,
    });

    this.cruntimeActive--;
};

// Create a detailed log record directly
State.prototype.logRecord = function(fields) {
    if (!this.enabled) {
        return;
    }
    return this.rawLogRecord(fields);
};

//===========================================================================//
// Events
//===========================================================================//

// Note: four arguments are always expected, but everything but "name" is
// allowed to be set to undefined.
//
State.prototype.logEventWithGUID = function(name, message, payload, spanGUID) {
    if (!this.enabled) {
        return;
    }

    this.rawLogRecord({
        stable_name     : name,
        message         : message,
        filename        : this.defaultLogFilename(),
        payload         : payload,
        span_guid       : spanGUID,
    });
};

// Valid call signatures:
//
// event(name)
// event(name, message)
// event(name, payload)
// event(name, message, payload)
//
State.prototype.logEvent = function(name, message, payload) {
    // The two-argument call signature is the only case that requires
    // parameter shuffling
    if (arguments.length === 2 && typeof message === "object") {
        payload = message;
        message = undefined;
    }
    return this.logEventWithGUID(name, message, payload, undefined);
};

State.prototype.eventWrap = function(name, f) {
    // We *don't* check this.enabled on the outer wrapper. The enabled setting
    // is potentially togglable at runtime. Conditionally creating the wrapper
    // would be very confusing as later re-enabling the cruntime would not
    // retroactively convert the input function into a wrapper equivalent.
    var self = this;
    return function() {
        if (this.enabled) {
            self.rawLogRecord({
                stable_name : name,
                filename    : self.defaultLogFilename(),
                payload     : {
                    arguments    : arguments,
                    stack_frames : platform.stackTrace(),
                },
            });
        }
        return f.apply(this, arguments);
    };
};

//===========================================================================//
// Spans
//===========================================================================//

State.prototype.setActiveSpanName = function(name) {
    if (!this.enabled) {
        return;
    }
    var span = this.getActiveSpan();
    if (!span) {
        // It's not an error to call this when there's no active span
        return;
    }
    span.name(name);
};

// Pretty simple: bank on the uniqueness of the "__cr_span" property
// name and ensure we use that property name consistently in the
// auto-instrumentation.
State.prototype.spanForObject = function (obj, spanHandle) {

    if (!this.enabled) {
        return span_handle.getNoOpHandle();
    }

    if (typeof obj !== "object") {
        return spanHandle || this.api;
    }

    // Handle the setter case
    if (arguments.length == 2) {

        if (span_handle.isSpanHandle(spanHandle)) {
            obj.__cr_span = spanHandle;
        }
        return spanHandle;

    } else {

        // Does this object have an explciit span handle?
        var handle = obj.__cr_span;
        if (span_handle.isSpanHandle(handle)) {
            return handle;
        }

        // Is there an active span handle?
        // Note: there are cases where the active span handle is not
        // necessarily what the customer would want. It is being assumed
        // it will be correct "often enough" that this is helpful behavior.
        var lastIndex = this.activeSpanOrJoinIDsStack.length - 1;
        if (lastIndex >= 0) {
            var spanOrJoinIds = this.activeSpanOrJoinIDsStack[lastIndex];
            if (span_handle.isSpanHandle(spanOrJoinIds)) {
                return spanOrJoinIds;
            }
        }
        if (this.verbose) {
            this.api.warn("No span handle for:", obj);
        }
        return span_handle.getNoOpHandle();
    }
};

// Sets the given span as active for the duration of the callthrough (then
// pops it from the active stack on call termination).
//
// This means that any calls further up in the callstack can access
// this span via a call to getActiveJoinIds() in order to inherit the join IDs.
//
// Note: a span being removed from the active span stack is not the same as
// end()-ing a span.  The caller is still responsible for calling end() on
// the given span.
//
// Note: `span` *is* allowed to be null to simplify things for the caller.
//
// Note/TODO: this really only active span stack really only works for
// synchronous calls or else the push() / pop() potentially becomes unbalanced.
// Being applicable only to synchronous functions is a serious limitation in
// JS.  It's worth considering if a sufficiently performant "set" of active
// spans could be maintained instead -- something that doesn't necessarily
// have to be push / popped in order, but does maintain knowledge of the
// most recent span.
//
State.prototype.setActiveSpanOrJoinIds = function(spanOrJoinIds, self, args, callthrough) {
    if (!this.enabled) {
        return callthrough.apply(self, args);
    }

    if (spanOrJoinIds) {
       this.activeSpanOrJoinIDsStack.push(spanOrJoinIds);
    }

    var ret;
    try {
        ret = callthrough.apply(self, args);
    } catch (e) {
        this.logException(e);
        throw e;
    } finally {
        if (spanOrJoinIds) {
            this.activeSpanOrJoinIDsStack.pop();
        }
    }
    return ret;
};

State.prototype.setActiveJoinIds = function(joinIds, callthrough) {

    if (this.verbose) {
        var filteredStack = this.platform.stackTrace(0, false);
        this.logRecord({
            stable_name : "cr/set_active_join_ids",
            message : JSON.stringify(joinIds) + " " + filteredStack[0],
            payload : {
                join_ids        : joinIds,
                active_join_ids : this.getActiveJoinIdsStack(),
            },
            stack_frames : this.platform.stackTrace(0, true),
        });
    }

    return this.setActiveSpanOrJoinIds(joinIds, null, [], callthrough);
};

State.prototype.setActiveSpan = function(span, self, args, callthrough) {

    if (this.verbose) {
        var filteredStack = this.platform.stackTrace(0, false);
        this.logRecord({
            stable_name : "cr/set_active_span",
            message : span.name() + " " + JSON.stringify(span.joinIds()) + " " + filteredStack[0],
            payload : {
                span_name       : span.name(),
                span_guid       : span.guid(),
                join_ids        : span.joinIds(),
                active_join_ids : this.getActiveJoinIdsStack(),
            },
            stack_frames : this.platform.stackTrace(0, true),
        });
    }

    return this.setActiveSpanOrJoinIds(span, self, args, callthrough);
};

State.prototype.getActiveSpan = function() {
    if (!this.enabled) {
        return null;
    }
    for (var i = this.activeSpanOrJoinIDsStack.length - 1; i >= 0; i--) {
        var span = this.activeSpanOrJoinIDsStack[i];
        if (span_handle.isSpanHandle(span) && span.valid()) {
            return span;
        }
    }
    return null;
};

// Return the active join IDs.
//
State.prototype.getActiveJoinIds = function() {
    if (!this.enabled) {
        return {};
    }

    for (var i = this.activeSpanOrJoinIDsStack.length - 1; i >= 0; i--) {
        var span = this.activeSpanOrJoinIDsStack[i];

        // SpanHandle objects need to be valid(); otherwise, assumed it's a
        // key-value joinID map and return it. It is possible for spans to
        // be ended before it is popped from the active stack and it produces
        // more accurate traces to account for that.  Also, checking here is
        // incrementally easier than having spans check
        if (!span_handle.isSpanHandle(span)) {
            return span;
        } else if (span.valid()) {
            return span.joinIds();
        }
    }
    return {};
};

// Internal utility: not intended to be exposed to the client API.
State.prototype.getActiveJoinIdsStack = function() {
    if (!this.enabled) {
        return [];
    }
    var stack = [];
    for (var i = 0; i < this.activeSpanOrJoinIDsStack.length; i++) {
        var span = this.activeSpanOrJoinIDsStack[i];
        if (!span_handle.isSpanHandle(span)) {
            stack.push(span);
        } else if (span.valid()) {
            stack.push(span.joinIds());
        }
    }
    return stack;
};

// Create the span record
State.prototype.rawSpanBegin = function (name, joinIdKeyValues) {
    if (!this.enabled) {
        return null;
    }

    var record = pool.spanRecords.acquire();
    record.span_guid     = platform.generateGUID();
    record.runtime_guid  = this.runtime.guid;
    record.span_name     = name;
    record.oldest_micros = this.nowMicros();
    record.youngest_micros = null;
    record.join_ids      = [];
    record.attributes    = [];

    this.mergeJoinIdMapIntoSpanRecord(record, joinIdKeyValues);

    if (this.verbose) {
        this.logRecord({
            stable_name : "cr/span_begin",
            message     : name,
            payload     : {
                name              : name,
                guid              : record.span_guid,
                explicit_join_ids : joinIdKeyValues,
                merged_join_ids   : record.join_ids,
                join_id_stack     : this.getActiveJoinIdsStack(),
            },
            stack_frames : this.platform.stackTrace(0, true),
        });
    }
    return record;
};

// Merge a JS map of key-value pairs into the span record's thrift join ids
// structures.  Use this method rather than doing this manually to ensure the
// object pooling is utilized.
//
State.prototype.mergeJoinIdMapIntoSpanRecord = function(spanRecord, joinIdMap) {
    if (!joinIdMap) {
        return;
    }

    // Scan for duplicate keys that need to be replaced.  This is a little awkward
    // since the thrift structure is a list of pairs, even though conceptually it
    // is a map with unique keys.
    var replacedKeys = {};
    for (var i = 0; i < spanRecord.join_ids.length; i++) {
        var existingKey = spanRecord.join_ids[i].TraceKey;
        if (!(existingKey in joinIdMap)) {
            continue;
        }
        var newValue = joinIdMap[existingKey];
        replacedKeys[existingKey] = true;
        spanRecord.join_ids[i].Value = String(newValue);
    }

    // Append any new keys
    for (var key in joinIdMap) {
        if (replacedKeys[key] === undefined) {
            var value = joinIdMap[key];
            if (value === undefined) {
                continue;
            }
            var joinId = pool.traceJoinIds.acquire();
            joinId.TraceKey = String(key);
            joinId.Value = String(value);
            spanRecord.join_ids.push(joinId);
        }
    }
};

// Returns null if the value should be skipped, otherwise a valid
// (but potentially empty) string.
function convertAttributeValue(value) {
    if (value === undefined || value === null) {
        return null;
    }
    var valueType = typeof value;
    if (valueType === "object") {
        try {
            value = JSON.stringify(value);
        } catch (e) {
            // Use the default conversion if JSON encoding fails
        }
    }
    return "" + value;
}

State.prototype.mergeAttributesIntoSpanRecord = function(spanRecord, attrMap) {
    if (!attrMap) {
        return;
    }

    // Scan for duplicate keys that need to be replaced.  This is a little awkward
    // since the thrift structure is a list of pairs, even though conceptually it
    // is a map with unique keys.
    var replacedKeys = {};
    for (var i = 0; i < spanRecord.attributes.length; i++) {
        var existingKey = spanRecord.attributes[i].Key;
        if (!(existingKey in attrMap)) {
            continue;
        }
        var newValue = convertAttributeValue(attrMap[existingKey]);
        if (newValue === null) {
            continue;
        }
        replacedKeys[existingKey] = true;
        spanRecord.attributes[i].Value = String(newValue);
    }

    // Append any new keys
    for (var key in attrMap) {
        if (key === null || key === undefined) {
            continue;
        }
        if (replacedKeys[key] === undefined) {
            var value = convertAttributeValue(attrMap[key]);
            if (value === null) {
                continue;
            }
            var pair = pool.keyValue.acquire();
            pair.Key = String(key);
            pair.Value = value;
            spanRecord.attributes.push(pair);
        }
    }
};

// Create the "handle" object for a given span record.
State.prototype.createSpanHandle = function (spanRecord) {
    return span_handle.acquire(this, spanRecord);
};

// Start a new span and return a handle interface for controlling the span.
//
// Valid signatures:
//
// var handle = cr.span("my_span_name");
// var handle = cr.span("my_span_name", { my_key : "my_value" });
// var result = cr.span("my_span_name", { my_key : "my_value" }, function(handle) {
//      return 42.0;
// });
//
// The third signature will automatically set the span as active for the
// duration of the callthrough; it does *not*, however, automatically call
// end() on the span.
//
// The newly created span with inherit any globally set join IDs as well as
// the join IDs of the nearest active span.
//
State.prototype.span = function (name, joinIdKeyValues, callthrough) {
    if (arguments.length === 2 && typeof joinIdKeyValues === "function") {
        callthrough = joinIdKeyValues;
        joinIdKeyValues = null;
    }

    var handle;

    if (!this.enabled) {
        handle = span_handle.getNoOpHandle();
        if (callthrough) {
            return callthrough(handle);
        }
        return handle;
    }

    // Always inherit the join IDs from the top-most active span.
    //
    // Note: merge into the activeSpan joinIds object to avoid modifying
    // the incoming argument -- less risk of unintended side-effects.
    var activeJoinIds = this.getActiveJoinIds();
    for (var key in joinIdKeyValues) {
        activeJoinIds[key] = joinIdKeyValues[key];
    }
    joinIdKeyValues = activeJoinIds;

    var record = this.rawSpanBegin(name, joinIdKeyValues);
    handle = this.createSpanHandle(record);
    if (callthrough) {
        return this.setActiveSpan(handle, null, [ handle ], callthrough);
    } else {
        return handle;
    }
};

// Wrap a synchronous function inside a span and return the wrapper function.
// A map of join ids can optionally be passed in as a second argument.  Note
// this will not work as expected with asynchronous functions that signal
// completion via an promise, event, or callback.
//
// function add(x, y) { return x + y; }
//
// var add = cr.spanWrap("add", add);
// var z = add(1, 2);
//
State.prototype.spanWrap = function (name, joinIdKeyValues, f) {
    var self = this;

    if (arguments.length == 2) {
        f = joinIdKeyValues;
        joinIdKeyValues = {};
    }

    return function() {
        var handle = self.span(name, joinIdKeyValues);
        var r;
        try {
            r = f.apply(this, arguments);
        } catch (e) {
            self.logException(e);
            throw e;
        } finally {
            handle.end();
        }
        return r;
    };
};

// Wrap a block of synchronous code inside a span.  The code will be executed
// immediately.  This is an alternative to explicitly surrounding the block
// of code with span creation and end() call that will automatically catch
// and log exceptions before rethrowing them.
//
// var z = 0;
// cr.spanSection("inner_computation", function() {
//      z = 4 * 2;
// });
//
State.prototype.spanSection = function (name, joinIdKeyValues, f) {
    if (arguments.length === 2) {
        f = joinIdKeyValues;
        joinIdKeyValues = {};
    }

    var handle = this.span(name, joinIdKeyValues);
    var r;
    try {
        r = f();
    } catch (e) {
        this.logException(e);
        throw e;
    } finally {
        handle.end();
    }
    return r;
};

// A manually created span.
State.prototype.spanManual = function (name, oldestMicros, youngestMicros) {
    if (!this.enabled) {
        return;
    }
    var record = this.rawSpanBegin(name);
    record.oldest_micros = oldestMicros;
    record.youngest_micros = youngestMicros;
    this.pushSpanRecord(record);
    return record.span_guid;
};

State.prototype.spanApplyImp = function (operation, joinIds, async, f, selfArg, callArgs) {

    var handle = this.span(operation, joinIds);

    // Assume the convention that the last argument is the "done" / "next" callback.
    if (async) {
        var done = callArgs[callArgs.length - 1];

        if (typeof done !== "function") {
            throw new Error("Invalid argument: expected last argument to be of type function");
        }

        callArgs[callArgs.length - 1] = function (err) {
            if (err) {
                handle.error("Error passed to callback", {
                    error : err,
                });
            }
            handle.log("Callback invoked", {
                "error"     : err,
                "arguments" : Array.prototype.slice.call(arguments),
            });

            handle.end();

            return done.apply(this, arguments);
        };
    } else {
        this.activeSpanOrJoinIDsStack.push(handle);
    }


    var ret;
    try {
        handle.log("Call invoked", {
            "this"      : selfArg,
            "arguments" : callArgs,
        });

        ret = f.apply(selfArg, callArgs);

    } catch (e) {
        this.logException(e);
        throw e;
    } finally {
        if (!async) {
            handle.end();
            this.activeSpanOrJoinIDsStack.pop();
        }
    }
    handle.log("Call returned", {
        "value" : ret,
    });
    return ret;
};

State.prototype.callSync = function (operation, joinIds, f, selfArg) {
    // Normalize arguments
    var callArgs;
    if (arguments.length < 2) {
        throw new Error("Invalid number of arguments");
    }
    if (typeof joinIds === "function") {
        callArgs = Array.prototype.slice.call(arguments, 3);
        selfArg = f;
        f = joinIds;
        joinIds = {};
    } else {
        callArgs = Array.prototype.slice.call(arguments, 4);
    }
    return this.spanApplyImp(operation, joinIds, false, f, selfArg, callArgs);
};

State.prototype.applySync = function (operation, joinIds, f, selfArg, callArgs) {
    // Normalize arguments
    if (arguments.length < 2) {
        throw new Error("Invalid number of arguments");
    }
    if (typeof joinIds === "function") {
        callArgs = selfArg;
        selfArg = f;
        f = joinIds;
        joinIds = {};
    }
    return this.spanApplyImp(operation, joinIds, false, f, selfArg, callArgs);
};

State.prototype.callAsync = function (operation, joinIds, f, selfArg) {
    // Normalize arguments
    var callArgs;
    if (arguments.length < 2) {
        throw new Error("Invalid number of arguments");
    }
    if (typeof joinIds === "function") {
        callArgs = Array.prototype.slice.call(arguments, 3);
        selfArg = f;
        f = joinIds;
        joinIds = {};
    } else {
        callArgs = Array.prototype.slice.call(arguments, 4);
    }
    return this.spanApplyImp(operation, joinIds, true, f, selfArg, callArgs);
};

State.prototype.applyAsync = function (operation, joinIds, f, selfArg, callArgs) {
    // Normalize arguments
    if (arguments.length < 2) {
        throw new Error("Invalid number of arguments");
    }
    if (typeof joinIds === "function") {
        callArgs = selfArg;
        selfArg = f;
        f = joinIds;
        joinIds = {};
    }
    return this.spanApplyImp(operation, joinIds, true, f, selfArg, callArgs);
};

// Add a span record to the internal buffer
State.prototype.pushSpanRecord = function(record) {
    // Merge in any global join ids -- do this at the end of the span as
    // this allows some spans that may have been automatically created
    // by the cruntime before the user set the global join ids to still
    // capture those global join ids.
    this.mergeJoinIdMapIntoSpanRecord(record, this.joinIds);

    // TODO: the Thrift fields on the record should be checked here to be
    // sure they're the right data type or else thrift will throw an
    // exception.

    if (this.spans.length >= this.bufferMaxSpanRecords) {
        // Treat this like a random sampling and replace a record at random.
        // This is not truly random in mathematical sense for a number of reasons,
        // but the assumption this is provides more useful information than
        // dropping all records once the max is hit.
        var index = Math.floor(this.spans.length * Math.random());
        releaseSpanRecord(this.spans[index]);
        this.spans[index] = record;
        this.counters.dropped_spans++;
    } else {
        this.spans.push(record);
    }
};

//===========================================================================//
// Stats
//===========================================================================//

// Primarily intended for debugging
State.prototype.reportBufferStats = function() {

    var runtimeAttrs = {};
    if (this.runtime.attrs) {
        for (var i = 0; i < this.runtime.attrs.length; i++) {
            var attr = this.runtime.attrs[i];
            runtimeAttrs[attr.Key] = attr.Value;
        }
    }

    return {
        // Basic configuration
        service_host        : this.serviceHost,
        service_port        : this.servicePort,
        runtime             : this.runtime,
        auth                : this.auth,

        // Runtime attributes
        runtime_attributes  : runtimeAttrs,
        statistics          : this.stats,

        // Current buffer stats
        queued_logs         : this.logs.length,
        queued_spans        : this.spans.length,
        max_log_records     : this.bufferMaxLogRecords,
        max_span_records    : this.bufferMaxSpanRecords,

        // Memory pooling stats
        log_records_allocated  : pool.logRecords.allocationCount,
        log_records_acquired   : pool.logRecords.acquireCount,
        log_records_released   : pool.logRecords.releaseCount,
        log_records_active     : pool.logRecords.allocationCount - pool.logRecords.freeList.length,

        span_records_allocated : pool.spanRecords.allocationCount,
        span_records_acquired  : pool.spanRecords.acquireCount,
        span_records_released  : pool.spanRecords.releaseCount,
        span_records_active    : pool.spanRecords.allocationCount - pool.spanRecords.freeList.length,

        join_ids_allocated     : pool.traceJoinIds.allocationCount,
        join_ids_acquired      : pool.traceJoinIds.acquireCount,
        join_ids_released      : pool.traceJoinIds.releaseCount,
        join_ids_active        : pool.traceJoinIds.allocationCount - pool.traceJoinIds.freeList.length,
    };
};

//===========================================================================//
// Exports
//===========================================================================//

module.exports = State;

},{"./clock_state.js":12,"./object_pool.js":13,"./span_handle.js":14,"./timestamp_samples.js":16,"node/packages/rl-eventemitter":17,"node/packages/rl-inspectable-object":18,"node/packages/rl-scrubber":20}],16:[function(require,module,exports){
// A fixed size buffer storing sample counts over a set of time ranges.
//
// This is specifically being used for record approximately how many log/span
// records were discarded over a given period of time.  This provides the
// server with some notion of what was *not* reported without consuming a
// lot of bandwidth.
//
// Arguments:
//
// maxBuckets   -- the maximum number of buckets to use regardless of total
//                 sample count
// granularity  -- the bucket size expressed as base-10 exponent, i.e. assuming
//                 microsecond samples, the initial granularity values map as:
//                 0 => microseconds
//                 3 => milliseconds
//                 6 => seconds
//
// The implementation itself has two primary objectives:
//
// (1) Use a fixed maximum amount of memory regardless of # of samples added
//     to the buffer.
// (2) Keep the implementation very simple so it's not adding any source of
//     code complexity and/or defects.
//
function TimestampSamples(maxBuckets, granularity) {
    this.maxBuckets   = maxBuckets;
    this.minMagnitude = Math.pow(10, granularity);

    // Note: this will initialize the rest of the object fields
    this.clear();
}

TimestampSamples.prototype.clear = function () {
    this.buckets     = {};
    this.bucketCount = 0;
    this.sampleCount = 0;
    this.magnitude   = this.minMagnitude;
};

TimestampSamples.prototype.add = function (timestamp) {
    var key = Math.floor(timestamp / this.magnitude);

    // There's an existing bucket for this sample, just add to
    // the total.
    if (this.buckets[key]) {
        this.buckets[key]++;
        this.sampleCount++;
        return;
    }

    // There's no existing bucket, but there's still capacity for
    // a new bucket to be created
    //
    // The min for a bucket is implicitly (key * magnitude).
    // The max for a bucket is implicitly (key * magnitude - 1).
    if (this.bucketCount < this.maxBuckets) {
        this.buckets[key] = 1;
        this.bucketCount++;
        this.sampleCount++;
        return;
    }

    //
    // Redistribute the buckets at 10x less granularity
    // then add().
    //
    var newBuckets = {};
    var newBucketCount = 0;
    for (var bucketKey in this.buckets) {
        var oldBucket = this.buckets[bucketKey];
        var newKey = Math.floor(bucketKey / 10);

        if (newBuckets[newKey]) {
            newBuckets[newKey] += oldBucket;
        } else {
            newBuckets[newKey] = oldBucket;
            newBucketCount ++;
        }
    }
    this.buckets = newBuckets;
    this.bucketCount = newBucketCount;
    this.magnitude *= 10;

    this.add(timestamp);
};

TimestampSamples.prototype.bucketAt = function(timestamp) {
    var key = Math.floor(timestamp / this.magnitude);
    var bucket = this.buckets[key];
    return {
        min   : key * this.magnitude,
        max   : key * this.magnitude - 1,
        count : bucket || 0,
    };
};

module.exports = TimestampSamples;

},{}],17:[function(require,module,exports){
//=============================================================================//
// EventEmitter
//
// Simple subset of http://nodejs.org/api/events.html
//=============================================================================//

function EventEmitter() {
    this._listeners = {};
}

EventEmitter.prototype.on = function (evt, listener) {
    console.assert(typeof listener === "function", "typeof listener incorrect: " + typeof listener);
    var arr = this._listeners[evt];
    if (!arr) {
        arr = this._listeners[evt] = [];
    }
    arr.push(listener);
};

EventEmitter.prototype.removeListener = function (evt, listener) {
    var updated = [];
    var existing = this._listeners[evt];
    if (!existing) {
        return;
    }
    for (var i = 0; i < existing.length; i++) {
        if (existing[i] != listener) {
            updated.push(existing[i]);
        }
    }
    this._listeners[evt] = updated;
};

EventEmitter.prototype.once = function (evt, listener) {
    var self = this;
    var wrapper = function() {
        listener.apply(self, arguments);
        self.removeListener(wrapper);
    };
    self.on(evt, wrapper);
};

EventEmitter.prototype.emit = function (evt) {
    var listeners = this._listeners[evt];
    if (!listeners) {
        return;
    }

    var args = Array.prototype.slice.call(arguments, 1);
    var list = this._listeners[evt];
    for (var i = 0; i < list.length; i++) {
        list[i].apply(this, args);
    }
};

EventEmitter.prototype.listeners = function (evt) {
    return this._listeners[evt];
};

EventEmitter.listenerCount = function(emitter, evt) {
    if (!emitter) {
        return 0;
    }
    var evtListeners = emitter.listeners(evt);
    if (!evtListeners) {
        return 0;
    }
    return evtListeners.length;
};

module.exports = EventEmitter;

},{}],18:[function(require,module,exports){
module.exports = require("./src/process.js");

},{"./src/process.js":19}],19:[function(require,module,exports){
//===========================================================================//
// Polyfill
//===========================================================================//

var isArray = (function() {
    if (Array.isArray) {
        return function(obj) {
            return Array.isArray(obj);
        }
    } else {
        return function(obj) {
            return Object.prototype.toString.call(obj) === "[object Array]";
        };
    }
})();

function isRegExp (obj) {
    return Object.prototype.toString.call(obj) === "[object RegExp]";
}

//===========================================================================//
// Processor
//===========================================================================//

function Processor(opts) {
    this.opts = opts || {};
    this.valueCount = 0;
    this.seen = [];

    this.limitValueCount    = this.opts.limit_value_count || 64;
    this.limitStringLength  = this.opts.limit_string_length || 512;
    this.limitArrayLength   = this.opts.limit_array_length || 24;
    this.arrayPeekLength    = this.opts.array_peek_length || 5;
}

Processor.prototype.process = function(value, opts) {

    // Reset the object state
    Processor.call(this, opts);

    var pair = this.processFastPath(value);
    if (pair.ok) {
        return pair.result;
    } else {
        return this.processSlowPath(value);
    }
};

// Check the is the object is "simple" enough to just rely on
// JSON.stringify. For brevity, the return value is the field
// count -- which will be greater than limit if it is not a
// simple value.
Processor.prototype.isSimple = function(value) {
    var self         = this;
    var limit        = self.limitValueCount;
    var exceedsLimit = limit + 1;
    var seen         = [];

    return isSimple(0, value, limit);

    // Recursive worker function
    function isSimple(count, value, limit) {

        var type = typeof value;

        // First check for circular references
        if (type === "object") {
            if (seen.indexOf(value) !== -1) {
                return exceedsLimit;
            }
            seen.push(value);
        }

        if (type === "string") {

            if (value.length > self.limitStringLength) {
                return exceedsLimit;
            }
            return count + 1;

        } else if (type === "number") {

            if (value === Infinity) {
                return exceedsLimit;
            } else if (value === -Infinity) {
                return exceedsLimit;
            } else if (!(value === value)) {  // <-- NaN returns false for any comparison
                return exceedsLimit;
            } else {
                return count + 1;
            }

        } else if (type === "function") {

            return exceedsLimit;

        } else if (type !== "object") {

            return count + 1;

        } else if (isArray(value)) {

            if (count + value.length > limit) {
                return exceedsLimit;
            }

            var keyCount = 0;
            for (var key in value) {
                keyCount++;
            }
            if (keyCount !== value.length) {
                return exceedsLimit;
            }

            for (var i = 0; i < value.length; i++) {
                count += isSimple(count, value[i], limit);
                if (count > limit) {
                    return exceedsLimit;
                }
            }
            return count;

        } else {

            var props = 0;
            for (var key in value) {
                if (value.hasOwnProperty(key)) {
                    props++;
                }
            }
            if (count + props > limit) {
                return exceedsLimit;
            }
            for (var key in value) {
                if (!value.hasOwnProperty(key)) {
                    continue;
                }
                count = isSimple(count, value[key], limit);
                if (count + props > limit) {
                    return exceedsLimit;
                }
            }
            return count;
        }
    }
}

// We make some unverified assumptions here, namely...
//
// (1) many user payloads will be small, simple, and directly
// JSON.stringify-able.
//
// (2) JSON.stringify() is implemented natively by the JS platform and will
// thus be efficient in terms of raw performance and, perhaps more
// importantly, minimal GC heap thrashing with temporaries.
//
// (3) Efficiency is more important than exact size constraints in the
// value conversion.
//
// Thus we assume it's overally quicker to always try stringifying the
// object -- and fallback to our more involved, processing, GC
// thrashing heavy simplficiation algorithm if and only if that native
// stringification failed.
Processor.prototype.processFastPath = function(value) {
    // Check if the object is clearly too large before attempting the native
    // stringification.
    if (this.isSimple(value) > this.limitValueCount) {
        return { ok : false };
    }

    var result;
    try {
        // Use a JSON round-trip to implicitly clone the object
        var json = JSON.stringify(value);
        return { ok : true, result : JSON.parse(json) };
    } catch (e) {
        return { ok : false };
    }
};

Processor.prototype.processSlowPath = function(value) {
    return this.postProcessValue(this.processValue(value));
};

Processor.prototype.truncateString = function(value) {
    var limit = this.limitStringLength;
    if (value.length > limit) {
        value = value.slice(0, limit - 1) + "";
    }
    return value;
};

// Do a breadth-first expansion of the processed values.  The incoming value
// is always going to be either a primitive or a function to expand an
// object into it's primitives (and possibly its corresponding nested expansion
// functions).
Processor.prototype.postProcessValue = function(value) {

    // TODO: make this configurable
    var valueLimit = this.limitValueCount;
    var self = this;

    var root = {
        value : value,
    };
    var indices = [ "value" ];
    var parents = [ root ];

    // The value count is increment on addition to the queue
    this.valueCount++;

    while (parents.length) {
        var parent = parents.shift();
        var index  = indices.shift();
        var value  = parent[index];

        // If this is a non-primitive value expand it out
        if (typeof value === "function") {
            parent[index] = value = value();
        }

        if (typeof value === "object") {
            if (isArray(value)) {
                // Need to reset the array here since we still have the reference
                // to the parent object here.
                if (this.valueCount + value.length >= valueLimit) {
                    parent[index] = value = ["<truncated>"];
                    parents.push(value);
                    indices.push(0);
                } else {
                    for (var i = 0; i < value.length; i++) {
                        enqueue(i, value, true);
                    }
                }

            } else {
                // The object case is easier as we can delete the over-limit
                // fields in the enqueue function.
                for (var key in value) {
                    if (!value.hasOwnProperty(key)) {
                        continue;
                    }
                    enqueue(key, value, true);
                }
            }
        }
    }

    function enqueue (key, value, isObject) {
        if (self.valueCount < valueLimit) {
            parents.push(value);
            indices.push(key);
            self.valueCount++;
        } else {
            if (isObject) {
                delete value[key];
            }
        }

        if (self.valueCount === valueLimit) {
            parents.push(value);
            indices.push("");
            value[""] = "<truncated>";
            self.valueCount++;
        }
    }

    return root.value;
};


// Reduces a given JS value such that...
//
// If the value is a primitive, a value to use for the JSON payload is
// return.
//
// Else, return a function to expand the object one-level into a set of
// payloads primitives and futher expansion functions (for use in a
// breadth-first expansion).
//
// TODO: Node.js buffers for the node side of things
//
Processor.prototype.processValue = function(value) {

    var self = this;

    switch (typeof value) {

    case "undefined":
        return value;

    case "boolean":
        return value;

    case "string":
        return this.truncateString(value);

    case "number":
        if (value === Infinity) {
            return "<infinity>";
        } else if (value === -Infinity) {
            return "<-infinity>";
        } else if (!(value === value)) {  // <-- NaN returns false for any comparison
            return "<NaN>";
        } else {
            return value;
        }

    case "object":

        if (value === null) {

            return value;

        } else if (isRegExp(value)) {

            value = this.truncateString(value.toString());
            return "<regexp: " + value + ">";

        } else if (this.seen.indexOf(value) !== -1) {

            return "<circular>";
        }

        // At this point, this is not a primitive object -- record that we've
        // seen it to avoid circular references.
        this.seen.push(value);

        if (isArray(value)) {

            // TODO: make this limit an option
            if (value.length > this.limitArrayLength) {

                return function() {
                    // Note: slice() clamps out of range indexing, so there's no need to worry about
                    // arrayPeekLength and limitArrayLength being set irrationally.
                    return {
                        "$type" : "<truncated_array>",
                        length  : value.length,
                        head    : self.processValue(value.slice(0, self.arrayPeekLength)),
                        tail    : self.processValue(value.slice(value.length - self.arrayPeekLength)),
                    };
                }

            } else {

                return function() {

                    // Handle the unusual case of arrays that also have fields
                    // (e.g. jQuery objects).  Normalize these to an associative
                    // array with string keys only.
                    //
                    // Note: there doesn't seem to be a clean, cross-JS-variations way to detect
                    // these complex objects definitively.  Here the assumption made is if the object
                    // has a "length" property and the number of keys is equal to that length AND
                    // it has already passed the isArray() test, then it's most likely a normal
                    // array.  In the unlikely case that the object has a length properties that's
                    // equal to the number of keys BUT also has non-numeric keys, those non-numeric
                    // keys won't end up in the JSON: so be it.
                    //
                    var keyCount = 0;
                    for (var k in value) {
                        keyCount++;
                    }
                    if (keyCount == value.length) {
                        var a = new Array(value.length);
                        for (var i = 0; i < value.length; i++) {
                            a[i] = self.processValue(value[i]);
                        }
                        return a;
                    } else {
                        return self.cloneKeyValues(value);
                    }
                };
            }

        } else {

            return function() {
                return self.cloneKeyValues(value);
            };
        }

    case "function":
        return "<function>";

    // ECMAScript 6
    case "symbol":
        return "<symbol>";

    }
};

// Duplicate all the key-value pairs in an object, respecting the current
// processor options.
Processor.prototype.cloneKeyValues = function (value) {
    var obj = {};
    for (var key in value) {
        var elemType = (typeof value[key]);
        if (this.opts.exclude_functions && elemType === "function") {
            continue;
        }
        obj[key] = this.processValue(value[key]);
    }
    return obj;
}

// Use a global singleton to reduce the GC impact.
var gProcessor = new Processor();

//===========================================================================//
// Exports
//===========================================================================//

// Given an arbitary JS value return a new JS value that can stringified with
// JSON.stringify().
//
// - Circular references are removed.
// - The resulting object does not need to support round-tripping
// - Total size and max depth can be limited
//
module.exports = function(value, opts) {
    return gProcessor.process(value, opts);
};

},{}],20:[function(require,module,exports){
module.exports = require("./src/scrubber.js");

},{"./src/scrubber.js":23}],21:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var deepClone, deepDelete, deepExtend, deepFromFlat, deepKeys, deepMapValues, isPlainObject, mapKeys, mapValues, _;

_ = require('underscore');

module.exports = {
  deepKeys: deepKeys = function(obj) {
    if (!isPlainObject(obj)) {
      throw new Error("deepKeys must be called on an object, not '" + obj + "'");
    }
    return _.flatten(_.map(obj, function(v, k) {
      if (isPlainObject(v) && !_.isEmpty(v)) {
        return _.map(deepKeys(v), function(subkey) {
          return "" + k + "." + subkey;
        });
      } else {
        return [k];
      }
    }));
  },
  deepClone: deepClone = function(object) {
    var type, _i, _len, _ref;
    if (object == null) {
      return object;
    }
    _ref = [Date, Number, String, Boolean];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      type = _ref[_i];
      if (object instanceof type) {
        return new type(object);
      }
    }
    if (_(object).isArray()) {
      return _(object).map(deepClone);
    }
    if (!_(object).isObject()) {
      return object;
    }
    if (object.nodeType && _(object.cloneNode).isFunction()) {
      return object.cloneNode(true);
    }
    if (object.constructor !== {}.constructor) {
      return object;
    }
    return mapValues(object, deepClone);
  },
  deepHas: function(obj, keys) {
    var helper;
    helper = function(obj, keys) {
      if ((keys.length === 0) || (!_.isObject(obj))) {
        return false;
      } else if (keys.length === 1) {
        return _.first(keys) in obj;
      } else {
        return helper(obj[_.first(keys)], _.rest(keys));
      }
    };
    return helper(obj, _.isArray(keys) ? keys : keys.split('.'));
  },
  deepOmit: function(obj, keys) {
    var deepOmitOne;
    if (!isPlainObject(obj)) {
      throw new Error("deepOmit must be called on an object, not '" + obj + "'");
    }
    deepOmitOne = function(obj, key) {
      var helper;
      helper = function(obj, key_arr) {
        switch (false) {
          case !_.isEmpty(key_arr):
            return obj;
          case key_arr.length !== 1:
            return _.omit(obj, _.first(key_arr));
          case !!isPlainObject(obj[_.first(key_arr)]):
            return obj;
          default:
            return _.extend({}, obj, _.object([_.first(key_arr)], [helper(obj[_.first(key_arr)], _.rest(key_arr))]));
        }
      };
      return helper(obj, key.split('.'));
    };
    return _.reduce(keys, deepOmitOne, obj);
  },
  deepPick: (function() {
    var deepGet;
    deepGet = function(obj, key) {
      var helper;
      helper = function(obj, key_arr) {
        if (key_arr.length === 1) {
          return obj != null ? obj[_.first(key_arr)] : void 0;
        } else {
          return helper(obj[_.first(key_arr)], _.rest(key_arr));
        }
      };
      return helper(obj, key.split('.'));
    };
    return function(obj, keys) {
      var flat_new_obj;
      if (!isPlainObject(obj)) {
        throw new Error("deepPick must be called on an object, not '" + obj + "'");
      }
      flat_new_obj = _.reduce(keys, function(new_obj, key) {
        var val;
        val = deepGet(obj, key);
        if (val !== void 0) {
          new_obj[key] = val;
        }
        return new_obj;
      }, {});
      return deepFromFlat(flat_new_obj);
    };
  })(),
  deepDelete: deepDelete = function(obj, key) {
    if ((key == null) || (obj == null)) {
      return;
    }
    if (!_(key).isArray()) {
      key = key.split('.');
    }
    if (key.length === 1) {
      delete obj[key];
      return;
    }
    return deepDelete(obj[key[0]], key.slice(1, key.length));
  },
  deepExtend: deepExtend = function(obj, ext, mutate) {
    return _.reduce(ext, function(acc, val, key) {
      acc[key] = (key in obj) && isPlainObject(obj[key]) && isPlainObject(val) ? deepExtend(obj[key], val) : val;
      return acc;
    }, mutate ? obj : _.clone(obj));
  },
  isPlainObject: isPlainObject = function(value) {
    return (value != null ? value.constructor : void 0) === {}.constructor;
  },
  deepToFlat: function(obj) {
    var recurse, res;
    res = {};
    recurse = function(obj, current) {
      var key, newKey, value, _results;
      _results = [];
      for (key in obj) {
        value = obj[key];
        newKey = (current ? current + "." + key : key);
        if (value && isPlainObject(value)) {
          _results.push(recurse(value, newKey));
        } else {
          _results.push(res[newKey] = value);
        }
      }
      return _results;
    };
    recurse(obj);
    return res;
  },
  deepFromFlat: deepFromFlat = function(o) {
    var k, key, oo, part, parts, t;
    oo = {};
    t = void 0;
    parts = void 0;
    part = void 0;
    for (k in o) {
      t = oo;
      parts = k.split(".");
      key = parts.pop();
      while (parts.length) {
        part = parts.shift();
        t = t[part] = t[part] || {};
      }
      t[key] = o[k];
    }
    return oo;
  },
  mapValues: mapValues = function(obj, f_val) {
    if (!isPlainObject(obj)) {
      throw new Error("mapValues must be called on an object, not '" + obj + "'");
    }
    return _.object(_.keys(obj), _.map(obj, f_val));
  },
  deepMapValues: deepMapValues = function(obj, f) {
    if (!isPlainObject(obj)) {
      throw new Error("deepMapValues must be called on an object, not '" + obj + "'");
    }
    return mapValues(obj, function(v, k) {
      if (isPlainObject(v)) {
        return deepMapValues(v, function(subv, subk) {
          return f(subv, "" + k + "." + subk);
        });
      } else {
        return f(v, k);
      }
    });
  },
  mapKeys: mapKeys = function(obj, f_val) {
    if (!isPlainObject(obj)) {
      throw new Error("mapKeys must be called on an object, not '" + obj + "'");
    }
    return _.object(_.map(obj, function(v, k) {
      return f_val(k, v);
    }), _.values(obj));
  }
};

},{"underscore":22}],22:[function(require,module,exports){
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result  either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],23:[function(require,module,exports){
//===========================================================================//
// Dependencies
//===========================================================================//

var _  = require("underscore");
_.mixin(require("underscore.deep"));

var defaultConfig = {
    rules : [],
};

function identityFunc (value) {
    return value;
}

function _startsWith(str, prefix) {
    return str.substr(0, prefix.length) == prefix;
}

function _endsWith(str, prefix) {
    return str.substr(-prefix.length) == prefix;
}

//===========================================================================//
// Matching rules
//===========================================================================//

function keyMatchesRuleData(ruleData, fullKey, key) {
    var i;

    // Check key name matches against *this* field name
    if (ruleData.keySet[key]) {
        return true;
    }
    for (i = 0; i < ruleData.keyPrefixes.length; i++) {
        if (_startsWith(key, ruleData.keyPrefixes[i])) {
            return true;
        }
    }
    for (i = 0; i < ruleData.keySuffixes.length; i++) {
        if (_endsWith(key, ruleData.keySuffixes[i])) {
            return true;
        }
    }

    // Check path names against the full dot notation key path
    if (ruleData.pathSet[fullKey]) {
        return true;
    }
    for (i = 0; i < ruleData.pathPrefixes.length; i++) {
        if (_startsWith(key, ruleData.pathPrefixes[i])) {
            return true;
        }
    }
    for (i = 0; i < ruleData.pathSuffixes.length; i++) {
        if (_endsWith(key, ruleData.pathSuffixes[i])) {
            return true;
        }
    }

    // Check regular expresssion matches against the full key path
    for (i = 0; i < ruleData.regularExpressions.length; i++) {
        if (fullKey.match(ruleData.regularExpressions[i])) {
            return true;
        }
    }
    return false;
}

// Transform the rule config into a more runtime-useful form.
function buildRuleData(rule) {
    var ruleData = {
        keySet          : {},
        keyPrefixes     : [],
        keySuffixes     : [],

        pathSet         : {},
        pathPrefixes    : [],
        pathSuffixes    : [],

        regularExpressions : [],
    };

    var i;
    if (rule.keys) {
        for (i = 0; i < rule.keys.length; i++) {
            ruleData.keySet[rule.keys[i]] = true;
        }
    }
    ruleData.keyPrefixes = rule.key_prefixes || [];
    ruleData.keySuffixes = rule.key_suffixes || [];

    if (rule.paths) {
        for (i = 0; i < rule.paths.length; i++) {
            ruleData.pathSet[rule.paths[i]] = true;
        }
    }
    ruleData.pathPrefixes = rule.path_prefixes || [];
    ruleData.pathSuffixes = rule.path_suffixes || [];

    if (rule.regular_expressions) {
        for (i = 0; i < rule.regular_expressions.length; i++) {
            ruleData.regularExpressions.push(new RegExp(rule.regular_expressions[i]));
        }
    }
    return ruleData;
}

//===========================================================================//
// Implementation code
//===========================================================================//

function deepMapValuesOrDirectCall(obj, f) {
    if (_.isArray(obj)) {
        for (var i = 0; i < obj.length; i++) {
            obj[i] = deepMapValuesOrDirectCall(obj[i], f);
        }
        return obj;
    } else if (_.isObject(obj)) {
        return _.deepMapValues(obj, f);
    } else {
        return f(obj);
    }
}

function deepRemoveKeys(obj, prefix, ruleData) {
    // Functions are objects in JS so both these checks are needed.
    if (!_.isObject(obj) || typeof obj === "function") {
        return;
    }
    for (var key in obj) {
        if (!obj.hasOwnProperty(key)) {
            continue;
        }
        if (keyMatchesRuleData(ruleData, prefix + key, key)) {
            delete obj[key];
            continue;
        }
        deepRemoveKeys(obj[key], prefix + key + ".", ruleData);
    }
}

function deepReplaceValues(obj, prefix, ruleData, value) {
    // Functions are objects in JS so both these checks are needed.
    if (!_.isObject(obj) || typeof obj === "function") {
        return;
    }
    for (var key in obj) {
        if (!obj.hasOwnProperty(key)) {
            continue;
        }      
        if (keyMatchesRuleData(ruleData, prefix + key, key)) {
            obj[key] = value;
            continue;
        }
        if (obj[key] !== key) {
            deepReplaceValues(obj[key], prefix + key + ".", ruleData, value);
        }
    }
}

function generateFunctionForRule(rule) {

    var ruleData = buildRuleData(rule);

    if (rule.match == "keys") {

        if (rule.op == "remove") {
            return function(value) {
                deepRemoveKeys(value, "", ruleData);
                return value;
            };

        } else if (rule.op == "replace") {
            return function(value) {
                deepReplaceValues(value, "", ruleData, rule.value);
                return value;
            };
        }

    } else if (rule.match == "url_query_string") {
        return function(value) {
            return deepMapValuesOrDirectCall(value, function(value) {
                if (!_.isString(value)) {
                    return value;
                }
                return processQueryStringValue(ruleData, value, rule.value);
            });
        };
    }

    // Hmmm...unhandled case
    throw new Error("Unsupported rule:\n" + JSON.stringify(rule, null, 4));
}

// Handle both full urls and just query strings:
//
//      "http://url.com/page?param=123&value=765"
//      "param=123&value=765"
//
// For brevity of the implementation, treat "replacement === undefined" as meaning
// *remove* the key and value. (Hey, it's not a public API!)
//
function processQueryStringValue(ruleData, value, replacementRaw) {

    // Early out if this clearly is not a URL query string
    if (value.indexOf("=") === -1) {
        return value;
    }

    var replacementValue;
    if (replacementRaw !== undefined) {
        replacementValue = encodeURIComponent(replacementRaw);
    }

    var leading = "";
    var parts = value.split("?");
    if (parts.length > 1) {
        leading = parts.shift() + "?";
    }

    var queryString = _.chain(parts.join("?").split("&"))
        .map(function(param) {
            var parts = param.split("=");
            var key, value;

            try {
                key = decodeURIComponent(parts[0]);
            } catch (_ignored) {
                return param;
            }
            value = parts.slice(1).join("=");

            // The key is always also the "full key" in a query string
            if (keyMatchesRuleData(ruleData, key, key)) {
                if (replacementValue === undefined) {
                    return "";
                } else {
                    return parts[0] + "=" + replacementValue;
                }
            } else {
                // No match, return the unmodified pair
                return param;
            }
        })
        .filter(function(v) { return v.length > 0; })
        .value()
        .join("&");

    return leading + queryString;
}

//===========================================================================//
// Scubber
//===========================================================================//

function Scrubber(cfg) {
    cfg = cfg || defaultConfig;

    this._config     = cfg;
    this._scrubFunc  = identityFunc;
    this._configure(cfg);
}

Scrubber.prototype._configure = function(cfg) {
    if (cfg.rules.length) {
        // Split any multiple match types into individual rules with a single
        // match type.
        var rules = [];
        _.each(cfg.rules, function (rule) {
            if (_.isArray(rule.match)) {
                _.each(rule.match, function (match) {
                    var newRule = _.clone(rule);
                    newRule.match = match;
                    rules.push(newRule);
                });
            } else {
                rules.push(rule);
            }
        });

        // TODO: this is presumably quite inefficient for large objects --
        // compose() is making this into N scans of the full object for
        // each rule; presumably walking the object once and checking each
        // rule at each step would be more efficient.
        var funcs = _.map(rules, generateFunctionForRule);
        this._scrubFunc = _.compose.apply(_, funcs);
    }
};

Scrubber.prototype.copy = function(value) {
    return this._scrubFunc(_.deepClone(value));
};

Scrubber.prototype.modify = function(value) {
    return this._scrubFunc(value);
};

//===========================================================================//
// Exported API
//===========================================================================//

var lib = {};

lib.make = function(cfg) {
    return new Scrubber(cfg);
};

module.exports = lib;

},{"underscore":22,"underscore.deep":21}]},{},[9])(9)
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3Rvb2xzL3JidWlsZC9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwicGFja2FnZS5qc29uIiwic3JjL2dlbmVyYXRlZC9jcm91dG9uX3RocmlmdF9hbGwuanMiLCJzcmMvaW5pdGlhbGl6ZV9kZWJ1Z19vdmVybGF5LmpzIiwic3JjL2luaXRpYWxpemVfcnVudGltZV9hdHRyaWJ1dGVzLmpzIiwic3JjL2luc3RydW1lbnRfYWpheC5qcyIsInNyYy9pbnN0cnVtZW50X2RvY3VtZW50LmpzIiwic3JjL3BsYXRmb3JtX2Jyb3dzZXIuanMiLCJzcmMvcG9seWZpbGwuanMiLCIuLi9ybC1jcnVudGltZS1jb21tb24vaW5kZXguanMiLCIuLi9ybC1jcnVudGltZS1jb21tb24vc3JjL2FwaS5qcyIsIi4uL3JsLWNydW50aW1lLWNvbW1vbi9zcmMvY2xvY2tfc3RhdGUuanMiLCIuLi9ybC1jcnVudGltZS1jb21tb24vc3JjL29iamVjdF9wb29sLmpzIiwiLi4vcmwtY3J1bnRpbWUtY29tbW9uL3NyYy9zcGFuX2hhbmRsZS5qcyIsIi4uL3JsLWNydW50aW1lLWNvbW1vbi9zcmMvc3RhdGUuanMiLCIuLi9ybC1jcnVudGltZS1jb21tb24vc3JjL3RpbWVzdGFtcF9zYW1wbGVzLmpzIiwiLi4vcmwtZXZlbnRlbWl0dGVyL2luZGV4LmpzIiwiLi4vcmwtaW5zcGVjdGFibGUtb2JqZWN0L2luZGV4LmpzIiwiLi4vcmwtaW5zcGVjdGFibGUtb2JqZWN0L3NyYy9wcm9jZXNzLmpzIiwiLi4vcmwtc2NydWJiZXIvaW5kZXguanMiLCIuLi9ybC1zY3J1YmJlci9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS5kZWVwL3VuZGVyc2NvcmUuZGVlcC5qcyIsIi4uL3JsLXNjcnViYmVyL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL3VuZGVyc2NvcmUuanMiLCIuLi9ybC1zY3J1YmJlci9zcmMvc2NydWJiZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdpR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDem1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeG1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1bEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hhQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJtb2R1bGUuZXhwb3J0cz17XG4gICAgXCJuYW1lXCI6IFwicmwtY3J1bnRpbWUtYnJvd3NlclwiLFxuICAgIFwidmVyc2lvblwiOiBcIjAuNC40XCIsXG4gICAgXCJtYWluXCI6IFwiY3J1bnRpbWVfYnJvd3Nlci5qc1wiLFxuICAgIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICAgICAgXCJodHRwLXNlcnZlclwiOiBcIl4wLjcuNVwiXG4gICAgfVxufSIsIihmdW5jdGlvbigpIHtcbnZhciBjcm91dG9uX3RocmlmdCA9IHt9O1xuLy9cbi8vIEF1dG9nZW5lcmF0ZWQgYnkgVGhyaWZ0IENvbXBpbGVyICgwLjkuMilcbi8vXG4vLyBETyBOT1QgRURJVCBVTkxFU1MgWU9VIEFSRSBTVVJFIFRIQVQgWU9VIEtOT1cgV0hBVCBZT1UgQVJFIERPSU5HXG4vL1xuXG5cbmlmICh0eXBlb2YgY3JvdXRvbl90aHJpZnQgPT09ICd1bmRlZmluZWQnKSB7XG4gIGNyb3V0b25fdGhyaWZ0ID0ge307XG59XG5jcm91dG9uX3RocmlmdC5LZXlWYWx1ZSA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgdGhpcy5LZXkgPSBudWxsO1xuICB0aGlzLlZhbHVlID0gbnVsbDtcbiAgaWYgKGFyZ3MpIHtcbiAgICBpZiAoYXJncy5LZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5LZXkgPSBhcmdzLktleTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFRocmlmdC5UUHJvdG9jb2xFeGNlcHRpb24oVGhyaWZ0LlRQcm90b2NvbEV4Y2VwdGlvblR5cGUuVU5LTk9XTiwgJ1JlcXVpcmVkIGZpZWxkIEtleSBpcyB1bnNldCEnKTtcbiAgICB9XG4gICAgaWYgKGFyZ3MuVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5WYWx1ZSA9IGFyZ3MuVmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUaHJpZnQuVFByb3RvY29sRXhjZXB0aW9uKFRocmlmdC5UUHJvdG9jb2xFeGNlcHRpb25UeXBlLlVOS05PV04sICdSZXF1aXJlZCBmaWVsZCBWYWx1ZSBpcyB1bnNldCEnKTtcbiAgICB9XG4gIH1cbn07XG5jcm91dG9uX3RocmlmdC5LZXlWYWx1ZS5wcm90b3R5cGUgPSB7fTtcbmNyb3V0b25fdGhyaWZ0LktleVZhbHVlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgaW5wdXQucmVhZFN0cnVjdEJlZ2luKCk7XG4gIHdoaWxlICh0cnVlKVxuICB7XG4gICAgdmFyIHJldCA9IGlucHV0LnJlYWRGaWVsZEJlZ2luKCk7XG4gICAgdmFyIGZuYW1lID0gcmV0LmZuYW1lO1xuICAgIHZhciBmdHlwZSA9IHJldC5mdHlwZTtcbiAgICB2YXIgZmlkID0gcmV0LmZpZDtcbiAgICBpZiAoZnR5cGUgPT0gVGhyaWZ0LlR5cGUuU1RPUCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHN3aXRjaCAoZmlkKVxuICAgIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgIGlmIChmdHlwZSA9PSBUaHJpZnQuVHlwZS5TVFJJTkcpIHtcbiAgICAgICAgdGhpcy5LZXkgPSBpbnB1dC5yZWFkU3RyaW5nKCkudmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dC5za2lwKGZ0eXBlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgaWYgKGZ0eXBlID09IFRocmlmdC5UeXBlLlNUUklORykge1xuICAgICAgICB0aGlzLlZhbHVlID0gaW5wdXQucmVhZFN0cmluZygpLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXQuc2tpcChmdHlwZSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlucHV0LnNraXAoZnR5cGUpO1xuICAgIH1cbiAgICBpbnB1dC5yZWFkRmllbGRFbmQoKTtcbiAgfVxuICBpbnB1dC5yZWFkU3RydWN0RW5kKCk7XG4gIHJldHVybjtcbn07XG5cbmNyb3V0b25fdGhyaWZ0LktleVZhbHVlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKG91dHB1dCkge1xuICBvdXRwdXQud3JpdGVTdHJ1Y3RCZWdpbignS2V5VmFsdWUnKTtcbiAgaWYgKHRoaXMuS2V5ICE9PSBudWxsICYmIHRoaXMuS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBvdXRwdXQud3JpdGVGaWVsZEJlZ2luKCdLZXknLCBUaHJpZnQuVHlwZS5TVFJJTkcsIDEpO1xuICAgIG91dHB1dC53cml0ZVN0cmluZyh0aGlzLktleSk7XG4gICAgb3V0cHV0LndyaXRlRmllbGRFbmQoKTtcbiAgfVxuICBpZiAodGhpcy5WYWx1ZSAhPT0gbnVsbCAmJiB0aGlzLlZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBvdXRwdXQud3JpdGVGaWVsZEJlZ2luKCdWYWx1ZScsIFRocmlmdC5UeXBlLlNUUklORywgMik7XG4gICAgb3V0cHV0LndyaXRlU3RyaW5nKHRoaXMuVmFsdWUpO1xuICAgIG91dHB1dC53cml0ZUZpZWxkRW5kKCk7XG4gIH1cbiAgb3V0cHV0LndyaXRlRmllbGRTdG9wKCk7XG4gIG91dHB1dC53cml0ZVN0cnVjdEVuZCgpO1xuICByZXR1cm47XG59O1xuXG5jcm91dG9uX3RocmlmdC5OYW1lZENvdW50ZXIgPSBmdW5jdGlvbihhcmdzKSB7XG4gIHRoaXMuTmFtZSA9IG51bGw7XG4gIHRoaXMuVmFsdWUgPSBudWxsO1xuICBpZiAoYXJncykge1xuICAgIGlmIChhcmdzLk5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5OYW1lID0gYXJncy5OYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVGhyaWZ0LlRQcm90b2NvbEV4Y2VwdGlvbihUaHJpZnQuVFByb3RvY29sRXhjZXB0aW9uVHlwZS5VTktOT1dOLCAnUmVxdWlyZWQgZmllbGQgTmFtZSBpcyB1bnNldCEnKTtcbiAgICB9XG4gICAgaWYgKGFyZ3MuVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5WYWx1ZSA9IGFyZ3MuVmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUaHJpZnQuVFByb3RvY29sRXhjZXB0aW9uKFRocmlmdC5UUHJvdG9jb2xFeGNlcHRpb25UeXBlLlVOS05PV04sICdSZXF1aXJlZCBmaWVsZCBWYWx1ZSBpcyB1bnNldCEnKTtcbiAgICB9XG4gIH1cbn07XG5jcm91dG9uX3RocmlmdC5OYW1lZENvdW50ZXIucHJvdG90eXBlID0ge307XG5jcm91dG9uX3RocmlmdC5OYW1lZENvdW50ZXIucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihpbnB1dCkge1xuICBpbnB1dC5yZWFkU3RydWN0QmVnaW4oKTtcbiAgd2hpbGUgKHRydWUpXG4gIHtcbiAgICB2YXIgcmV0ID0gaW5wdXQucmVhZEZpZWxkQmVnaW4oKTtcbiAgICB2YXIgZm5hbWUgPSByZXQuZm5hbWU7XG4gICAgdmFyIGZ0eXBlID0gcmV0LmZ0eXBlO1xuICAgIHZhciBmaWQgPSByZXQuZmlkO1xuICAgIGlmIChmdHlwZSA9PSBUaHJpZnQuVHlwZS5TVE9QKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc3dpdGNoIChmaWQpXG4gICAge1xuICAgICAgY2FzZSAxOlxuICAgICAgaWYgKGZ0eXBlID09IFRocmlmdC5UeXBlLlNUUklORykge1xuICAgICAgICB0aGlzLk5hbWUgPSBpbnB1dC5yZWFkU3RyaW5nKCkudmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dC5za2lwKGZ0eXBlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgaWYgKGZ0eXBlID09IFRocmlmdC5UeXBlLkk2NCkge1xuICAgICAgICB0aGlzLlZhbHVlID0gaW5wdXQucmVhZEk2NCgpLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXQuc2tpcChmdHlwZSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlucHV0LnNraXAoZnR5cGUpO1xuICAgIH1cbiAgICBpbnB1dC5yZWFkRmllbGRFbmQoKTtcbiAgfVxuICBpbnB1dC5yZWFkU3RydWN0RW5kKCk7XG4gIHJldHVybjtcbn07XG5cbmNyb3V0b25fdGhyaWZ0Lk5hbWVkQ291bnRlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihvdXRwdXQpIHtcbiAgb3V0cHV0LndyaXRlU3RydWN0QmVnaW4oJ05hbWVkQ291bnRlcicpO1xuICBpZiAodGhpcy5OYW1lICE9PSBudWxsICYmIHRoaXMuTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgb3V0cHV0LndyaXRlRmllbGRCZWdpbignTmFtZScsIFRocmlmdC5UeXBlLlNUUklORywgMSk7XG4gICAgb3V0cHV0LndyaXRlU3RyaW5nKHRoaXMuTmFtZSk7XG4gICAgb3V0cHV0LndyaXRlRmllbGRFbmQoKTtcbiAgfVxuICBpZiAodGhpcy5WYWx1ZSAhPT0gbnVsbCAmJiB0aGlzLlZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBvdXRwdXQud3JpdGVGaWVsZEJlZ2luKCdWYWx1ZScsIFRocmlmdC5UeXBlLkk2NCwgMik7XG4gICAgb3V0cHV0LndyaXRlSTY0KHRoaXMuVmFsdWUpO1xuICAgIG91dHB1dC53cml0ZUZpZWxkRW5kKCk7XG4gIH1cbiAgb3V0cHV0LndyaXRlRmllbGRTdG9wKCk7XG4gIG91dHB1dC53cml0ZVN0cnVjdEVuZCgpO1xuICByZXR1cm47XG59O1xuXG5jcm91dG9uX3RocmlmdC5SdW50aW1lID0gZnVuY3Rpb24oYXJncykge1xuICB0aGlzLmd1aWQgPSBudWxsO1xuICB0aGlzLnN0YXJ0X21pY3JvcyA9IG51bGw7XG4gIHRoaXMuZ3JvdXBfbmFtZSA9IG51bGw7XG4gIHRoaXMuYXR0cnMgPSBudWxsO1xuICBpZiAoYXJncykge1xuICAgIGlmIChhcmdzLmd1aWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5ndWlkID0gYXJncy5ndWlkO1xuICAgIH1cbiAgICBpZiAoYXJncy5zdGFydF9taWNyb3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zdGFydF9taWNyb3MgPSBhcmdzLnN0YXJ0X21pY3JvcztcbiAgICB9XG4gICAgaWYgKGFyZ3MuZ3JvdXBfbmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmdyb3VwX25hbWUgPSBhcmdzLmdyb3VwX25hbWU7XG4gICAgfVxuICAgIGlmIChhcmdzLmF0dHJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIH1cbiAgfVxufTtcbmNyb3V0b25fdGhyaWZ0LlJ1bnRpbWUucHJvdG90eXBlID0ge307XG5jcm91dG9uX3RocmlmdC5SdW50aW1lLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgaW5wdXQucmVhZFN0cnVjdEJlZ2luKCk7XG4gIHdoaWxlICh0cnVlKVxuICB7XG4gICAgdmFyIHJldCA9IGlucHV0LnJlYWRGaWVsZEJlZ2luKCk7XG4gICAgdmFyIGZuYW1lID0gcmV0LmZuYW1lO1xuICAgIHZhciBmdHlwZSA9IHJldC5mdHlwZTtcbiAgICB2YXIgZmlkID0gcmV0LmZpZDtcbiAgICBpZiAoZnR5cGUgPT0gVGhyaWZ0LlR5cGUuU1RPUCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHN3aXRjaCAoZmlkKVxuICAgIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgIGlmIChmdHlwZSA9PSBUaHJpZnQuVHlwZS5TVFJJTkcpIHtcbiAgICAgICAgdGhpcy5ndWlkID0gaW5wdXQucmVhZFN0cmluZygpLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXQuc2tpcChmdHlwZSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgIGlmIChmdHlwZSA9PSBUaHJpZnQuVHlwZS5JNjQpIHtcbiAgICAgICAgdGhpcy5zdGFydF9taWNyb3MgPSBpbnB1dC5yZWFkSTY0KCkudmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dC5za2lwKGZ0eXBlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgaWYgKGZ0eXBlID09IFRocmlmdC5UeXBlLlNUUklORykge1xuICAgICAgICB0aGlzLmdyb3VwX25hbWUgPSBpbnB1dC5yZWFkU3RyaW5nKCkudmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dC5za2lwKGZ0eXBlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA0OlxuICAgICAgaWYgKGZ0eXBlID09IFRocmlmdC5UeXBlLkxJU1QpIHtcbiAgICAgICAgdmFyIF9zaXplMCA9IDA7XG4gICAgICAgIHZhciBfcnRtcDM0O1xuICAgICAgICB0aGlzLmF0dHJzID0gW107XG4gICAgICAgIHZhciBfZXR5cGUzID0gMDtcbiAgICAgICAgX3J0bXAzNCA9IGlucHV0LnJlYWRMaXN0QmVnaW4oKTtcbiAgICAgICAgX2V0eXBlMyA9IF9ydG1wMzQuZXR5cGU7XG4gICAgICAgIF9zaXplMCA9IF9ydG1wMzQuc2l6ZTtcbiAgICAgICAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgX3NpemUwOyArK19pNSlcbiAgICAgICAge1xuICAgICAgICAgIHZhciBlbGVtNiA9IG51bGw7XG4gICAgICAgICAgZWxlbTYgPSBuZXcgY3JvdXRvbl90aHJpZnQuS2V5VmFsdWUoKTtcbiAgICAgICAgICBlbGVtNi5yZWFkKGlucHV0KTtcbiAgICAgICAgICB0aGlzLmF0dHJzLnB1c2goZWxlbTYpO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0LnJlYWRMaXN0RW5kKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dC5za2lwKGZ0eXBlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW5wdXQuc2tpcChmdHlwZSk7XG4gICAgfVxuICAgIGlucHV0LnJlYWRGaWVsZEVuZCgpO1xuICB9XG4gIGlucHV0LnJlYWRTdHJ1Y3RFbmQoKTtcbiAgcmV0dXJuO1xufTtcblxuY3JvdXRvbl90aHJpZnQuUnVudGltZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihvdXRwdXQpIHtcbiAgb3V0cHV0LndyaXRlU3RydWN0QmVnaW4oJ1J1bnRpbWUnKTtcbiAgaWYgKHRoaXMuZ3VpZCAhPT0gbnVsbCAmJiB0aGlzLmd1aWQgIT09IHVuZGVmaW5lZCkge1xuICAgIG91dHB1dC53cml0ZUZpZWxkQmVnaW4oJ2d1aWQnLCBUaHJpZnQuVHlwZS5TVFJJTkcsIDEpO1xuICAgIG91dHB1dC53cml0ZVN0cmluZyh0aGlzLmd1aWQpO1xuICAgIG91dHB1dC53cml0ZUZpZWxkRW5kKCk7XG4gIH1cbiAgaWYgKHRoaXMuc3RhcnRfbWljcm9zICE9PSBudWxsICYmIHRoaXMuc3RhcnRfbWljcm9zICE9PSB1bmRlZmluZWQpIHtcbiAgICBvdXRwdXQud3JpdGVGaWVsZEJlZ2luKCdzdGFydF9taWNyb3MnLCBUaHJpZnQuVHlwZS5JNjQsIDIpO1xuICAgIG91dHB1dC53cml0ZUk2NCh0aGlzLnN0YXJ0X21pY3Jvcyk7XG4gICAgb3V0cHV0LndyaXRlRmllbGRFbmQoKTtcbiAgfVxuICBpZiAodGhpcy5ncm91cF9uYW1lICE9PSBudWxsICYmIHRoaXMuZ3JvdXBfbmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgb3V0cHV0LndyaXRlRmllbGRCZWdpbignZ3JvdXBfbmFtZScsIFRocmlmdC5UeXBlLlNUUklORywgMyk7XG4gICAgb3V0cHV0LndyaXRlU3RyaW5nKHRoaXMuZ3JvdXBfbmFtZSk7XG4gICAgb3V0cHV0LndyaXRlRmllbGRFbmQoKTtcbiAgfVxuICBpZiAodGhpcy5hdHRycyAhPT0gbnVsbCAmJiB0aGlzLmF0dHJzICE9PSB1bmRlZmluZWQpIHtcbiAgICBvdXRwdXQud3JpdGVGaWVsZEJlZ2luKCdhdHRycycsIFRocmlmdC5UeXBlLkxJU1QsIDQpO1xuICAgIG91dHB1dC53cml0ZUxpc3RCZWdpbihUaHJpZnQuVHlwZS5TVFJVQ1QsIHRoaXMuYXR0cnMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpdGVyNyBpbiB0aGlzLmF0dHJzKVxuICAgIHtcbiAgICAgIGlmICh0aGlzLmF0dHJzLmhhc093blByb3BlcnR5KGl0ZXI3KSlcbiAgICAgIHtcbiAgICAgICAgaXRlcjcgPSB0aGlzLmF0dHJzW2l0ZXI3XTtcbiAgICAgICAgaXRlcjcud3JpdGUob3V0cHV0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgb3V0cHV0LndyaXRlTGlzdEVuZCgpO1xuICAgIG91dHB1dC53cml0ZUZpZWxkRW5kKCk7XG4gIH1cbiAgb3V0cHV0LndyaXRlRmllbGRTdG9wKCk7XG4gIG91dHB1dC53cml0ZVN0cnVjdEVuZCgpO1xuICByZXR1cm47XG59O1xuXG5jcm91dG9uX3RocmlmdC5Mb2dSZWNvcmQgPSBmdW5jdGlvbihhcmdzKSB7XG4gIHRoaXMudGltZXN0YW1wX21pY3JvcyA9IG51bGw7XG4gIHRoaXMucnVudGltZV9ndWlkID0gbnVsbDtcbiAgdGhpcy5zcGFuX2d1aWQgPSBudWxsO1xuICB0aGlzLnN0YWJsZV9uYW1lID0gbnVsbDtcbiAgdGhpcy5tZXNzYWdlID0gbnVsbDtcbiAgdGhpcy5sZXZlbCA9IG51bGw7XG4gIHRoaXMudGhyZWFkX2lkID0gbnVsbDtcbiAgdGhpcy5maWxlbmFtZSA9IG51bGw7XG4gIHRoaXMubGluZV9udW1iZXIgPSBudWxsO1xuICB0aGlzLnN0YWNrX2ZyYW1lcyA9IG51bGw7XG4gIHRoaXMucGF5bG9hZF9qc29uID0gbnVsbDtcbiAgdGhpcy5lcnJvcl9mbGFnID0gbnVsbDtcbiAgaWYgKGFyZ3MpIHtcbiAgICBpZiAoYXJncy50aW1lc3RhbXBfbWljcm9zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMudGltZXN0YW1wX21pY3JvcyA9IGFyZ3MudGltZXN0YW1wX21pY3JvcztcbiAgICB9XG4gICAgaWYgKGFyZ3MucnVudGltZV9ndWlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMucnVudGltZV9ndWlkID0gYXJncy5ydW50aW1lX2d1aWQ7XG4gICAgfVxuICAgIGlmIChhcmdzLnNwYW5fZ3VpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnNwYW5fZ3VpZCA9IGFyZ3Muc3Bhbl9ndWlkO1xuICAgIH1cbiAgICBpZiAoYXJncy5zdGFibGVfbmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnN0YWJsZV9uYW1lID0gYXJncy5zdGFibGVfbmFtZTtcbiAgICB9XG4gICAgaWYgKGFyZ3MubWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBhcmdzLm1lc3NhZ2U7XG4gICAgfVxuICAgIGlmIChhcmdzLmxldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMubGV2ZWwgPSBhcmdzLmxldmVsO1xuICAgIH1cbiAgICBpZiAoYXJncy50aHJlYWRfaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50aHJlYWRfaWQgPSBhcmdzLnRocmVhZF9pZDtcbiAgICB9XG4gICAgaWYgKGFyZ3MuZmlsZW5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5maWxlbmFtZSA9IGFyZ3MuZmlsZW5hbWU7XG4gICAgfVxuICAgIGlmIChhcmdzLmxpbmVfbnVtYmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMubGluZV9udW1iZXIgPSBhcmdzLmxpbmVfbnVtYmVyO1xuICAgIH1cbiAgICBpZiAoYXJncy5zdGFja19mcmFtZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zdGFja19mcmFtZXMgPSBhcmdzLnN0YWNrX2ZyYW1lcztcbiAgICB9XG4gICAgaWYgKGFyZ3MucGF5bG9hZF9qc29uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMucGF5bG9hZF9qc29uID0gYXJncy5wYXlsb2FkX2pzb247XG4gICAgfVxuICAgIGlmIChhcmdzLmVycm9yX2ZsYWcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5lcnJvcl9mbGFnID0gYXJncy5lcnJvcl9mbGFnO1xuICAgIH1cbiAgfVxufTtcbmNyb3V0b25fdGhyaWZ0LkxvZ1JlY29yZC5wcm90b3R5cGUgPSB7fTtcbmNyb3V0b25fdGhyaWZ0LkxvZ1JlY29yZC5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGlucHV0LnJlYWRTdHJ1Y3RCZWdpbigpO1xuICB3aGlsZSAodHJ1ZSlcbiAge1xuICAgIHZhciByZXQgPSBpbnB1dC5yZWFkRmllbGRCZWdpbigpO1xuICAgIHZhciBmbmFtZSA9IHJldC5mbmFtZTtcbiAgICB2YXIgZnR5cGUgPSByZXQuZnR5cGU7XG4gICAgdmFyIGZpZCA9IHJldC5maWQ7XG4gICAgaWYgKGZ0eXBlID09IFRocmlmdC5UeXBlLlNUT1ApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBzd2l0Y2ggKGZpZClcbiAgICB7XG4gICAgICBjYXNlIDE6XG4gICAgICBpZiAoZnR5cGUgPT0gVGhyaWZ0LlR5cGUuSTY0KSB7XG4gICAgICAgIHRoaXMudGltZXN0YW1wX21pY3JvcyA9IGlucHV0LnJlYWRJNjQoKS52YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlucHV0LnNraXAoZnR5cGUpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICBpZiAoZnR5cGUgPT0gVGhyaWZ0LlR5cGUuU1RSSU5HKSB7XG4gICAgICAgIHRoaXMucnVudGltZV9ndWlkID0gaW5wdXQucmVhZFN0cmluZygpLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXQuc2tpcChmdHlwZSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgIGlmIChmdHlwZSA9PSBUaHJpZnQuVHlwZS5TVFJJTkcpIHtcbiAgICAgICAgdGhpcy5zcGFuX2d1aWQgPSBpbnB1dC5yZWFkU3RyaW5nKCkudmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dC5za2lwKGZ0eXBlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA0OlxuICAgICAgaWYgKGZ0eXBlID09IFRocmlmdC5UeXBlLlNUUklORykge1xuICAgICAgICB0aGlzLnN0YWJsZV9uYW1lID0gaW5wdXQucmVhZFN0cmluZygpLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXQuc2tpcChmdHlwZSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICAgIGNhc2UgNTpcbiAgICAgIGlmIChmdHlwZSA9PSBUaHJpZnQuVHlwZS5TVFJJTkcpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gaW5wdXQucmVhZFN0cmluZygpLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXQuc2tpcChmdHlwZSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICAgIGNhc2UgNjpcbiAgICAgIGlmIChmdHlwZSA9PSBUaHJpZnQuVHlwZS5TVFJJTkcpIHtcbiAgICAgICAgdGhpcy5sZXZlbCA9IGlucHV0LnJlYWRTdHJpbmcoKS52YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlucHV0LnNraXAoZnR5cGUpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDc6XG4gICAgICBpZiAoZnR5cGUgPT0gVGhyaWZ0LlR5cGUuSTY0KSB7XG4gICAgICAgIHRoaXMudGhyZWFkX2lkID0gaW5wdXQucmVhZEk2NCgpLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXQuc2tpcChmdHlwZSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICAgIGNhc2UgODpcbiAgICAgIGlmIChmdHlwZSA9PSBUaHJpZnQuVHlwZS5TVFJJTkcpIHtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IGlucHV0LnJlYWRTdHJpbmcoKS52YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlucHV0LnNraXAoZnR5cGUpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDk6XG4gICAgICBpZiAoZnR5cGUgPT0gVGhyaWZ0LlR5cGUuSTY0KSB7XG4gICAgICAgIHRoaXMubGluZV9udW1iZXIgPSBpbnB1dC5yZWFkSTY0KCkudmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dC5za2lwKGZ0eXBlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMDpcbiAgICAgIGlmIChmdHlwZSA9PSBUaHJpZnQuVHlwZS5MSVNUKSB7XG4gICAgICAgIHZhciBfc2l6ZTggPSAwO1xuICAgICAgICB2YXIgX3J0bXAzMTI7XG4gICAgICAgIHRoaXMuc3RhY2tfZnJhbWVzID0gW107XG4gICAgICAgIHZhciBfZXR5cGUxMSA9IDA7XG4gICAgICAgIF9ydG1wMzEyID0gaW5wdXQucmVhZExpc3RCZWdpbigpO1xuICAgICAgICBfZXR5cGUxMSA9IF9ydG1wMzEyLmV0eXBlO1xuICAgICAgICBfc2l6ZTggPSBfcnRtcDMxMi5zaXplO1xuICAgICAgICBmb3IgKHZhciBfaTEzID0gMDsgX2kxMyA8IF9zaXplODsgKytfaTEzKVxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGVsZW0xNCA9IG51bGw7XG4gICAgICAgICAgZWxlbTE0ID0gaW5wdXQucmVhZFN0cmluZygpLnZhbHVlO1xuICAgICAgICAgIHRoaXMuc3RhY2tfZnJhbWVzLnB1c2goZWxlbTE0KTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dC5yZWFkTGlzdEVuZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXQuc2tpcChmdHlwZSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICAgIGNhc2UgMTE6XG4gICAgICBpZiAoZnR5cGUgPT0gVGhyaWZ0LlR5cGUuU1RSSU5HKSB7XG4gICAgICAgIHRoaXMucGF5bG9hZF9qc29uID0gaW5wdXQucmVhZFN0cmluZygpLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXQuc2tpcChmdHlwZSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI6XG4gICAgICBpZiAoZnR5cGUgPT0gVGhyaWZ0LlR5cGUuQk9PTCkge1xuICAgICAgICB0aGlzLmVycm9yX2ZsYWcgPSBpbnB1dC5yZWFkQm9vbCgpLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXQuc2tpcChmdHlwZSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlucHV0LnNraXAoZnR5cGUpO1xuICAgIH1cbiAgICBpbnB1dC5yZWFkRmllbGRFbmQoKTtcbiAgfVxuICBpbnB1dC5yZWFkU3RydWN0RW5kKCk7XG4gIHJldHVybjtcbn07XG5cbmNyb3V0b25fdGhyaWZ0LkxvZ1JlY29yZC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihvdXRwdXQpIHtcbiAgb3V0cHV0LndyaXRlU3RydWN0QmVnaW4oJ0xvZ1JlY29yZCcpO1xuICBpZiAodGhpcy50aW1lc3RhbXBfbWljcm9zICE9PSBudWxsICYmIHRoaXMudGltZXN0YW1wX21pY3JvcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgb3V0cHV0LndyaXRlRmllbGRCZWdpbigndGltZXN0YW1wX21pY3JvcycsIFRocmlmdC5UeXBlLkk2NCwgMSk7XG4gICAgb3V0cHV0LndyaXRlSTY0KHRoaXMudGltZXN0YW1wX21pY3Jvcyk7XG4gICAgb3V0cHV0LndyaXRlRmllbGRFbmQoKTtcbiAgfVxuICBpZiAodGhpcy5ydW50aW1lX2d1aWQgIT09IG51bGwgJiYgdGhpcy5ydW50aW1lX2d1aWQgIT09IHVuZGVmaW5lZCkge1xuICAgIG91dHB1dC53cml0ZUZpZWxkQmVnaW4oJ3J1bnRpbWVfZ3VpZCcsIFRocmlmdC5UeXBlLlNUUklORywgMik7XG4gICAgb3V0cHV0LndyaXRlU3RyaW5nKHRoaXMucnVudGltZV9ndWlkKTtcbiAgICBvdXRwdXQud3JpdGVGaWVsZEVuZCgpO1xuICB9XG4gIGlmICh0aGlzLnNwYW5fZ3VpZCAhPT0gbnVsbCAmJiB0aGlzLnNwYW5fZ3VpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgb3V0cHV0LndyaXRlRmllbGRCZWdpbignc3Bhbl9ndWlkJywgVGhyaWZ0LlR5cGUuU1RSSU5HLCAzKTtcbiAgICBvdXRwdXQud3JpdGVTdHJpbmcodGhpcy5zcGFuX2d1aWQpO1xuICAgIG91dHB1dC53cml0ZUZpZWxkRW5kKCk7XG4gIH1cbiAgaWYgKHRoaXMuc3RhYmxlX25hbWUgIT09IG51bGwgJiYgdGhpcy5zdGFibGVfbmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgb3V0cHV0LndyaXRlRmllbGRCZWdpbignc3RhYmxlX25hbWUnLCBUaHJpZnQuVHlwZS5TVFJJTkcsIDQpO1xuICAgIG91dHB1dC53cml0ZVN0cmluZyh0aGlzLnN0YWJsZV9uYW1lKTtcbiAgICBvdXRwdXQud3JpdGVGaWVsZEVuZCgpO1xuICB9XG4gIGlmICh0aGlzLm1lc3NhZ2UgIT09IG51bGwgJiYgdGhpcy5tZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICBvdXRwdXQud3JpdGVGaWVsZEJlZ2luKCdtZXNzYWdlJywgVGhyaWZ0LlR5cGUuU1RSSU5HLCA1KTtcbiAgICBvdXRwdXQud3JpdGVTdHJpbmcodGhpcy5tZXNzYWdlKTtcbiAgICBvdXRwdXQud3JpdGVGaWVsZEVuZCgpO1xuICB9XG4gIGlmICh0aGlzLmxldmVsICE9PSBudWxsICYmIHRoaXMubGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgIG91dHB1dC53cml0ZUZpZWxkQmVnaW4oJ2xldmVsJywgVGhyaWZ0LlR5cGUuU1RSSU5HLCA2KTtcbiAgICBvdXRwdXQud3JpdGVTdHJpbmcodGhpcy5sZXZlbCk7XG4gICAgb3V0cHV0LndyaXRlRmllbGRFbmQoKTtcbiAgfVxuICBpZiAodGhpcy50aHJlYWRfaWQgIT09IG51bGwgJiYgdGhpcy50aHJlYWRfaWQgIT09IHVuZGVmaW5lZCkge1xuICAgIG91dHB1dC53cml0ZUZpZWxkQmVnaW4oJ3RocmVhZF9pZCcsIFRocmlmdC5UeXBlLkk2NCwgNyk7XG4gICAgb3V0cHV0LndyaXRlSTY0KHRoaXMudGhyZWFkX2lkKTtcbiAgICBvdXRwdXQud3JpdGVGaWVsZEVuZCgpO1xuICB9XG4gIGlmICh0aGlzLmZpbGVuYW1lICE9PSBudWxsICYmIHRoaXMuZmlsZW5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIG91dHB1dC53cml0ZUZpZWxkQmVnaW4oJ2ZpbGVuYW1lJywgVGhyaWZ0LlR5cGUuU1RSSU5HLCA4KTtcbiAgICBvdXRwdXQud3JpdGVTdHJpbmcodGhpcy5maWxlbmFtZSk7XG4gICAgb3V0cHV0LndyaXRlRmllbGRFbmQoKTtcbiAgfVxuICBpZiAodGhpcy5saW5lX251bWJlciAhPT0gbnVsbCAmJiB0aGlzLmxpbmVfbnVtYmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICBvdXRwdXQud3JpdGVGaWVsZEJlZ2luKCdsaW5lX251bWJlcicsIFRocmlmdC5UeXBlLkk2NCwgOSk7XG4gICAgb3V0cHV0LndyaXRlSTY0KHRoaXMubGluZV9udW1iZXIpO1xuICAgIG91dHB1dC53cml0ZUZpZWxkRW5kKCk7XG4gIH1cbiAgaWYgKHRoaXMuc3RhY2tfZnJhbWVzICE9PSBudWxsICYmIHRoaXMuc3RhY2tfZnJhbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBvdXRwdXQud3JpdGVGaWVsZEJlZ2luKCdzdGFja19mcmFtZXMnLCBUaHJpZnQuVHlwZS5MSVNULCAxMCk7XG4gICAgb3V0cHV0LndyaXRlTGlzdEJlZ2luKFRocmlmdC5UeXBlLlNUUklORywgdGhpcy5zdGFja19mcmFtZXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpdGVyMTUgaW4gdGhpcy5zdGFja19mcmFtZXMpXG4gICAge1xuICAgICAgaWYgKHRoaXMuc3RhY2tfZnJhbWVzLmhhc093blByb3BlcnR5KGl0ZXIxNSkpXG4gICAgICB7XG4gICAgICAgIGl0ZXIxNSA9IHRoaXMuc3RhY2tfZnJhbWVzW2l0ZXIxNV07XG4gICAgICAgIG91dHB1dC53cml0ZVN0cmluZyhpdGVyMTUpO1xuICAgICAgfVxuICAgIH1cbiAgICBvdXRwdXQud3JpdGVMaXN0RW5kKCk7XG4gICAgb3V0cHV0LndyaXRlRmllbGRFbmQoKTtcbiAgfVxuICBpZiAodGhpcy5wYXlsb2FkX2pzb24gIT09IG51bGwgJiYgdGhpcy5wYXlsb2FkX2pzb24gIT09IHVuZGVmaW5lZCkge1xuICAgIG91dHB1dC53cml0ZUZpZWxkQmVnaW4oJ3BheWxvYWRfanNvbicsIFRocmlmdC5UeXBlLlNUUklORywgMTEpO1xuICAgIG91dHB1dC53cml0ZVN0cmluZyh0aGlzLnBheWxvYWRfanNvbik7XG4gICAgb3V0cHV0LndyaXRlRmllbGRFbmQoKTtcbiAgfVxuICBpZiAodGhpcy5lcnJvcl9mbGFnICE9PSBudWxsICYmIHRoaXMuZXJyb3JfZmxhZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgb3V0cHV0LndyaXRlRmllbGRCZWdpbignZXJyb3JfZmxhZycsIFRocmlmdC5UeXBlLkJPT0wsIDEyKTtcbiAgICBvdXRwdXQud3JpdGVCb29sKHRoaXMuZXJyb3JfZmxhZyk7XG4gICAgb3V0cHV0LndyaXRlRmllbGRFbmQoKTtcbiAgfVxuICBvdXRwdXQud3JpdGVGaWVsZFN0b3AoKTtcbiAgb3V0cHV0LndyaXRlU3RydWN0RW5kKCk7XG4gIHJldHVybjtcbn07XG5cbmNyb3V0b25fdGhyaWZ0LlRyYWNlSm9pbklkID0gZnVuY3Rpb24oYXJncykge1xuICB0aGlzLlRyYWNlS2V5ID0gbnVsbDtcbiAgdGhpcy5WYWx1ZSA9IG51bGw7XG4gIGlmIChhcmdzKSB7XG4gICAgaWYgKGFyZ3MuVHJhY2VLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5UcmFjZUtleSA9IGFyZ3MuVHJhY2VLZXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUaHJpZnQuVFByb3RvY29sRXhjZXB0aW9uKFRocmlmdC5UUHJvdG9jb2xFeGNlcHRpb25UeXBlLlVOS05PV04sICdSZXF1aXJlZCBmaWVsZCBUcmFjZUtleSBpcyB1bnNldCEnKTtcbiAgICB9XG4gICAgaWYgKGFyZ3MuVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5WYWx1ZSA9IGFyZ3MuVmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUaHJpZnQuVFByb3RvY29sRXhjZXB0aW9uKFRocmlmdC5UUHJvdG9jb2xFeGNlcHRpb25UeXBlLlVOS05PV04sICdSZXF1aXJlZCBmaWVsZCBWYWx1ZSBpcyB1bnNldCEnKTtcbiAgICB9XG4gIH1cbn07XG5jcm91dG9uX3RocmlmdC5UcmFjZUpvaW5JZC5wcm90b3R5cGUgPSB7fTtcbmNyb3V0b25fdGhyaWZ0LlRyYWNlSm9pbklkLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgaW5wdXQucmVhZFN0cnVjdEJlZ2luKCk7XG4gIHdoaWxlICh0cnVlKVxuICB7XG4gICAgdmFyIHJldCA9IGlucHV0LnJlYWRGaWVsZEJlZ2luKCk7XG4gICAgdmFyIGZuYW1lID0gcmV0LmZuYW1lO1xuICAgIHZhciBmdHlwZSA9IHJldC5mdHlwZTtcbiAgICB2YXIgZmlkID0gcmV0LmZpZDtcbiAgICBpZiAoZnR5cGUgPT0gVGhyaWZ0LlR5cGUuU1RPUCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHN3aXRjaCAoZmlkKVxuICAgIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgIGlmIChmdHlwZSA9PSBUaHJpZnQuVHlwZS5TVFJJTkcpIHtcbiAgICAgICAgdGhpcy5UcmFjZUtleSA9IGlucHV0LnJlYWRTdHJpbmcoKS52YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlucHV0LnNraXAoZnR5cGUpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICBpZiAoZnR5cGUgPT0gVGhyaWZ0LlR5cGUuU1RSSU5HKSB7XG4gICAgICAgIHRoaXMuVmFsdWUgPSBpbnB1dC5yZWFkU3RyaW5nKCkudmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dC5za2lwKGZ0eXBlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW5wdXQuc2tpcChmdHlwZSk7XG4gICAgfVxuICAgIGlucHV0LnJlYWRGaWVsZEVuZCgpO1xuICB9XG4gIGlucHV0LnJlYWRTdHJ1Y3RFbmQoKTtcbiAgcmV0dXJuO1xufTtcblxuY3JvdXRvbl90aHJpZnQuVHJhY2VKb2luSWQucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24ob3V0cHV0KSB7XG4gIG91dHB1dC53cml0ZVN0cnVjdEJlZ2luKCdUcmFjZUpvaW5JZCcpO1xuICBpZiAodGhpcy5UcmFjZUtleSAhPT0gbnVsbCAmJiB0aGlzLlRyYWNlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBvdXRwdXQud3JpdGVGaWVsZEJlZ2luKCdUcmFjZUtleScsIFRocmlmdC5UeXBlLlNUUklORywgMSk7XG4gICAgb3V0cHV0LndyaXRlU3RyaW5nKHRoaXMuVHJhY2VLZXkpO1xuICAgIG91dHB1dC53cml0ZUZpZWxkRW5kKCk7XG4gIH1cbiAgaWYgKHRoaXMuVmFsdWUgIT09IG51bGwgJiYgdGhpcy5WYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgb3V0cHV0LndyaXRlRmllbGRCZWdpbignVmFsdWUnLCBUaHJpZnQuVHlwZS5TVFJJTkcsIDIpO1xuICAgIG91dHB1dC53cml0ZVN0cmluZyh0aGlzLlZhbHVlKTtcbiAgICBvdXRwdXQud3JpdGVGaWVsZEVuZCgpO1xuICB9XG4gIG91dHB1dC53cml0ZUZpZWxkU3RvcCgpO1xuICBvdXRwdXQud3JpdGVTdHJ1Y3RFbmQoKTtcbiAgcmV0dXJuO1xufTtcblxuY3JvdXRvbl90aHJpZnQuU3BhblJlY29yZCA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgdGhpcy5zcGFuX2d1aWQgPSBudWxsO1xuICB0aGlzLnJ1bnRpbWVfZ3VpZCA9IG51bGw7XG4gIHRoaXMuc3Bhbl9uYW1lID0gbnVsbDtcbiAgdGhpcy5qb2luX2lkcyA9IG51bGw7XG4gIHRoaXMub2xkZXN0X21pY3JvcyA9IG51bGw7XG4gIHRoaXMueW91bmdlc3RfbWljcm9zID0gbnVsbDtcbiAgdGhpcy5hdHRyaWJ1dGVzID0gbnVsbDtcbiAgdGhpcy5lcnJvcl9mbGFnID0gbnVsbDtcbiAgaWYgKGFyZ3MpIHtcbiAgICBpZiAoYXJncy5zcGFuX2d1aWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zcGFuX2d1aWQgPSBhcmdzLnNwYW5fZ3VpZDtcbiAgICB9XG4gICAgaWYgKGFyZ3MucnVudGltZV9ndWlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMucnVudGltZV9ndWlkID0gYXJncy5ydW50aW1lX2d1aWQ7XG4gICAgfVxuICAgIGlmIChhcmdzLnNwYW5fbmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnNwYW5fbmFtZSA9IGFyZ3Muc3Bhbl9uYW1lO1xuICAgIH1cbiAgICBpZiAoYXJncy5qb2luX2lkcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmpvaW5faWRzID0gYXJncy5qb2luX2lkcztcbiAgICB9XG4gICAgaWYgKGFyZ3Mub2xkZXN0X21pY3JvcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm9sZGVzdF9taWNyb3MgPSBhcmdzLm9sZGVzdF9taWNyb3M7XG4gICAgfVxuICAgIGlmIChhcmdzLnlvdW5nZXN0X21pY3JvcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnlvdW5nZXN0X21pY3JvcyA9IGFyZ3MueW91bmdlc3RfbWljcm9zO1xuICAgIH1cbiAgICBpZiAoYXJncy5hdHRyaWJ1dGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuYXR0cmlidXRlcyA9IGFyZ3MuYXR0cmlidXRlcztcbiAgICB9XG4gICAgaWYgKGFyZ3MuZXJyb3JfZmxhZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmVycm9yX2ZsYWcgPSBhcmdzLmVycm9yX2ZsYWc7XG4gICAgfVxuICB9XG59O1xuY3JvdXRvbl90aHJpZnQuU3BhblJlY29yZC5wcm90b3R5cGUgPSB7fTtcbmNyb3V0b25fdGhyaWZ0LlNwYW5SZWNvcmQucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihpbnB1dCkge1xuICBpbnB1dC5yZWFkU3RydWN0QmVnaW4oKTtcbiAgd2hpbGUgKHRydWUpXG4gIHtcbiAgICB2YXIgcmV0ID0gaW5wdXQucmVhZEZpZWxkQmVnaW4oKTtcbiAgICB2YXIgZm5hbWUgPSByZXQuZm5hbWU7XG4gICAgdmFyIGZ0eXBlID0gcmV0LmZ0eXBlO1xuICAgIHZhciBmaWQgPSByZXQuZmlkO1xuICAgIGlmIChmdHlwZSA9PSBUaHJpZnQuVHlwZS5TVE9QKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc3dpdGNoIChmaWQpXG4gICAge1xuICAgICAgY2FzZSAxOlxuICAgICAgaWYgKGZ0eXBlID09IFRocmlmdC5UeXBlLlNUUklORykge1xuICAgICAgICB0aGlzLnNwYW5fZ3VpZCA9IGlucHV0LnJlYWRTdHJpbmcoKS52YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlucHV0LnNraXAoZnR5cGUpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICBpZiAoZnR5cGUgPT0gVGhyaWZ0LlR5cGUuU1RSSU5HKSB7XG4gICAgICAgIHRoaXMucnVudGltZV9ndWlkID0gaW5wdXQucmVhZFN0cmluZygpLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXQuc2tpcChmdHlwZSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgIGlmIChmdHlwZSA9PSBUaHJpZnQuVHlwZS5TVFJJTkcpIHtcbiAgICAgICAgdGhpcy5zcGFuX25hbWUgPSBpbnB1dC5yZWFkU3RyaW5nKCkudmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dC5za2lwKGZ0eXBlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA0OlxuICAgICAgaWYgKGZ0eXBlID09IFRocmlmdC5UeXBlLkxJU1QpIHtcbiAgICAgICAgdmFyIF9zaXplMTYgPSAwO1xuICAgICAgICB2YXIgX3J0bXAzMjA7XG4gICAgICAgIHRoaXMuam9pbl9pZHMgPSBbXTtcbiAgICAgICAgdmFyIF9ldHlwZTE5ID0gMDtcbiAgICAgICAgX3J0bXAzMjAgPSBpbnB1dC5yZWFkTGlzdEJlZ2luKCk7XG4gICAgICAgIF9ldHlwZTE5ID0gX3J0bXAzMjAuZXR5cGU7XG4gICAgICAgIF9zaXplMTYgPSBfcnRtcDMyMC5zaXplO1xuICAgICAgICBmb3IgKHZhciBfaTIxID0gMDsgX2kyMSA8IF9zaXplMTY7ICsrX2kyMSlcbiAgICAgICAge1xuICAgICAgICAgIHZhciBlbGVtMjIgPSBudWxsO1xuICAgICAgICAgIGVsZW0yMiA9IG5ldyBjcm91dG9uX3RocmlmdC5UcmFjZUpvaW5JZCgpO1xuICAgICAgICAgIGVsZW0yMi5yZWFkKGlucHV0KTtcbiAgICAgICAgICB0aGlzLmpvaW5faWRzLnB1c2goZWxlbTIyKTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dC5yZWFkTGlzdEVuZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXQuc2tpcChmdHlwZSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICAgIGNhc2UgNTpcbiAgICAgIGlmIChmdHlwZSA9PSBUaHJpZnQuVHlwZS5JNjQpIHtcbiAgICAgICAgdGhpcy5vbGRlc3RfbWljcm9zID0gaW5wdXQucmVhZEk2NCgpLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXQuc2tpcChmdHlwZSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICAgIGNhc2UgNjpcbiAgICAgIGlmIChmdHlwZSA9PSBUaHJpZnQuVHlwZS5JNjQpIHtcbiAgICAgICAgdGhpcy55b3VuZ2VzdF9taWNyb3MgPSBpbnB1dC5yZWFkSTY0KCkudmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dC5za2lwKGZ0eXBlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA4OlxuICAgICAgaWYgKGZ0eXBlID09IFRocmlmdC5UeXBlLkxJU1QpIHtcbiAgICAgICAgdmFyIF9zaXplMjMgPSAwO1xuICAgICAgICB2YXIgX3J0bXAzMjc7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IFtdO1xuICAgICAgICB2YXIgX2V0eXBlMjYgPSAwO1xuICAgICAgICBfcnRtcDMyNyA9IGlucHV0LnJlYWRMaXN0QmVnaW4oKTtcbiAgICAgICAgX2V0eXBlMjYgPSBfcnRtcDMyNy5ldHlwZTtcbiAgICAgICAgX3NpemUyMyA9IF9ydG1wMzI3LnNpemU7XG4gICAgICAgIGZvciAodmFyIF9pMjggPSAwOyBfaTI4IDwgX3NpemUyMzsgKytfaTI4KVxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGVsZW0yOSA9IG51bGw7XG4gICAgICAgICAgZWxlbTI5ID0gbmV3IGNyb3V0b25fdGhyaWZ0LktleVZhbHVlKCk7XG4gICAgICAgICAgZWxlbTI5LnJlYWQoaW5wdXQpO1xuICAgICAgICAgIHRoaXMuYXR0cmlidXRlcy5wdXNoKGVsZW0yOSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXQucmVhZExpc3RFbmQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlucHV0LnNraXAoZnR5cGUpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDk6XG4gICAgICBpZiAoZnR5cGUgPT0gVGhyaWZ0LlR5cGUuQk9PTCkge1xuICAgICAgICB0aGlzLmVycm9yX2ZsYWcgPSBpbnB1dC5yZWFkQm9vbCgpLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXQuc2tpcChmdHlwZSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlucHV0LnNraXAoZnR5cGUpO1xuICAgIH1cbiAgICBpbnB1dC5yZWFkRmllbGRFbmQoKTtcbiAgfVxuICBpbnB1dC5yZWFkU3RydWN0RW5kKCk7XG4gIHJldHVybjtcbn07XG5cbmNyb3V0b25fdGhyaWZ0LlNwYW5SZWNvcmQucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24ob3V0cHV0KSB7XG4gIG91dHB1dC53cml0ZVN0cnVjdEJlZ2luKCdTcGFuUmVjb3JkJyk7XG4gIGlmICh0aGlzLnNwYW5fZ3VpZCAhPT0gbnVsbCAmJiB0aGlzLnNwYW5fZ3VpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgb3V0cHV0LndyaXRlRmllbGRCZWdpbignc3Bhbl9ndWlkJywgVGhyaWZ0LlR5cGUuU1RSSU5HLCAxKTtcbiAgICBvdXRwdXQud3JpdGVTdHJpbmcodGhpcy5zcGFuX2d1aWQpO1xuICAgIG91dHB1dC53cml0ZUZpZWxkRW5kKCk7XG4gIH1cbiAgaWYgKHRoaXMucnVudGltZV9ndWlkICE9PSBudWxsICYmIHRoaXMucnVudGltZV9ndWlkICE9PSB1bmRlZmluZWQpIHtcbiAgICBvdXRwdXQud3JpdGVGaWVsZEJlZ2luKCdydW50aW1lX2d1aWQnLCBUaHJpZnQuVHlwZS5TVFJJTkcsIDIpO1xuICAgIG91dHB1dC53cml0ZVN0cmluZyh0aGlzLnJ1bnRpbWVfZ3VpZCk7XG4gICAgb3V0cHV0LndyaXRlRmllbGRFbmQoKTtcbiAgfVxuICBpZiAodGhpcy5zcGFuX25hbWUgIT09IG51bGwgJiYgdGhpcy5zcGFuX25hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIG91dHB1dC53cml0ZUZpZWxkQmVnaW4oJ3NwYW5fbmFtZScsIFRocmlmdC5UeXBlLlNUUklORywgMyk7XG4gICAgb3V0cHV0LndyaXRlU3RyaW5nKHRoaXMuc3Bhbl9uYW1lKTtcbiAgICBvdXRwdXQud3JpdGVGaWVsZEVuZCgpO1xuICB9XG4gIGlmICh0aGlzLmpvaW5faWRzICE9PSBudWxsICYmIHRoaXMuam9pbl9pZHMgIT09IHVuZGVmaW5lZCkge1xuICAgIG91dHB1dC53cml0ZUZpZWxkQmVnaW4oJ2pvaW5faWRzJywgVGhyaWZ0LlR5cGUuTElTVCwgNCk7XG4gICAgb3V0cHV0LndyaXRlTGlzdEJlZ2luKFRocmlmdC5UeXBlLlNUUlVDVCwgdGhpcy5qb2luX2lkcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGl0ZXIzMCBpbiB0aGlzLmpvaW5faWRzKVxuICAgIHtcbiAgICAgIGlmICh0aGlzLmpvaW5faWRzLmhhc093blByb3BlcnR5KGl0ZXIzMCkpXG4gICAgICB7XG4gICAgICAgIGl0ZXIzMCA9IHRoaXMuam9pbl9pZHNbaXRlcjMwXTtcbiAgICAgICAgaXRlcjMwLndyaXRlKG91dHB1dCk7XG4gICAgICB9XG4gICAgfVxuICAgIG91dHB1dC53cml0ZUxpc3RFbmQoKTtcbiAgICBvdXRwdXQud3JpdGVGaWVsZEVuZCgpO1xuICB9XG4gIGlmICh0aGlzLm9sZGVzdF9taWNyb3MgIT09IG51bGwgJiYgdGhpcy5vbGRlc3RfbWljcm9zICE9PSB1bmRlZmluZWQpIHtcbiAgICBvdXRwdXQud3JpdGVGaWVsZEJlZ2luKCdvbGRlc3RfbWljcm9zJywgVGhyaWZ0LlR5cGUuSTY0LCA1KTtcbiAgICBvdXRwdXQud3JpdGVJNjQodGhpcy5vbGRlc3RfbWljcm9zKTtcbiAgICBvdXRwdXQud3JpdGVGaWVsZEVuZCgpO1xuICB9XG4gIGlmICh0aGlzLnlvdW5nZXN0X21pY3JvcyAhPT0gbnVsbCAmJiB0aGlzLnlvdW5nZXN0X21pY3JvcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgb3V0cHV0LndyaXRlRmllbGRCZWdpbigneW91bmdlc3RfbWljcm9zJywgVGhyaWZ0LlR5cGUuSTY0LCA2KTtcbiAgICBvdXRwdXQud3JpdGVJNjQodGhpcy55b3VuZ2VzdF9taWNyb3MpO1xuICAgIG91dHB1dC53cml0ZUZpZWxkRW5kKCk7XG4gIH1cbiAgaWYgKHRoaXMuYXR0cmlidXRlcyAhPT0gbnVsbCAmJiB0aGlzLmF0dHJpYnV0ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIG91dHB1dC53cml0ZUZpZWxkQmVnaW4oJ2F0dHJpYnV0ZXMnLCBUaHJpZnQuVHlwZS5MSVNULCA4KTtcbiAgICBvdXRwdXQud3JpdGVMaXN0QmVnaW4oVGhyaWZ0LlR5cGUuU1RSVUNULCB0aGlzLmF0dHJpYnV0ZXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpdGVyMzEgaW4gdGhpcy5hdHRyaWJ1dGVzKVxuICAgIHtcbiAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoaXRlcjMxKSlcbiAgICAgIHtcbiAgICAgICAgaXRlcjMxID0gdGhpcy5hdHRyaWJ1dGVzW2l0ZXIzMV07XG4gICAgICAgIGl0ZXIzMS53cml0ZShvdXRwdXQpO1xuICAgICAgfVxuICAgIH1cbiAgICBvdXRwdXQud3JpdGVMaXN0RW5kKCk7XG4gICAgb3V0cHV0LndyaXRlRmllbGRFbmQoKTtcbiAgfVxuICBpZiAodGhpcy5lcnJvcl9mbGFnICE9PSBudWxsICYmIHRoaXMuZXJyb3JfZmxhZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgb3V0cHV0LndyaXRlRmllbGRCZWdpbignZXJyb3JfZmxhZycsIFRocmlmdC5UeXBlLkJPT0wsIDkpO1xuICAgIG91dHB1dC53cml0ZUJvb2wodGhpcy5lcnJvcl9mbGFnKTtcbiAgICBvdXRwdXQud3JpdGVGaWVsZEVuZCgpO1xuICB9XG4gIG91dHB1dC53cml0ZUZpZWxkU3RvcCgpO1xuICBvdXRwdXQud3JpdGVTdHJ1Y3RFbmQoKTtcbiAgcmV0dXJuO1xufTtcblxuY3JvdXRvbl90aHJpZnQuQXV0aCA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgdGhpcy5hY2Nlc3NfdG9rZW4gPSBudWxsO1xuICBpZiAoYXJncykge1xuICAgIGlmIChhcmdzLmFjY2Vzc190b2tlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmFjY2Vzc190b2tlbiA9IGFyZ3MuYWNjZXNzX3Rva2VuO1xuICAgIH1cbiAgfVxufTtcbmNyb3V0b25fdGhyaWZ0LkF1dGgucHJvdG90eXBlID0ge307XG5jcm91dG9uX3RocmlmdC5BdXRoLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgaW5wdXQucmVhZFN0cnVjdEJlZ2luKCk7XG4gIHdoaWxlICh0cnVlKVxuICB7XG4gICAgdmFyIHJldCA9IGlucHV0LnJlYWRGaWVsZEJlZ2luKCk7XG4gICAgdmFyIGZuYW1lID0gcmV0LmZuYW1lO1xuICAgIHZhciBmdHlwZSA9IHJldC5mdHlwZTtcbiAgICB2YXIgZmlkID0gcmV0LmZpZDtcbiAgICBpZiAoZnR5cGUgPT0gVGhyaWZ0LlR5cGUuU1RPUCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHN3aXRjaCAoZmlkKVxuICAgIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgIGlmIChmdHlwZSA9PSBUaHJpZnQuVHlwZS5TVFJJTkcpIHtcbiAgICAgICAgdGhpcy5hY2Nlc3NfdG9rZW4gPSBpbnB1dC5yZWFkU3RyaW5nKCkudmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dC5za2lwKGZ0eXBlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAwOlxuICAgICAgICBpbnB1dC5za2lwKGZ0eXBlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnB1dC5za2lwKGZ0eXBlKTtcbiAgICB9XG4gICAgaW5wdXQucmVhZEZpZWxkRW5kKCk7XG4gIH1cbiAgaW5wdXQucmVhZFN0cnVjdEVuZCgpO1xuICByZXR1cm47XG59O1xuXG5jcm91dG9uX3RocmlmdC5BdXRoLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKG91dHB1dCkge1xuICBvdXRwdXQud3JpdGVTdHJ1Y3RCZWdpbignQXV0aCcpO1xuICBpZiAodGhpcy5hY2Nlc3NfdG9rZW4gIT09IG51bGwgJiYgdGhpcy5hY2Nlc3NfdG9rZW4gIT09IHVuZGVmaW5lZCkge1xuICAgIG91dHB1dC53cml0ZUZpZWxkQmVnaW4oJ2FjY2Vzc190b2tlbicsIFRocmlmdC5UeXBlLlNUUklORywgMSk7XG4gICAgb3V0cHV0LndyaXRlU3RyaW5nKHRoaXMuYWNjZXNzX3Rva2VuKTtcbiAgICBvdXRwdXQud3JpdGVGaWVsZEVuZCgpO1xuICB9XG4gIG91dHB1dC53cml0ZUZpZWxkU3RvcCgpO1xuICBvdXRwdXQud3JpdGVTdHJ1Y3RFbmQoKTtcbiAgcmV0dXJuO1xufTtcblxuY3JvdXRvbl90aHJpZnQuVGltaW5nID0gZnVuY3Rpb24oYXJncykge1xuICB0aGlzLnJlY2VpdmVfbWljcm9zID0gbnVsbDtcbiAgdGhpcy50cmFuc21pdF9taWNyb3MgPSBudWxsO1xuICBpZiAoYXJncykge1xuICAgIGlmIChhcmdzLnJlY2VpdmVfbWljcm9zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMucmVjZWl2ZV9taWNyb3MgPSBhcmdzLnJlY2VpdmVfbWljcm9zO1xuICAgIH1cbiAgICBpZiAoYXJncy50cmFuc21pdF9taWNyb3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50cmFuc21pdF9taWNyb3MgPSBhcmdzLnRyYW5zbWl0X21pY3JvcztcbiAgICB9XG4gIH1cbn07XG5jcm91dG9uX3RocmlmdC5UaW1pbmcucHJvdG90eXBlID0ge307XG5jcm91dG9uX3RocmlmdC5UaW1pbmcucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihpbnB1dCkge1xuICBpbnB1dC5yZWFkU3RydWN0QmVnaW4oKTtcbiAgd2hpbGUgKHRydWUpXG4gIHtcbiAgICB2YXIgcmV0ID0gaW5wdXQucmVhZEZpZWxkQmVnaW4oKTtcbiAgICB2YXIgZm5hbWUgPSByZXQuZm5hbWU7XG4gICAgdmFyIGZ0eXBlID0gcmV0LmZ0eXBlO1xuICAgIHZhciBmaWQgPSByZXQuZmlkO1xuICAgIGlmIChmdHlwZSA9PSBUaHJpZnQuVHlwZS5TVE9QKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc3dpdGNoIChmaWQpXG4gICAge1xuICAgICAgY2FzZSAxOlxuICAgICAgaWYgKGZ0eXBlID09IFRocmlmdC5UeXBlLkk2NCkge1xuICAgICAgICB0aGlzLnJlY2VpdmVfbWljcm9zID0gaW5wdXQucmVhZEk2NCgpLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXQuc2tpcChmdHlwZSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgIGlmIChmdHlwZSA9PSBUaHJpZnQuVHlwZS5JNjQpIHtcbiAgICAgICAgdGhpcy50cmFuc21pdF9taWNyb3MgPSBpbnB1dC5yZWFkSTY0KCkudmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dC5za2lwKGZ0eXBlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW5wdXQuc2tpcChmdHlwZSk7XG4gICAgfVxuICAgIGlucHV0LnJlYWRGaWVsZEVuZCgpO1xuICB9XG4gIGlucHV0LnJlYWRTdHJ1Y3RFbmQoKTtcbiAgcmV0dXJuO1xufTtcblxuY3JvdXRvbl90aHJpZnQuVGltaW5nLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKG91dHB1dCkge1xuICBvdXRwdXQud3JpdGVTdHJ1Y3RCZWdpbignVGltaW5nJyk7XG4gIGlmICh0aGlzLnJlY2VpdmVfbWljcm9zICE9PSBudWxsICYmIHRoaXMucmVjZWl2ZV9taWNyb3MgIT09IHVuZGVmaW5lZCkge1xuICAgIG91dHB1dC53cml0ZUZpZWxkQmVnaW4oJ3JlY2VpdmVfbWljcm9zJywgVGhyaWZ0LlR5cGUuSTY0LCAxKTtcbiAgICBvdXRwdXQud3JpdGVJNjQodGhpcy5yZWNlaXZlX21pY3Jvcyk7XG4gICAgb3V0cHV0LndyaXRlRmllbGRFbmQoKTtcbiAgfVxuICBpZiAodGhpcy50cmFuc21pdF9taWNyb3MgIT09IG51bGwgJiYgdGhpcy50cmFuc21pdF9taWNyb3MgIT09IHVuZGVmaW5lZCkge1xuICAgIG91dHB1dC53cml0ZUZpZWxkQmVnaW4oJ3RyYW5zbWl0X21pY3JvcycsIFRocmlmdC5UeXBlLkk2NCwgMik7XG4gICAgb3V0cHV0LndyaXRlSTY0KHRoaXMudHJhbnNtaXRfbWljcm9zKTtcbiAgICBvdXRwdXQud3JpdGVGaWVsZEVuZCgpO1xuICB9XG4gIG91dHB1dC53cml0ZUZpZWxkU3RvcCgpO1xuICBvdXRwdXQud3JpdGVTdHJ1Y3RFbmQoKTtcbiAgcmV0dXJuO1xufTtcblxuY3JvdXRvbl90aHJpZnQuU2FtcGxlQ291bnQgPSBmdW5jdGlvbihhcmdzKSB7XG4gIHRoaXMub2xkZXN0X21pY3JvcyA9IG51bGw7XG4gIHRoaXMueW91bmdlc3RfbWljcm9zID0gbnVsbDtcbiAgdGhpcy5jb3VudCA9IG51bGw7XG4gIGlmIChhcmdzKSB7XG4gICAgaWYgKGFyZ3Mub2xkZXN0X21pY3JvcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm9sZGVzdF9taWNyb3MgPSBhcmdzLm9sZGVzdF9taWNyb3M7XG4gICAgfVxuICAgIGlmIChhcmdzLnlvdW5nZXN0X21pY3JvcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnlvdW5nZXN0X21pY3JvcyA9IGFyZ3MueW91bmdlc3RfbWljcm9zO1xuICAgIH1cbiAgICBpZiAoYXJncy5jb3VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmNvdW50ID0gYXJncy5jb3VudDtcbiAgICB9XG4gIH1cbn07XG5jcm91dG9uX3RocmlmdC5TYW1wbGVDb3VudC5wcm90b3R5cGUgPSB7fTtcbmNyb3V0b25fdGhyaWZ0LlNhbXBsZUNvdW50LnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgaW5wdXQucmVhZFN0cnVjdEJlZ2luKCk7XG4gIHdoaWxlICh0cnVlKVxuICB7XG4gICAgdmFyIHJldCA9IGlucHV0LnJlYWRGaWVsZEJlZ2luKCk7XG4gICAgdmFyIGZuYW1lID0gcmV0LmZuYW1lO1xuICAgIHZhciBmdHlwZSA9IHJldC5mdHlwZTtcbiAgICB2YXIgZmlkID0gcmV0LmZpZDtcbiAgICBpZiAoZnR5cGUgPT0gVGhyaWZ0LlR5cGUuU1RPUCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHN3aXRjaCAoZmlkKVxuICAgIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgIGlmIChmdHlwZSA9PSBUaHJpZnQuVHlwZS5JNjQpIHtcbiAgICAgICAgdGhpcy5vbGRlc3RfbWljcm9zID0gaW5wdXQucmVhZEk2NCgpLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXQuc2tpcChmdHlwZSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgIGlmIChmdHlwZSA9PSBUaHJpZnQuVHlwZS5JNjQpIHtcbiAgICAgICAgdGhpcy55b3VuZ2VzdF9taWNyb3MgPSBpbnB1dC5yZWFkSTY0KCkudmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dC5za2lwKGZ0eXBlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgaWYgKGZ0eXBlID09IFRocmlmdC5UeXBlLkk2NCkge1xuICAgICAgICB0aGlzLmNvdW50ID0gaW5wdXQucmVhZEk2NCgpLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXQuc2tpcChmdHlwZSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlucHV0LnNraXAoZnR5cGUpO1xuICAgIH1cbiAgICBpbnB1dC5yZWFkRmllbGRFbmQoKTtcbiAgfVxuICBpbnB1dC5yZWFkU3RydWN0RW5kKCk7XG4gIHJldHVybjtcbn07XG5cbmNyb3V0b25fdGhyaWZ0LlNhbXBsZUNvdW50LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKG91dHB1dCkge1xuICBvdXRwdXQud3JpdGVTdHJ1Y3RCZWdpbignU2FtcGxlQ291bnQnKTtcbiAgaWYgKHRoaXMub2xkZXN0X21pY3JvcyAhPT0gbnVsbCAmJiB0aGlzLm9sZGVzdF9taWNyb3MgIT09IHVuZGVmaW5lZCkge1xuICAgIG91dHB1dC53cml0ZUZpZWxkQmVnaW4oJ29sZGVzdF9taWNyb3MnLCBUaHJpZnQuVHlwZS5JNjQsIDEpO1xuICAgIG91dHB1dC53cml0ZUk2NCh0aGlzLm9sZGVzdF9taWNyb3MpO1xuICAgIG91dHB1dC53cml0ZUZpZWxkRW5kKCk7XG4gIH1cbiAgaWYgKHRoaXMueW91bmdlc3RfbWljcm9zICE9PSBudWxsICYmIHRoaXMueW91bmdlc3RfbWljcm9zICE9PSB1bmRlZmluZWQpIHtcbiAgICBvdXRwdXQud3JpdGVGaWVsZEJlZ2luKCd5b3VuZ2VzdF9taWNyb3MnLCBUaHJpZnQuVHlwZS5JNjQsIDIpO1xuICAgIG91dHB1dC53cml0ZUk2NCh0aGlzLnlvdW5nZXN0X21pY3Jvcyk7XG4gICAgb3V0cHV0LndyaXRlRmllbGRFbmQoKTtcbiAgfVxuICBpZiAodGhpcy5jb3VudCAhPT0gbnVsbCAmJiB0aGlzLmNvdW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICBvdXRwdXQud3JpdGVGaWVsZEJlZ2luKCdjb3VudCcsIFRocmlmdC5UeXBlLkk2NCwgMyk7XG4gICAgb3V0cHV0LndyaXRlSTY0KHRoaXMuY291bnQpO1xuICAgIG91dHB1dC53cml0ZUZpZWxkRW5kKCk7XG4gIH1cbiAgb3V0cHV0LndyaXRlRmllbGRTdG9wKCk7XG4gIG91dHB1dC53cml0ZVN0cnVjdEVuZCgpO1xuICByZXR1cm47XG59O1xuXG5jcm91dG9uX3RocmlmdC5SZXBvcnRSZXF1ZXN0ID0gZnVuY3Rpb24oYXJncykge1xuICB0aGlzLnJ1bnRpbWUgPSBudWxsO1xuICB0aGlzLnNwYW5fcmVjb3JkcyA9IG51bGw7XG4gIHRoaXMubG9nX3JlY29yZHMgPSBudWxsO1xuICB0aGlzLnRpbWVzdGFtcF9vZmZzZXRfbWljcm9zID0gbnVsbDtcbiAgdGhpcy5vbGRlc3RfbWljcm9zID0gbnVsbDtcbiAgdGhpcy55b3VuZ2VzdF9taWNyb3MgPSBudWxsO1xuICB0aGlzLmNvdW50ZXJzID0gbnVsbDtcbiAgaWYgKGFyZ3MpIHtcbiAgICBpZiAoYXJncy5ydW50aW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMucnVudGltZSA9IGFyZ3MucnVudGltZTtcbiAgICB9XG4gICAgaWYgKGFyZ3Muc3Bhbl9yZWNvcmRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc3Bhbl9yZWNvcmRzID0gYXJncy5zcGFuX3JlY29yZHM7XG4gICAgfVxuICAgIGlmIChhcmdzLmxvZ19yZWNvcmRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMubG9nX3JlY29yZHMgPSBhcmdzLmxvZ19yZWNvcmRzO1xuICAgIH1cbiAgICBpZiAoYXJncy50aW1lc3RhbXBfb2Zmc2V0X21pY3JvcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnRpbWVzdGFtcF9vZmZzZXRfbWljcm9zID0gYXJncy50aW1lc3RhbXBfb2Zmc2V0X21pY3JvcztcbiAgICB9XG4gICAgaWYgKGFyZ3Mub2xkZXN0X21pY3JvcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm9sZGVzdF9taWNyb3MgPSBhcmdzLm9sZGVzdF9taWNyb3M7XG4gICAgfVxuICAgIGlmIChhcmdzLnlvdW5nZXN0X21pY3JvcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnlvdW5nZXN0X21pY3JvcyA9IGFyZ3MueW91bmdlc3RfbWljcm9zO1xuICAgIH1cbiAgICBpZiAoYXJncy5jb3VudGVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmNvdW50ZXJzID0gYXJncy5jb3VudGVycztcbiAgICB9XG4gIH1cbn07XG5jcm91dG9uX3RocmlmdC5SZXBvcnRSZXF1ZXN0LnByb3RvdHlwZSA9IHt9O1xuY3JvdXRvbl90aHJpZnQuUmVwb3J0UmVxdWVzdC5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGlucHV0LnJlYWRTdHJ1Y3RCZWdpbigpO1xuICB3aGlsZSAodHJ1ZSlcbiAge1xuICAgIHZhciByZXQgPSBpbnB1dC5yZWFkRmllbGRCZWdpbigpO1xuICAgIHZhciBmbmFtZSA9IHJldC5mbmFtZTtcbiAgICB2YXIgZnR5cGUgPSByZXQuZnR5cGU7XG4gICAgdmFyIGZpZCA9IHJldC5maWQ7XG4gICAgaWYgKGZ0eXBlID09IFRocmlmdC5UeXBlLlNUT1ApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBzd2l0Y2ggKGZpZClcbiAgICB7XG4gICAgICBjYXNlIDE6XG4gICAgICBpZiAoZnR5cGUgPT0gVGhyaWZ0LlR5cGUuU1RSVUNUKSB7XG4gICAgICAgIHRoaXMucnVudGltZSA9IG5ldyBjcm91dG9uX3RocmlmdC5SdW50aW1lKCk7XG4gICAgICAgIHRoaXMucnVudGltZS5yZWFkKGlucHV0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlucHV0LnNraXAoZnR5cGUpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICBpZiAoZnR5cGUgPT0gVGhyaWZ0LlR5cGUuTElTVCkge1xuICAgICAgICB2YXIgX3NpemUzMiA9IDA7XG4gICAgICAgIHZhciBfcnRtcDMzNjtcbiAgICAgICAgdGhpcy5zcGFuX3JlY29yZHMgPSBbXTtcbiAgICAgICAgdmFyIF9ldHlwZTM1ID0gMDtcbiAgICAgICAgX3J0bXAzMzYgPSBpbnB1dC5yZWFkTGlzdEJlZ2luKCk7XG4gICAgICAgIF9ldHlwZTM1ID0gX3J0bXAzMzYuZXR5cGU7XG4gICAgICAgIF9zaXplMzIgPSBfcnRtcDMzNi5zaXplO1xuICAgICAgICBmb3IgKHZhciBfaTM3ID0gMDsgX2kzNyA8IF9zaXplMzI7ICsrX2kzNylcbiAgICAgICAge1xuICAgICAgICAgIHZhciBlbGVtMzggPSBudWxsO1xuICAgICAgICAgIGVsZW0zOCA9IG5ldyBjcm91dG9uX3RocmlmdC5TcGFuUmVjb3JkKCk7XG4gICAgICAgICAgZWxlbTM4LnJlYWQoaW5wdXQpO1xuICAgICAgICAgIHRoaXMuc3Bhbl9yZWNvcmRzLnB1c2goZWxlbTM4KTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dC5yZWFkTGlzdEVuZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXQuc2tpcChmdHlwZSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICAgIGNhc2UgNDpcbiAgICAgIGlmIChmdHlwZSA9PSBUaHJpZnQuVHlwZS5MSVNUKSB7XG4gICAgICAgIHZhciBfc2l6ZTM5ID0gMDtcbiAgICAgICAgdmFyIF9ydG1wMzQzO1xuICAgICAgICB0aGlzLmxvZ19yZWNvcmRzID0gW107XG4gICAgICAgIHZhciBfZXR5cGU0MiA9IDA7XG4gICAgICAgIF9ydG1wMzQzID0gaW5wdXQucmVhZExpc3RCZWdpbigpO1xuICAgICAgICBfZXR5cGU0MiA9IF9ydG1wMzQzLmV0eXBlO1xuICAgICAgICBfc2l6ZTM5ID0gX3J0bXAzNDMuc2l6ZTtcbiAgICAgICAgZm9yICh2YXIgX2k0NCA9IDA7IF9pNDQgPCBfc2l6ZTM5OyArK19pNDQpXG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgZWxlbTQ1ID0gbnVsbDtcbiAgICAgICAgICBlbGVtNDUgPSBuZXcgY3JvdXRvbl90aHJpZnQuTG9nUmVjb3JkKCk7XG4gICAgICAgICAgZWxlbTQ1LnJlYWQoaW5wdXQpO1xuICAgICAgICAgIHRoaXMubG9nX3JlY29yZHMucHVzaChlbGVtNDUpO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0LnJlYWRMaXN0RW5kKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dC5za2lwKGZ0eXBlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA1OlxuICAgICAgaWYgKGZ0eXBlID09IFRocmlmdC5UeXBlLkk2NCkge1xuICAgICAgICB0aGlzLnRpbWVzdGFtcF9vZmZzZXRfbWljcm9zID0gaW5wdXQucmVhZEk2NCgpLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXQuc2tpcChmdHlwZSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICAgIGNhc2UgNzpcbiAgICAgIGlmIChmdHlwZSA9PSBUaHJpZnQuVHlwZS5JNjQpIHtcbiAgICAgICAgdGhpcy5vbGRlc3RfbWljcm9zID0gaW5wdXQucmVhZEk2NCgpLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXQuc2tpcChmdHlwZSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICAgIGNhc2UgODpcbiAgICAgIGlmIChmdHlwZSA9PSBUaHJpZnQuVHlwZS5JNjQpIHtcbiAgICAgICAgdGhpcy55b3VuZ2VzdF9taWNyb3MgPSBpbnB1dC5yZWFkSTY0KCkudmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dC5za2lwKGZ0eXBlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA5OlxuICAgICAgaWYgKGZ0eXBlID09IFRocmlmdC5UeXBlLkxJU1QpIHtcbiAgICAgICAgdmFyIF9zaXplNDYgPSAwO1xuICAgICAgICB2YXIgX3J0bXAzNTA7XG4gICAgICAgIHRoaXMuY291bnRlcnMgPSBbXTtcbiAgICAgICAgdmFyIF9ldHlwZTQ5ID0gMDtcbiAgICAgICAgX3J0bXAzNTAgPSBpbnB1dC5yZWFkTGlzdEJlZ2luKCk7XG4gICAgICAgIF9ldHlwZTQ5ID0gX3J0bXAzNTAuZXR5cGU7XG4gICAgICAgIF9zaXplNDYgPSBfcnRtcDM1MC5zaXplO1xuICAgICAgICBmb3IgKHZhciBfaTUxID0gMDsgX2k1MSA8IF9zaXplNDY7ICsrX2k1MSlcbiAgICAgICAge1xuICAgICAgICAgIHZhciBlbGVtNTIgPSBudWxsO1xuICAgICAgICAgIGVsZW01MiA9IG5ldyBjcm91dG9uX3RocmlmdC5OYW1lZENvdW50ZXIoKTtcbiAgICAgICAgICBlbGVtNTIucmVhZChpbnB1dCk7XG4gICAgICAgICAgdGhpcy5jb3VudGVycy5wdXNoKGVsZW01Mik7XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXQucmVhZExpc3RFbmQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlucHV0LnNraXAoZnR5cGUpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnB1dC5za2lwKGZ0eXBlKTtcbiAgICB9XG4gICAgaW5wdXQucmVhZEZpZWxkRW5kKCk7XG4gIH1cbiAgaW5wdXQucmVhZFN0cnVjdEVuZCgpO1xuICByZXR1cm47XG59O1xuXG5jcm91dG9uX3RocmlmdC5SZXBvcnRSZXF1ZXN0LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKG91dHB1dCkge1xuICBvdXRwdXQud3JpdGVTdHJ1Y3RCZWdpbignUmVwb3J0UmVxdWVzdCcpO1xuICBpZiAodGhpcy5ydW50aW1lICE9PSBudWxsICYmIHRoaXMucnVudGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgb3V0cHV0LndyaXRlRmllbGRCZWdpbigncnVudGltZScsIFRocmlmdC5UeXBlLlNUUlVDVCwgMSk7XG4gICAgdGhpcy5ydW50aW1lLndyaXRlKG91dHB1dCk7XG4gICAgb3V0cHV0LndyaXRlRmllbGRFbmQoKTtcbiAgfVxuICBpZiAodGhpcy5zcGFuX3JlY29yZHMgIT09IG51bGwgJiYgdGhpcy5zcGFuX3JlY29yZHMgIT09IHVuZGVmaW5lZCkge1xuICAgIG91dHB1dC53cml0ZUZpZWxkQmVnaW4oJ3NwYW5fcmVjb3JkcycsIFRocmlmdC5UeXBlLkxJU1QsIDMpO1xuICAgIG91dHB1dC53cml0ZUxpc3RCZWdpbihUaHJpZnQuVHlwZS5TVFJVQ1QsIHRoaXMuc3Bhbl9yZWNvcmRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaXRlcjUzIGluIHRoaXMuc3Bhbl9yZWNvcmRzKVxuICAgIHtcbiAgICAgIGlmICh0aGlzLnNwYW5fcmVjb3Jkcy5oYXNPd25Qcm9wZXJ0eShpdGVyNTMpKVxuICAgICAge1xuICAgICAgICBpdGVyNTMgPSB0aGlzLnNwYW5fcmVjb3Jkc1tpdGVyNTNdO1xuICAgICAgICBpdGVyNTMud3JpdGUob3V0cHV0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgb3V0cHV0LndyaXRlTGlzdEVuZCgpO1xuICAgIG91dHB1dC53cml0ZUZpZWxkRW5kKCk7XG4gIH1cbiAgaWYgKHRoaXMubG9nX3JlY29yZHMgIT09IG51bGwgJiYgdGhpcy5sb2dfcmVjb3JkcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgb3V0cHV0LndyaXRlRmllbGRCZWdpbignbG9nX3JlY29yZHMnLCBUaHJpZnQuVHlwZS5MSVNULCA0KTtcbiAgICBvdXRwdXQud3JpdGVMaXN0QmVnaW4oVGhyaWZ0LlR5cGUuU1RSVUNULCB0aGlzLmxvZ19yZWNvcmRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaXRlcjU0IGluIHRoaXMubG9nX3JlY29yZHMpXG4gICAge1xuICAgICAgaWYgKHRoaXMubG9nX3JlY29yZHMuaGFzT3duUHJvcGVydHkoaXRlcjU0KSlcbiAgICAgIHtcbiAgICAgICAgaXRlcjU0ID0gdGhpcy5sb2dfcmVjb3Jkc1tpdGVyNTRdO1xuICAgICAgICBpdGVyNTQud3JpdGUob3V0cHV0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgb3V0cHV0LndyaXRlTGlzdEVuZCgpO1xuICAgIG91dHB1dC53cml0ZUZpZWxkRW5kKCk7XG4gIH1cbiAgaWYgKHRoaXMudGltZXN0YW1wX29mZnNldF9taWNyb3MgIT09IG51bGwgJiYgdGhpcy50aW1lc3RhbXBfb2Zmc2V0X21pY3JvcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgb3V0cHV0LndyaXRlRmllbGRCZWdpbigndGltZXN0YW1wX29mZnNldF9taWNyb3MnLCBUaHJpZnQuVHlwZS5JNjQsIDUpO1xuICAgIG91dHB1dC53cml0ZUk2NCh0aGlzLnRpbWVzdGFtcF9vZmZzZXRfbWljcm9zKTtcbiAgICBvdXRwdXQud3JpdGVGaWVsZEVuZCgpO1xuICB9XG4gIGlmICh0aGlzLm9sZGVzdF9taWNyb3MgIT09IG51bGwgJiYgdGhpcy5vbGRlc3RfbWljcm9zICE9PSB1bmRlZmluZWQpIHtcbiAgICBvdXRwdXQud3JpdGVGaWVsZEJlZ2luKCdvbGRlc3RfbWljcm9zJywgVGhyaWZ0LlR5cGUuSTY0LCA3KTtcbiAgICBvdXRwdXQud3JpdGVJNjQodGhpcy5vbGRlc3RfbWljcm9zKTtcbiAgICBvdXRwdXQud3JpdGVGaWVsZEVuZCgpO1xuICB9XG4gIGlmICh0aGlzLnlvdW5nZXN0X21pY3JvcyAhPT0gbnVsbCAmJiB0aGlzLnlvdW5nZXN0X21pY3JvcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgb3V0cHV0LndyaXRlRmllbGRCZWdpbigneW91bmdlc3RfbWljcm9zJywgVGhyaWZ0LlR5cGUuSTY0LCA4KTtcbiAgICBvdXRwdXQud3JpdGVJNjQodGhpcy55b3VuZ2VzdF9taWNyb3MpO1xuICAgIG91dHB1dC53cml0ZUZpZWxkRW5kKCk7XG4gIH1cbiAgaWYgKHRoaXMuY291bnRlcnMgIT09IG51bGwgJiYgdGhpcy5jb3VudGVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgb3V0cHV0LndyaXRlRmllbGRCZWdpbignY291bnRlcnMnLCBUaHJpZnQuVHlwZS5MSVNULCA5KTtcbiAgICBvdXRwdXQud3JpdGVMaXN0QmVnaW4oVGhyaWZ0LlR5cGUuU1RSVUNULCB0aGlzLmNvdW50ZXJzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaXRlcjU1IGluIHRoaXMuY291bnRlcnMpXG4gICAge1xuICAgICAgaWYgKHRoaXMuY291bnRlcnMuaGFzT3duUHJvcGVydHkoaXRlcjU1KSlcbiAgICAgIHtcbiAgICAgICAgaXRlcjU1ID0gdGhpcy5jb3VudGVyc1tpdGVyNTVdO1xuICAgICAgICBpdGVyNTUud3JpdGUob3V0cHV0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgb3V0cHV0LndyaXRlTGlzdEVuZCgpO1xuICAgIG91dHB1dC53cml0ZUZpZWxkRW5kKCk7XG4gIH1cbiAgb3V0cHV0LndyaXRlRmllbGRTdG9wKCk7XG4gIG91dHB1dC53cml0ZVN0cnVjdEVuZCgpO1xuICByZXR1cm47XG59O1xuXG5jcm91dG9uX3RocmlmdC5Db21tYW5kID0gZnVuY3Rpb24oYXJncykge1xuICB0aGlzLmRpc2FibGUgPSBudWxsO1xuICBpZiAoYXJncykge1xuICAgIGlmIChhcmdzLmRpc2FibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5kaXNhYmxlID0gYXJncy5kaXNhYmxlO1xuICAgIH1cbiAgfVxufTtcbmNyb3V0b25fdGhyaWZ0LkNvbW1hbmQucHJvdG90eXBlID0ge307XG5jcm91dG9uX3RocmlmdC5Db21tYW5kLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgaW5wdXQucmVhZFN0cnVjdEJlZ2luKCk7XG4gIHdoaWxlICh0cnVlKVxuICB7XG4gICAgdmFyIHJldCA9IGlucHV0LnJlYWRGaWVsZEJlZ2luKCk7XG4gICAgdmFyIGZuYW1lID0gcmV0LmZuYW1lO1xuICAgIHZhciBmdHlwZSA9IHJldC5mdHlwZTtcbiAgICB2YXIgZmlkID0gcmV0LmZpZDtcbiAgICBpZiAoZnR5cGUgPT0gVGhyaWZ0LlR5cGUuU1RPUCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHN3aXRjaCAoZmlkKVxuICAgIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgIGlmIChmdHlwZSA9PSBUaHJpZnQuVHlwZS5CT09MKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZSA9IGlucHV0LnJlYWRCb29sKCkudmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dC5za2lwKGZ0eXBlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAwOlxuICAgICAgICBpbnB1dC5za2lwKGZ0eXBlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnB1dC5za2lwKGZ0eXBlKTtcbiAgICB9XG4gICAgaW5wdXQucmVhZEZpZWxkRW5kKCk7XG4gIH1cbiAgaW5wdXQucmVhZFN0cnVjdEVuZCgpO1xuICByZXR1cm47XG59O1xuXG5jcm91dG9uX3RocmlmdC5Db21tYW5kLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKG91dHB1dCkge1xuICBvdXRwdXQud3JpdGVTdHJ1Y3RCZWdpbignQ29tbWFuZCcpO1xuICBpZiAodGhpcy5kaXNhYmxlICE9PSBudWxsICYmIHRoaXMuZGlzYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgb3V0cHV0LndyaXRlRmllbGRCZWdpbignZGlzYWJsZScsIFRocmlmdC5UeXBlLkJPT0wsIDEpO1xuICAgIG91dHB1dC53cml0ZUJvb2wodGhpcy5kaXNhYmxlKTtcbiAgICBvdXRwdXQud3JpdGVGaWVsZEVuZCgpO1xuICB9XG4gIG91dHB1dC53cml0ZUZpZWxkU3RvcCgpO1xuICBvdXRwdXQud3JpdGVTdHJ1Y3RFbmQoKTtcbiAgcmV0dXJuO1xufTtcblxuY3JvdXRvbl90aHJpZnQuUmVwb3J0UmVzcG9uc2UgPSBmdW5jdGlvbihhcmdzKSB7XG4gIHRoaXMuY29tbWFuZHMgPSBudWxsO1xuICB0aGlzLnRpbWluZyA9IG51bGw7XG4gIHRoaXMuZXJyb3JzID0gbnVsbDtcbiAgaWYgKGFyZ3MpIHtcbiAgICBpZiAoYXJncy5jb21tYW5kcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmNvbW1hbmRzID0gYXJncy5jb21tYW5kcztcbiAgICB9XG4gICAgaWYgKGFyZ3MudGltaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMudGltaW5nID0gYXJncy50aW1pbmc7XG4gICAgfVxuICAgIGlmIChhcmdzLmVycm9ycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmVycm9ycyA9IGFyZ3MuZXJyb3JzO1xuICAgIH1cbiAgfVxufTtcbmNyb3V0b25fdGhyaWZ0LlJlcG9ydFJlc3BvbnNlLnByb3RvdHlwZSA9IHt9O1xuY3JvdXRvbl90aHJpZnQuUmVwb3J0UmVzcG9uc2UucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihpbnB1dCkge1xuICBpbnB1dC5yZWFkU3RydWN0QmVnaW4oKTtcbiAgd2hpbGUgKHRydWUpXG4gIHtcbiAgICB2YXIgcmV0ID0gaW5wdXQucmVhZEZpZWxkQmVnaW4oKTtcbiAgICB2YXIgZm5hbWUgPSByZXQuZm5hbWU7XG4gICAgdmFyIGZ0eXBlID0gcmV0LmZ0eXBlO1xuICAgIHZhciBmaWQgPSByZXQuZmlkO1xuICAgIGlmIChmdHlwZSA9PSBUaHJpZnQuVHlwZS5TVE9QKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc3dpdGNoIChmaWQpXG4gICAge1xuICAgICAgY2FzZSAxOlxuICAgICAgaWYgKGZ0eXBlID09IFRocmlmdC5UeXBlLkxJU1QpIHtcbiAgICAgICAgdmFyIF9zaXplNTYgPSAwO1xuICAgICAgICB2YXIgX3J0bXAzNjA7XG4gICAgICAgIHRoaXMuY29tbWFuZHMgPSBbXTtcbiAgICAgICAgdmFyIF9ldHlwZTU5ID0gMDtcbiAgICAgICAgX3J0bXAzNjAgPSBpbnB1dC5yZWFkTGlzdEJlZ2luKCk7XG4gICAgICAgIF9ldHlwZTU5ID0gX3J0bXAzNjAuZXR5cGU7XG4gICAgICAgIF9zaXplNTYgPSBfcnRtcDM2MC5zaXplO1xuICAgICAgICBmb3IgKHZhciBfaTYxID0gMDsgX2k2MSA8IF9zaXplNTY7ICsrX2k2MSlcbiAgICAgICAge1xuICAgICAgICAgIHZhciBlbGVtNjIgPSBudWxsO1xuICAgICAgICAgIGVsZW02MiA9IG5ldyBjcm91dG9uX3RocmlmdC5Db21tYW5kKCk7XG4gICAgICAgICAgZWxlbTYyLnJlYWQoaW5wdXQpO1xuICAgICAgICAgIHRoaXMuY29tbWFuZHMucHVzaChlbGVtNjIpO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0LnJlYWRMaXN0RW5kKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dC5za2lwKGZ0eXBlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgaWYgKGZ0eXBlID09IFRocmlmdC5UeXBlLlNUUlVDVCkge1xuICAgICAgICB0aGlzLnRpbWluZyA9IG5ldyBjcm91dG9uX3RocmlmdC5UaW1pbmcoKTtcbiAgICAgICAgdGhpcy50aW1pbmcucmVhZChpbnB1dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dC5za2lwKGZ0eXBlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgaWYgKGZ0eXBlID09IFRocmlmdC5UeXBlLkxJU1QpIHtcbiAgICAgICAgdmFyIF9zaXplNjMgPSAwO1xuICAgICAgICB2YXIgX3J0bXAzNjc7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICAgIHZhciBfZXR5cGU2NiA9IDA7XG4gICAgICAgIF9ydG1wMzY3ID0gaW5wdXQucmVhZExpc3RCZWdpbigpO1xuICAgICAgICBfZXR5cGU2NiA9IF9ydG1wMzY3LmV0eXBlO1xuICAgICAgICBfc2l6ZTYzID0gX3J0bXAzNjcuc2l6ZTtcbiAgICAgICAgZm9yICh2YXIgX2k2OCA9IDA7IF9pNjggPCBfc2l6ZTYzOyArK19pNjgpXG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgZWxlbTY5ID0gbnVsbDtcbiAgICAgICAgICBlbGVtNjkgPSBpbnB1dC5yZWFkU3RyaW5nKCkudmFsdWU7XG4gICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChlbGVtNjkpO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0LnJlYWRMaXN0RW5kKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dC5za2lwKGZ0eXBlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW5wdXQuc2tpcChmdHlwZSk7XG4gICAgfVxuICAgIGlucHV0LnJlYWRGaWVsZEVuZCgpO1xuICB9XG4gIGlucHV0LnJlYWRTdHJ1Y3RFbmQoKTtcbiAgcmV0dXJuO1xufTtcblxuY3JvdXRvbl90aHJpZnQuUmVwb3J0UmVzcG9uc2UucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24ob3V0cHV0KSB7XG4gIG91dHB1dC53cml0ZVN0cnVjdEJlZ2luKCdSZXBvcnRSZXNwb25zZScpO1xuICBpZiAodGhpcy5jb21tYW5kcyAhPT0gbnVsbCAmJiB0aGlzLmNvbW1hbmRzICE9PSB1bmRlZmluZWQpIHtcbiAgICBvdXRwdXQud3JpdGVGaWVsZEJlZ2luKCdjb21tYW5kcycsIFRocmlmdC5UeXBlLkxJU1QsIDEpO1xuICAgIG91dHB1dC53cml0ZUxpc3RCZWdpbihUaHJpZnQuVHlwZS5TVFJVQ1QsIHRoaXMuY29tbWFuZHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpdGVyNzAgaW4gdGhpcy5jb21tYW5kcylcbiAgICB7XG4gICAgICBpZiAodGhpcy5jb21tYW5kcy5oYXNPd25Qcm9wZXJ0eShpdGVyNzApKVxuICAgICAge1xuICAgICAgICBpdGVyNzAgPSB0aGlzLmNvbW1hbmRzW2l0ZXI3MF07XG4gICAgICAgIGl0ZXI3MC53cml0ZShvdXRwdXQpO1xuICAgICAgfVxuICAgIH1cbiAgICBvdXRwdXQud3JpdGVMaXN0RW5kKCk7XG4gICAgb3V0cHV0LndyaXRlRmllbGRFbmQoKTtcbiAgfVxuICBpZiAodGhpcy50aW1pbmcgIT09IG51bGwgJiYgdGhpcy50aW1pbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIG91dHB1dC53cml0ZUZpZWxkQmVnaW4oJ3RpbWluZycsIFRocmlmdC5UeXBlLlNUUlVDVCwgMik7XG4gICAgdGhpcy50aW1pbmcud3JpdGUob3V0cHV0KTtcbiAgICBvdXRwdXQud3JpdGVGaWVsZEVuZCgpO1xuICB9XG4gIGlmICh0aGlzLmVycm9ycyAhPT0gbnVsbCAmJiB0aGlzLmVycm9ycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgb3V0cHV0LndyaXRlRmllbGRCZWdpbignZXJyb3JzJywgVGhyaWZ0LlR5cGUuTElTVCwgMyk7XG4gICAgb3V0cHV0LndyaXRlTGlzdEJlZ2luKFRocmlmdC5UeXBlLlNUUklORywgdGhpcy5lcnJvcnMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpdGVyNzEgaW4gdGhpcy5lcnJvcnMpXG4gICAge1xuICAgICAgaWYgKHRoaXMuZXJyb3JzLmhhc093blByb3BlcnR5KGl0ZXI3MSkpXG4gICAgICB7XG4gICAgICAgIGl0ZXI3MSA9IHRoaXMuZXJyb3JzW2l0ZXI3MV07XG4gICAgICAgIG91dHB1dC53cml0ZVN0cmluZyhpdGVyNzEpO1xuICAgICAgfVxuICAgIH1cbiAgICBvdXRwdXQud3JpdGVMaXN0RW5kKCk7XG4gICAgb3V0cHV0LndyaXRlRmllbGRFbmQoKTtcbiAgfVxuICBvdXRwdXQud3JpdGVGaWVsZFN0b3AoKTtcbiAgb3V0cHV0LndyaXRlU3RydWN0RW5kKCk7XG4gIHJldHVybjtcbn07XG5cblxuLy9cbi8vIEF1dG9nZW5lcmF0ZWQgYnkgVGhyaWZ0IENvbXBpbGVyICgwLjkuMilcbi8vXG4vLyBETyBOT1QgRURJVCBVTkxFU1MgWU9VIEFSRSBTVVJFIFRIQVQgWU9VIEtOT1cgV0hBVCBZT1UgQVJFIERPSU5HXG4vL1xuXG5cbi8vSEVMUEVSIEZVTkNUSU9OUyBBTkQgU1RSVUNUVVJFU1xuXG5jcm91dG9uX3RocmlmdC5SZXBvcnRpbmdTZXJ2aWNlX1JlcG9ydF9hcmdzID0gZnVuY3Rpb24oYXJncykge1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLnJlcXVlc3QgPSBudWxsO1xuICBpZiAoYXJncykge1xuICAgIGlmIChhcmdzLmF1dGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5hdXRoID0gYXJncy5hdXRoO1xuICAgIH1cbiAgICBpZiAoYXJncy5yZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMucmVxdWVzdCA9IGFyZ3MucmVxdWVzdDtcbiAgICB9XG4gIH1cbn07XG5jcm91dG9uX3RocmlmdC5SZXBvcnRpbmdTZXJ2aWNlX1JlcG9ydF9hcmdzLnByb3RvdHlwZSA9IHt9O1xuY3JvdXRvbl90aHJpZnQuUmVwb3J0aW5nU2VydmljZV9SZXBvcnRfYXJncy5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGlucHV0LnJlYWRTdHJ1Y3RCZWdpbigpO1xuICB3aGlsZSAodHJ1ZSlcbiAge1xuICAgIHZhciByZXQgPSBpbnB1dC5yZWFkRmllbGRCZWdpbigpO1xuICAgIHZhciBmbmFtZSA9IHJldC5mbmFtZTtcbiAgICB2YXIgZnR5cGUgPSByZXQuZnR5cGU7XG4gICAgdmFyIGZpZCA9IHJldC5maWQ7XG4gICAgaWYgKGZ0eXBlID09IFRocmlmdC5UeXBlLlNUT1ApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBzd2l0Y2ggKGZpZClcbiAgICB7XG4gICAgICBjYXNlIDE6XG4gICAgICBpZiAoZnR5cGUgPT0gVGhyaWZ0LlR5cGUuU1RSVUNUKSB7XG4gICAgICAgIHRoaXMuYXV0aCA9IG5ldyBjcm91dG9uX3RocmlmdC5BdXRoKCk7XG4gICAgICAgIHRoaXMuYXV0aC5yZWFkKGlucHV0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlucHV0LnNraXAoZnR5cGUpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICBpZiAoZnR5cGUgPT0gVGhyaWZ0LlR5cGUuU1RSVUNUKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdCA9IG5ldyBjcm91dG9uX3RocmlmdC5SZXBvcnRSZXF1ZXN0KCk7XG4gICAgICAgIHRoaXMucmVxdWVzdC5yZWFkKGlucHV0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlucHV0LnNraXAoZnR5cGUpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnB1dC5za2lwKGZ0eXBlKTtcbiAgICB9XG4gICAgaW5wdXQucmVhZEZpZWxkRW5kKCk7XG4gIH1cbiAgaW5wdXQucmVhZFN0cnVjdEVuZCgpO1xuICByZXR1cm47XG59O1xuXG5jcm91dG9uX3RocmlmdC5SZXBvcnRpbmdTZXJ2aWNlX1JlcG9ydF9hcmdzLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKG91dHB1dCkge1xuICBvdXRwdXQud3JpdGVTdHJ1Y3RCZWdpbignUmVwb3J0aW5nU2VydmljZV9SZXBvcnRfYXJncycpO1xuICBpZiAodGhpcy5hdXRoICE9PSBudWxsICYmIHRoaXMuYXV0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgb3V0cHV0LndyaXRlRmllbGRCZWdpbignYXV0aCcsIFRocmlmdC5UeXBlLlNUUlVDVCwgMSk7XG4gICAgdGhpcy5hdXRoLndyaXRlKG91dHB1dCk7XG4gICAgb3V0cHV0LndyaXRlRmllbGRFbmQoKTtcbiAgfVxuICBpZiAodGhpcy5yZXF1ZXN0ICE9PSBudWxsICYmIHRoaXMucmVxdWVzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgb3V0cHV0LndyaXRlRmllbGRCZWdpbigncmVxdWVzdCcsIFRocmlmdC5UeXBlLlNUUlVDVCwgMik7XG4gICAgdGhpcy5yZXF1ZXN0LndyaXRlKG91dHB1dCk7XG4gICAgb3V0cHV0LndyaXRlRmllbGRFbmQoKTtcbiAgfVxuICBvdXRwdXQud3JpdGVGaWVsZFN0b3AoKTtcbiAgb3V0cHV0LndyaXRlU3RydWN0RW5kKCk7XG4gIHJldHVybjtcbn07XG5cbmNyb3V0b25fdGhyaWZ0LlJlcG9ydGluZ1NlcnZpY2VfUmVwb3J0X3Jlc3VsdCA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgdGhpcy5zdWNjZXNzID0gbnVsbDtcbiAgaWYgKGFyZ3MpIHtcbiAgICBpZiAoYXJncy5zdWNjZXNzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc3VjY2VzcyA9IGFyZ3Muc3VjY2VzcztcbiAgICB9XG4gIH1cbn07XG5jcm91dG9uX3RocmlmdC5SZXBvcnRpbmdTZXJ2aWNlX1JlcG9ydF9yZXN1bHQucHJvdG90eXBlID0ge307XG5jcm91dG9uX3RocmlmdC5SZXBvcnRpbmdTZXJ2aWNlX1JlcG9ydF9yZXN1bHQucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihpbnB1dCkge1xuICBpbnB1dC5yZWFkU3RydWN0QmVnaW4oKTtcbiAgd2hpbGUgKHRydWUpXG4gIHtcbiAgICB2YXIgcmV0ID0gaW5wdXQucmVhZEZpZWxkQmVnaW4oKTtcbiAgICB2YXIgZm5hbWUgPSByZXQuZm5hbWU7XG4gICAgdmFyIGZ0eXBlID0gcmV0LmZ0eXBlO1xuICAgIHZhciBmaWQgPSByZXQuZmlkO1xuICAgIGlmIChmdHlwZSA9PSBUaHJpZnQuVHlwZS5TVE9QKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc3dpdGNoIChmaWQpXG4gICAge1xuICAgICAgY2FzZSAwOlxuICAgICAgaWYgKGZ0eXBlID09IFRocmlmdC5UeXBlLlNUUlVDVCkge1xuICAgICAgICB0aGlzLnN1Y2Nlc3MgPSBuZXcgY3JvdXRvbl90aHJpZnQuUmVwb3J0UmVzcG9uc2UoKTtcbiAgICAgICAgdGhpcy5zdWNjZXNzLnJlYWQoaW5wdXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXQuc2tpcChmdHlwZSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgaW5wdXQuc2tpcChmdHlwZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW5wdXQuc2tpcChmdHlwZSk7XG4gICAgfVxuICAgIGlucHV0LnJlYWRGaWVsZEVuZCgpO1xuICB9XG4gIGlucHV0LnJlYWRTdHJ1Y3RFbmQoKTtcbiAgcmV0dXJuO1xufTtcblxuY3JvdXRvbl90aHJpZnQuUmVwb3J0aW5nU2VydmljZV9SZXBvcnRfcmVzdWx0LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKG91dHB1dCkge1xuICBvdXRwdXQud3JpdGVTdHJ1Y3RCZWdpbignUmVwb3J0aW5nU2VydmljZV9SZXBvcnRfcmVzdWx0Jyk7XG4gIGlmICh0aGlzLnN1Y2Nlc3MgIT09IG51bGwgJiYgdGhpcy5zdWNjZXNzICE9PSB1bmRlZmluZWQpIHtcbiAgICBvdXRwdXQud3JpdGVGaWVsZEJlZ2luKCdzdWNjZXNzJywgVGhyaWZ0LlR5cGUuU1RSVUNULCAwKTtcbiAgICB0aGlzLnN1Y2Nlc3Mud3JpdGUob3V0cHV0KTtcbiAgICBvdXRwdXQud3JpdGVGaWVsZEVuZCgpO1xuICB9XG4gIG91dHB1dC53cml0ZUZpZWxkU3RvcCgpO1xuICBvdXRwdXQud3JpdGVTdHJ1Y3RFbmQoKTtcbiAgcmV0dXJuO1xufTtcblxuY3JvdXRvbl90aHJpZnQuUmVwb3J0aW5nU2VydmljZUNsaWVudCA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQpIHtcbiAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgdGhpcy5vdXRwdXQgPSAoIW91dHB1dCkgPyBpbnB1dCA6IG91dHB1dDtcbiAgICB0aGlzLnNlcWlkID0gMDtcbn07XG5jcm91dG9uX3RocmlmdC5SZXBvcnRpbmdTZXJ2aWNlQ2xpZW50LnByb3RvdHlwZSA9IHt9O1xuY3JvdXRvbl90aHJpZnQuUmVwb3J0aW5nU2VydmljZUNsaWVudC5wcm90b3R5cGUuUmVwb3J0ID0gZnVuY3Rpb24oYXV0aCwgcmVxdWVzdCwgY2FsbGJhY2spIHtcbiAgdGhpcy5zZW5kX1JlcG9ydChhdXRoLCByZXF1ZXN0LCBjYWxsYmFjayk7IFxuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMucmVjdl9SZXBvcnQoKTtcbiAgfVxufTtcblxuY3JvdXRvbl90aHJpZnQuUmVwb3J0aW5nU2VydmljZUNsaWVudC5wcm90b3R5cGUuc2VuZF9SZXBvcnQgPSBmdW5jdGlvbihhdXRoLCByZXF1ZXN0LCBjYWxsYmFjaykge1xuICB0aGlzLm91dHB1dC53cml0ZU1lc3NhZ2VCZWdpbignUmVwb3J0JywgVGhyaWZ0Lk1lc3NhZ2VUeXBlLkNBTEwsIHRoaXMuc2VxaWQpO1xuICB2YXIgYXJncyA9IG5ldyBjcm91dG9uX3RocmlmdC5SZXBvcnRpbmdTZXJ2aWNlX1JlcG9ydF9hcmdzKCk7XG4gIGFyZ3MuYXV0aCA9IGF1dGg7XG4gIGFyZ3MucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIGFyZ3Mud3JpdGUodGhpcy5vdXRwdXQpO1xuICB0aGlzLm91dHB1dC53cml0ZU1lc3NhZ2VFbmQoKTtcbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMub3V0cHV0LmdldFRyYW5zcG9ydCgpLmZsdXNoKHRydWUsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBzZWxmLnJlY3ZfUmVwb3J0KCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlc3VsdCA9IGU7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLm91dHB1dC5nZXRUcmFuc3BvcnQoKS5mbHVzaCgpO1xuICB9XG59O1xuXG5jcm91dG9uX3RocmlmdC5SZXBvcnRpbmdTZXJ2aWNlQ2xpZW50LnByb3RvdHlwZS5yZWN2X1JlcG9ydCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmV0ID0gdGhpcy5pbnB1dC5yZWFkTWVzc2FnZUJlZ2luKCk7XG4gIHZhciBmbmFtZSA9IHJldC5mbmFtZTtcbiAgdmFyIG10eXBlID0gcmV0Lm10eXBlO1xuICB2YXIgcnNlcWlkID0gcmV0LnJzZXFpZDtcbiAgaWYgKG10eXBlID09IFRocmlmdC5NZXNzYWdlVHlwZS5FWENFUFRJT04pIHtcbiAgICB2YXIgeCA9IG5ldyBUaHJpZnQuVEFwcGxpY2F0aW9uRXhjZXB0aW9uKCk7XG4gICAgeC5yZWFkKHRoaXMuaW5wdXQpO1xuICAgIHRoaXMuaW5wdXQucmVhZE1lc3NhZ2VFbmQoKTtcbiAgICB0aHJvdyB4O1xuICB9XG4gIHZhciByZXN1bHQgPSBuZXcgY3JvdXRvbl90aHJpZnQuUmVwb3J0aW5nU2VydmljZV9SZXBvcnRfcmVzdWx0KCk7XG4gIHJlc3VsdC5yZWFkKHRoaXMuaW5wdXQpO1xuICB0aGlzLmlucHV0LnJlYWRNZXNzYWdlRW5kKCk7XG5cbiAgaWYgKG51bGwgIT09IHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgcmV0dXJuIHJlc3VsdC5zdWNjZXNzO1xuICB9XG4gIHRocm93ICdSZXBvcnQgZmFpbGVkOiB1bmtub3duIHJlc3VsdCc7XG59O1xuXG4vKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKmpzaGludCBldmlsOnRydWUqL1xuXG4vKipcbiAqIFRoZSBUaHJpZnQgbmFtZXNwYWNlIGhvdXNlcyB0aGUgQXBhY2hlIFRocmlmdCBKYXZhU2NyaXB0IGxpYnJhcnkgXG4gKiBlbGVtZW50cyBwcm92aWRpbmcgSmF2YVNjcmlwdCBiaW5kaW5ncyBmb3IgdGhlIEFwYWNoZSBUaHJpZnQgUlBDIFxuICogc3lzdGVtLiBFbmQgdXNlcnMgd2lsbCB0eXBpY2FsbHkgb25seSBkaXJlY3RseSBtYWtlIHVzZSBvZiB0aGUgXG4gKiBUcmFuc3BvcnQgKFRYSFJUcmFuc3BvcnQvVFdlYlNvY2tldFRyYW5zcG9ydCkgYW5kIFByb3RvY29sIFxuICogKFRKU09OUFJvdG9jb2wvVEJpbmFyeVByb3RvY29sKSBjb25zdHJ1Y3RvcnMuXG4gKiBcbiAqIE9iamVjdCBtZXRob2RzIGJlZ2lubmluZyB3aXRoIGEgX18gKGUuZy4gX19vbk9wZW4oKSkgYXJlIGludGVybmFsIFxuICogYW5kIHNob3VsZCBub3QgYmUgY2FsbGVkIG91dHNpZGUgb2YgdGhlIG9iamVjdCdzIG93biBtZXRob2RzLlxuICogXG4gKiBUaGlzIGxpYnJhcnkgY3JlYXRlcyBvbmUgZ2xvYmFsIG9iamVjdDogVGhyaWZ0XG4gKiBDb2RlIGluIHRoaXMgbGlicmFyeSBtdXN0IG5ldmVyIGNyZWF0ZSBhZGRpdGlvbmFsIGdsb2JhbCBpZGVudGlmaWVycyxcbiAqIGFsbCBmZWF0dXJlcyBtdXN0IGJlIHNjb3BlZCB3aXRoaW4gdGhlIFRocmlmdCBuYW1lc3BhY2UuXG4gKiBAbmFtZXNwYWNlXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciB0cmFuc3BvcnQgPSBuZXcgVGhyaWZ0LlRyYW5zcG9ydChcImh0dHA6Ly9sb2NhbGhvc3Q6ODU4NVwiKTtcbiAqICAgICB2YXIgcHJvdG9jb2wgID0gbmV3IFRocmlmdC5Qcm90b2NvbCh0cmFuc3BvcnQpO1xuICogICAgIHZhciBjbGllbnQgPSBuZXcgTXlUaHJpZnRTdmNDbGllbnQocHJvdG9jb2wpO1xuICogICAgIHZhciByZXN1bHQgPSBjbGllbnQuTXlNZXRob2QoKTtcbiAqL1xudmFyIFRocmlmdCA9IHtcbiAgICAvKipcbiAgICAgKiBUaHJpZnQgSmF2YVNjcmlwdCBsaWJyYXJ5IHZlcnNpb24uXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQGNvbnN0IHtzdHJpbmd9IFZlcnNpb25cbiAgICAgKiBAbWVtYmVyb2YgVGhyaWZ0XG4gICAgICovXG4gICAgVmVyc2lvbjogJzEuMC4wLWRldicsXG5cbiAgICAvKipcbiAgICAgKiBUaHJpZnQgSURMIHR5cGUgc3RyaW5nIHRvIElkIG1hcHBpbmcuXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9ICBTVE9QICAgLSBFbmQgb2YgYSBzZXQgb2YgZmllbGRzLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgVk9JRCAgIC0gTm8gdmFsdWUgKG9ubHkgbGVnYWwgZm9yIHJldHVybiB0eXBlcykuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9ICBCT09MICAgLSBUcnVlL0ZhbHNlIGludGVnZXIuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9ICBCWVRFICAgLSBTaWduZWQgOCBiaXQgaW50ZWdlci5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gIEkwOCAgICAtIFNpZ25lZCA4IGJpdCBpbnRlZ2VyLiAgICAgXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9ICBET1VCTEUgLSA2NCBiaXQgSUVFRSA4NTQgZmxvYXRpbmcgcG9pbnQuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9ICBJMTYgICAgLSBTaWduZWQgMTYgYml0IGludGVnZXIuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9ICBJMzIgICAgLSBTaWduZWQgMzIgYml0IGludGVnZXIuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9ICBJNjQgICAgLSBTaWduZWQgNjQgYml0IGludGVnZXIuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9ICBTVFJJTkcgLSBBcnJheSBvZiBieXRlcyByZXByZXNlbnRpbmcgYSBzdHJpbmcgb2YgY2hhcmFjdGVycy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gIFVURjcgICAtIEFycmF5IG9mIGJ5dGVzIHJlcHJlc2VudGluZyBhIHN0cmluZyBvZiBVVEY3IGVuY29kZWQgY2hhcmFjdGVycy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gIFNUUlVDVCAtIEEgbXVsdGlmaWVsZCB0eXBlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgTUFQICAgIC0gQSBjb2xsZWN0aW9uIHR5cGUgKG1hcC9hc3NvY2lhdGl2ZS1hcnJheS9kaWN0aW9uYXJ5KS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gIFNFVCAgICAtIEEgY29sbGVjdGlvbiB0eXBlICh1bm9yZGVyZWQgYW5kIHdpdGhvdXQgcmVwZWF0ZWQgdmFsdWVzKS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gIExJU1QgICAtIEEgY29sbGVjdGlvbiB0eXBlICh1bm9yZGVyZWQpLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgVVRGOCAgIC0gQXJyYXkgb2YgYnl0ZXMgcmVwcmVzZW50aW5nIGEgc3RyaW5nIG9mIFVURjggZW5jb2RlZCBjaGFyYWN0ZXJzLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgVVRGMTYgIC0gQXJyYXkgb2YgYnl0ZXMgcmVwcmVzZW50aW5nIGEgc3RyaW5nIG9mIFVURjE2IGVuY29kZWQgY2hhcmFjdGVycy5cbiAgICAgKi9cbiAgICBUeXBlOiB7XG4gICAgICAgICdTVE9QJyA6IDAsXG4gICAgICAgICdWT0lEJyA6IDEsXG4gICAgICAgICdCT09MJyA6IDIsXG4gICAgICAgICdCWVRFJyA6IDMsXG4gICAgICAgICdJMDgnIDogMyxcbiAgICAgICAgJ0RPVUJMRScgOiA0LFxuICAgICAgICAnSTE2JyA6IDYsXG4gICAgICAgICdJMzInIDogOCxcbiAgICAgICAgJ0k2NCcgOiAxMCxcbiAgICAgICAgJ1NUUklORycgOiAxMSxcbiAgICAgICAgJ1VURjcnIDogMTEsXG4gICAgICAgICdTVFJVQ1QnIDogMTIsXG4gICAgICAgICdNQVAnIDogMTMsXG4gICAgICAgICdTRVQnIDogMTQsXG4gICAgICAgICdMSVNUJyA6IDE1LFxuICAgICAgICAnVVRGOCcgOiAxNixcbiAgICAgICAgJ1VURjE2JyA6IDE3XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRocmlmdCBSUEMgbWVzc2FnZSB0eXBlIHN0cmluZyB0byBJZCBtYXBwaW5nLlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgQ0FMTCAgICAgIC0gUlBDIGNhbGwgc2VudCBmcm9tIGNsaWVudCB0byBzZXJ2ZXIuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9ICBSRVBMWSAgICAgLSBSUEMgY2FsbCBub3JtYWwgcmVzcG9uc2UgZnJvbSBzZXJ2ZXIgdG8gY2xpZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgRVhDRVBUSU9OIC0gUlBDIGNhbGwgZXhjZXB0aW9uIHJlc3BvbnNlIGZyb20gc2VydmVyIHRvIGNsaWVudC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gIE9ORVdBWSAgICAtIE9uZXdheSBSUEMgY2FsbCBmcm9tIGNsaWVudCB0byBzZXJ2ZXIgd2l0aCBubyByZXNwb25zZS5cbiAgICAgKi9cbiAgICBNZXNzYWdlVHlwZToge1xuICAgICAgICAnQ0FMTCcgOiAxLFxuICAgICAgICAnUkVQTFknIDogMixcbiAgICAgICAgJ0VYQ0VQVElPTicgOiAzLFxuICAgICAgICAnT05FV0FZJyA6IDRcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXRpbGl0eSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGNvdW50IG9mIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmogLSBPYmplY3QgdG8gdGVzdC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBudW1iZXIgb2Ygb2JqZWN0J3Mgb3duIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBvYmplY3RMZW5ndGg6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICAgICAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGVzdGFibGlzaCBwcm90b3R5cGUgaW5oZXJpdGFuY2UuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL2phdmFzY3JpcHQuY3JvY2tmb3JkLmNvbS9wcm90b3R5cGFsLmh0bWx8UHJvdG90eXBhbCBJbmhlcml0YW5jZX1cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb25zdHJ1Y3RvciAtIENvbnRzdHJ1Y3RvciBmdW5jdGlvbiB0byBzZXQgYXMgZGVyaXZlZC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckNvbnN0cnVjdG9yIC0gQ29udHN0cnVjdG9yIGZ1bmN0aW9uIHRvIHNldCBhcyBiYXNlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZV0gLSBUeXBlIG5hbWUgdG8gc2V0IGFzIG5hbWUgcHJvcGVydHkgaW4gZGVyaXZlZCBwcm90b3R5cGUuXG4gICAgICovXG4gICAgaW5oZXJpdHM6IGZ1bmN0aW9uKGNvbnN0cnVjdG9yLCBzdXBlckNvbnN0cnVjdG9yLCBuYW1lKSB7XG4gICAgICBmdW5jdGlvbiBGKCkge31cbiAgICAgIEYucHJvdG90eXBlID0gc3VwZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBuZXcgRigpO1xuICAgICAgY29uc3RydWN0b3IucHJvdG90eXBlLm5hbWUgPSBuYW1lIHx8IFwiXCI7XG4gICAgfVxufTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhIFRocmlmdCBURXhjZXB0aW9uIGluc3RhbmNlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXVnbWVudHMgRXJyb3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gVGhlIFRFeGNlcHRpb24gbWVzc2FnZSAoZGlzdGluY3QgZnJvbSB0aGUgRXJyb3IgbWVzc2FnZSkuXG4gKiBAY2xhc3NkZXNjIFRFeGNlcHRpb24gaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGFsbCBUaHJpZnQgZXhjZXB0aW9ucyB0eXBlcy5cbiAqL1xuVGhyaWZ0LlRFeGNlcHRpb24gPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbn07XG5UaHJpZnQuaW5oZXJpdHMoVGhyaWZ0LlRFeGNlcHRpb24sIEVycm9yLCAnVEV4Y2VwdGlvbicpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1lc3NhZ2Ugc2V0IG9uIHRoZSBleGNlcHRpb24uXG4gKiBAcmVhZG9ubHlcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGV4Y2VwdGlvbiBtZXNzYWdlXG4gKi9cblRocmlmdC5URXhjZXB0aW9uLnByb3RvdHlwZS5nZXRNZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbn07XG5cbi8qKlxuICogVGhyaWZ0IEFwcGxpY2F0aW9uIEV4Y2VwdGlvbiB0eXBlIHN0cmluZyB0byBJZCBtYXBwaW5nLlxuICogQHJlYWRvbmx5XG4gKiBAcHJvcGVydHkge251bWJlcn0gIFVOS05PV04gICAgICAgICAgICAgICAgIC0gVW5rbm93bi91bmRlZmluZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gIFVOS05PV05fTUVUSE9EICAgICAgICAgIC0gQ2xpZW50IGF0dGVtcHRlZCB0byBjYWxsIGEgbWV0aG9kIHVua25vd24gdG8gdGhlIHNlcnZlci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgSU5WQUxJRF9NRVNTQUdFX1RZUEUgICAgLSBDbGllbnQgcGFzc2VkIGFuIHVua25vd24vdW5zdXBwb3J0ZWQgTWVzc2FnZVR5cGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gIFdST05HX01FVEhPRF9OQU1FICAgICAgIC0gVW51c2VkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9ICBCQURfU0VRVUVOQ0VfSUQgICAgICAgICAtIFVudXNlZCBpbiBUaHJpZnQgUlBDLCB1c2VkIHRvIGZsYWcgcHJvcHJpZXRhcnkgc2VxdWVuY2UgbnVtYmVyIGVycm9ycy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgTUlTU0lOR19SRVNVTFQgICAgICAgICAgLSBSYWlzZWQgYnkgYSBzZXJ2ZXIgcHJvY2Vzc29yIGlmIGEgaGFuZGxlciBmYWlscyB0byBzdXBwbHkgdGhlIHJlcXVpcmVkIHJldHVybiByZXN1bHQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gIElOVEVSTkFMX0VSUk9SICAgICAgICAgIC0gU29tZXRoaW5nIGJhZCBoYXBwZW5lZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgUFJPVE9DT0xfRVJST1IgICAgICAgICAgLSBUaGUgcHJvdG9jb2wgbGF5ZXIgZmFpbGVkIHRvIHNlcmlhbGl6ZSBvciBkZXNlcmlhbGl6ZSBkYXRhLlxuICogQHByb3BlcnR5IHtudW1iZXJ9ICBJTlZBTElEX1RSQU5TRk9STSAgICAgICAtIFVudXNlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgSU5WQUxJRF9QUk9UT0NPTCAgICAgICAgLSBUaGUgcHJvdG9jb2wgKG9yIHZlcnNpb24pIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gIFVOU1VQUE9SVEVEX0NMSUVOVF9UWVBFIC0gVW51c2VkLlxuICovXG5UaHJpZnQuVEFwcGxpY2F0aW9uRXhjZXB0aW9uVHlwZSA9IHtcbiAgICAnVU5LTk9XTicgOiAwLFxuICAgICdVTktOT1dOX01FVEhPRCcgOiAxLFxuICAgICdJTlZBTElEX01FU1NBR0VfVFlQRScgOiAyLFxuICAgICdXUk9OR19NRVRIT0RfTkFNRScgOiAzLFxuICAgICdCQURfU0VRVUVOQ0VfSUQnIDogNCxcbiAgICAnTUlTU0lOR19SRVNVTFQnIDogNSxcbiAgICAnSU5URVJOQUxfRVJST1InIDogNixcbiAgICAnUFJPVE9DT0xfRVJST1InIDogNyxcbiAgICAnSU5WQUxJRF9UUkFOU0ZPUk0nIDogOCxcbiAgICAnSU5WQUxJRF9QUk9UT0NPTCcgOiA5LFxuICAgICdVTlNVUFBPUlRFRF9DTElFTlRfVFlQRScgOiAxMFxufTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhIFRocmlmdCBUQXBwbGljYXRpb25FeGNlcHRpb24gaW5zdGFuY2UuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhdWdtZW50cyBUaHJpZnQuVEV4Y2VwdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBUaGUgVEFwcGxpY2F0aW9uRXhjZXB0aW9uIG1lc3NhZ2UgKGRpc3RpbmN0IGZyb20gdGhlIEVycm9yIG1lc3NhZ2UpLlxuICogQHBhcmFtIHtUaHJpZnQuVEFwcGxpY2F0aW9uRXhjZXB0aW9uVHlwZX0gW2NvZGVdIC0gVGhlIFRBcHBsaWNhdGlvbkV4Y2VwdGlvblR5cGUgY29kZS5cbiAqIEBjbGFzc2Rlc2MgVEFwcGxpY2F0aW9uRXhjZXB0aW9uIGlzIHRoZSBleGNlcHRpb24gY2xhc3MgdXNlZCB0byBwcm9wYWdhdGUgZXhjZXB0aW9ucyBmcm9tIGFuIFJQQyBzZXJ2ZXIgYmFjayB0byBhIGNhbGxpbmcgY2xpZW50LlxuKi9cblRocmlmdC5UQXBwbGljYXRpb25FeGNlcHRpb24gPSBmdW5jdGlvbihtZXNzYWdlLCBjb2RlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLmNvZGUgPSB0eXBlb2YgY29kZSA9PT0gXCJudW1iZXJcIiA/IGNvZGUgOiAwO1xufTtcblRocmlmdC5pbmhlcml0cyhUaHJpZnQuVEFwcGxpY2F0aW9uRXhjZXB0aW9uLCBUaHJpZnQuVEV4Y2VwdGlvbiwgJ1RBcHBsaWNhdGlvbkV4Y2VwdGlvbicpO1xuXG4vKipcbiAqIFJlYWQgYSBUQXBwbGljYXRpb25FeGNlcHRpb24gZnJvbSB0aGUgc3VwcGxpZWQgcHJvdG9jb2wuXG4gKiBAcGFyYW0ge29iamVjdH0gaW5wdXQgLSBUaGUgaW5wdXQgcHJvdG9jb2wgdG8gcmVhZCBmcm9tLlxuICovXG5UaHJpZnQuVEFwcGxpY2F0aW9uRXhjZXB0aW9uLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICB3aGlsZSAoMSkge1xuICAgICAgICB2YXIgcmV0ID0gaW5wdXQucmVhZEZpZWxkQmVnaW4oKTtcblxuICAgICAgICBpZiAocmV0LmZ0eXBlID09IFRocmlmdC5UeXBlLlNUT1ApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZpZCA9IHJldC5maWQ7XG5cbiAgICAgICAgc3dpdGNoIChmaWQpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBpZiAocmV0LmZ0eXBlID09IFRocmlmdC5UeXBlLlNUUklORykge1xuICAgICAgICAgICAgICAgICAgICByZXQgPSBpbnB1dC5yZWFkU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IHJldC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXQgPSBpbnB1dC5za2lwKHJldC5mdHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGlmIChyZXQuZnR5cGUgPT0gVGhyaWZ0LlR5cGUuSTMyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldCA9IGlucHV0LnJlYWRJMzIoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2RlID0gcmV0LnZhbHVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldCA9IGlucHV0LnNraXAocmV0LmZ0eXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0ID0gaW5wdXQuc2tpcChyZXQuZnR5cGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5wdXQucmVhZEZpZWxkRW5kKCk7XG4gICAgfVxuXG4gICAgaW5wdXQucmVhZFN0cnVjdEVuZCgpO1xufTtcblxuLyoqXG4gKiBXaXRlIGEgVEFwcGxpY2F0aW9uRXhjZXB0aW9uIHRvIHRoZSBzdXBwbGllZCBwcm90b2NvbC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBvdXRwdXQgLSBUaGUgb3V0cHV0IHByb3RvY29sIHRvIHdyaXRlIHRvLlxuICovXG5UaHJpZnQuVEFwcGxpY2F0aW9uRXhjZXB0aW9uLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKG91dHB1dCkge1xuICAgIG91dHB1dC53cml0ZVN0cnVjdEJlZ2luKCdUQXBwbGljYXRpb25FeGNlcHRpb24nKTtcblxuICAgIGlmICh0aGlzLm1lc3NhZ2UpIHtcbiAgICAgICAgb3V0cHV0LndyaXRlRmllbGRCZWdpbignbWVzc2FnZScsIFRocmlmdC5UeXBlLlNUUklORywgMSk7XG4gICAgICAgIG91dHB1dC53cml0ZVN0cmluZyh0aGlzLmdldE1lc3NhZ2UoKSk7XG4gICAgICAgIG91dHB1dC53cml0ZUZpZWxkRW5kKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY29kZSkge1xuICAgICAgICBvdXRwdXQud3JpdGVGaWVsZEJlZ2luKCd0eXBlJywgVGhyaWZ0LlR5cGUuSTMyLCAyKTtcbiAgICAgICAgb3V0cHV0LndyaXRlSTMyKHRoaXMuY29kZSk7XG4gICAgICAgIG91dHB1dC53cml0ZUZpZWxkRW5kKCk7XG4gICAgfVxuXG4gICAgb3V0cHV0LndyaXRlRmllbGRTdG9wKCk7XG4gICAgb3V0cHV0LndyaXRlU3RydWN0RW5kKCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGFwcGxpY2F0aW9uIGV4Y2VwdGlvbiBjb2RlIHNldCBvbiB0aGUgZXhjZXB0aW9uLlxuICogQHJlYWRvbmx5XG4gKiBAcmV0dXJucyB7VGhyaWZ0LlRBcHBsaWNhdGlvbkV4Y2VwdGlvblR5cGV9IGV4Y2VwdGlvbiBjb2RlXG4gKi9cblRocmlmdC5UQXBwbGljYXRpb25FeGNlcHRpb24ucHJvdG90eXBlLmdldENvZGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jb2RlO1xufTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RvciBGdW5jdGlvbiBmb3IgdGhlIFhIUiB0cmFuc3BvcnQuXG4gKiBJZiB5b3UgZG8gbm90IHNwZWNpZnkgYSB1cmwgdGhlbiB5b3UgbXVzdCBoYW5kbGUgWEhSIG9wZXJhdGlvbnMgb25cbiAqIHlvdXIgb3duLiBUaGlzIHR5cGUgY2FuIGFsc28gYmUgY29uc3RydWN0ZWQgdXNpbmcgdGhlIFRyYW5zcG9ydCBhbGlhc1xuICogZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdXJsXSAtIFRoZSBVUkwgdG8gY29ubmVjdCB0by5cbiAqIEBjbGFzc2Rlc2MgVGhlIEFwYWNoZSBUaHJpZnQgVHJhbnNwb3J0IGxheWVyIHBlcmZvcm1zIGJ5dGUgbGV2ZWwgSS9PIFxuICogYmV0d2VlbiBSUEMgY2xpZW50cyBhbmQgc2VydmVycy4gVGhlIEphdmFTY3JpcHQgVFhIUlRyYW5zcG9ydCBvYmplY3QgXG4gKiB1c2VzIEh0dHBbc10vWEhSLiBUYXJnZXQgc2VydmVycyBtdXN0IGltcGxlbWVudCB0aGUgaHR0cFtzXSB0cmFuc3BvcnRcbiAqIChzZWU6IG5vZGUuanMgZXhhbXBsZSBzZXJ2ZXJfaHR0cC5qcykuXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciB0cmFuc3BvcnQgPSBuZXcgVGhyaWZ0LlRYSFJUcmFuc3BvcnQoXCJodHRwOi8vbG9jYWxob3N0Ojg1ODVcIik7XG4gKi9cblRocmlmdC5UcmFuc3BvcnQgPSBUaHJpZnQuVFhIUlRyYW5zcG9ydCA9IGZ1bmN0aW9uKHVybCwgb3B0aW9ucykge1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMud3BvcyA9IDA7XG4gICAgdGhpcy5ycG9zID0gMDtcbiAgICB0aGlzLnVzZUNPUlMgPSAob3B0aW9ucyAmJiBvcHRpb25zLnVzZUNPUlMpO1xuICAgIHRoaXMuc2VuZF9idWYgPSAnJztcbiAgICB0aGlzLnJlY3ZfYnVmID0gJyc7XG59O1xuXG5UaHJpZnQuVFhIUlRyYW5zcG9ydC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYnJvd3NlciBzcGVjaWZpYyBYbWxIdHRwUmVxdWVzdCBPYmplY3QuXG4gICAgICogQHJldHVybnMge29iamVjdH0gdGhlIGJyb3dzZXIgWEhSIGludGVyZmFjZSBvYmplY3RcbiAgICAgKi9cbiAgICBnZXRYbWxIdHRwUmVxdWVzdE9iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRyeSB7IHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKTsgfSBjYXRjaCAoZTEpIHsgfVxuICAgICAgICB0cnkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQJyk7IH0gY2F0Y2ggKGUyKSB7IH1cbiAgICAgICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpOyB9IGNhdGNoIChlMykgeyB9XG5cbiAgICAgICAgdGhyb3cgXCJZb3VyIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IFhIUi5cIjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZHMgdGhlIGN1cnJlbnQgWFJIIHJlcXVlc3QgaWYgdGhlIHRyYW5zcG9ydCB3YXMgY3JlYXRlZCB3aXRoIGEgVVJMIFxuICAgICAqIGFuZCB0aGUgYXN5bmMgcGFyYW1ldGVyIGlzIGZhbHNlLiBJZiB0aGUgdHJhbnNwb3J0IHdhcyBub3QgY3JlYXRlZCB3aXRoXG4gICAgICogYSBVUkwsIG9yIHRoZSBhc3luYyBwYXJhbWV0ZXIgaXMgVHJ1ZSBhbmQgbm8gY2FsbGJhY2sgaXMgcHJvdmlkZWQsIG9yIFxuICAgICAqIHRoZSBVUkwgaXMgYW4gZW1wdHkgc3RyaW5nLCB0aGUgY3VycmVudCBzZW5kIGJ1ZmZlciBpcyByZXR1cm5lZC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYXN5bmMgLSBJZiB0cnVlIHRoZSBjdXJyZW50IHNlbmQgYnVmZmVyIGlzIHJldHVybmVkLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjYWxsYmFjayAtIE9wdGlvbmFsIGFzeW5jIGNvbXBsZXRpb24gY2FsbGJhY2sgXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZHxzdHJpbmd9IE5vdGhpbmcgb3IgdGhlIGN1cnJlbnQgc2VuZCBidWZmZXIuXG4gICAgICogQHRocm93cyB7c3RyaW5nfSBJZiBYSFIgZmFpbHMuXG4gICAgICovXG4gICAgZmx1c2g6IGZ1bmN0aW9uKGFzeW5jLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICgoYXN5bmMgJiYgIWNhbGxiYWNrKSB8fCB0aGlzLnVybCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMudXJsID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZF9idWY7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeHJlcSA9IHRoaXMuZ2V0WG1sSHR0cFJlcXVlc3RPYmplY3QoKTtcblxuICAgICAgICBpZiAoeHJlcS5vdmVycmlkZU1pbWVUeXBlKSB7XG4gICAgICAgICAgICB4cmVxLm92ZXJyaWRlTWltZVR5cGUoJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgLy9JZ25vcmUgWEhSIGNhbGxiYWNrcyB1bnRpbCB0aGUgZGF0YSBhcnJpdmVzLCB0aGVuIGNhbGwgdGhlXG4gICAgICAgICAgICAvLyAgY2xpZW50J3MgY2FsbGJhY2tcbiAgICAgICAgICAgIHhyZXEub25yZWFkeXN0YXRlY2hhbmdlID0gXG4gICAgICAgICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xpZW50Q2FsbGJhY2sgPSBjYWxsYmFjazsgICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PSA0ICYmIHRoaXMuc3RhdHVzID09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNldFJlY3ZCdWZmZXIodGhpcy5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICBjbGllbnRDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0oKSk7XG4gICAgICAgIH1cblxuICAgICAgICB4cmVxLm9wZW4oJ1BPU1QnLCB0aGlzLnVybCwgISFhc3luYyk7XG4gICAgICAgIHhyZXEuc2VuZCh0aGlzLnNlbmRfYnVmKTtcbiAgICAgICAgaWYgKGFzeW5jICYmIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeHJlcS5yZWFkeVN0YXRlICE9IDQpIHtcbiAgICAgICAgICAgIHRocm93ICdlbmNvdW50ZXJlZCBhbiB1bmtub3duIGFqYXggcmVhZHkgc3RhdGU6ICcgKyB4cmVxLnJlYWR5U3RhdGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeHJlcS5zdGF0dXMgIT0gMjAwKSB7XG4gICAgICAgICAgICB0aHJvdyAnZW5jb3VudGVyZWQgYSB1bmtub3duIHJlcXVlc3Qgc3RhdHVzOiAnICsgeHJlcS5zdGF0dXM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlY3ZfYnVmID0geHJlcS5yZXNwb25zZVRleHQ7XG4gICAgICAgIHRoaXMucmVjdl9idWZfc3ogPSB0aGlzLnJlY3ZfYnVmLmxlbmd0aDtcbiAgICAgICAgdGhpcy53cG9zID0gdGhpcy5yZWN2X2J1Zi5sZW5ndGg7XG4gICAgICAgIHRoaXMucnBvcyA9IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBqUXVlcnkgWEhSIG9iamVjdCB0byBiZSB1c2VkIGZvciBhIFRocmlmdCBzZXJ2ZXIgY2FsbC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY2xpZW50IC0gVGhlIFRocmlmdCBTZXJ2aWNlIGNsaWVudCBvYmplY3QgZ2VuZXJhdGVkIGJ5IHRoZSBJREwgY29tcGlsZXIuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBvc3REYXRhIC0gVGhlIG1lc3NhZ2UgdG8gc2VuZCB0byB0aGUgc2VydmVyLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGFyZ3MgLSBUaGUgb3JpZ2luYWwgY2FsbCBhcmd1bWVudHMgd2l0aCB0aGUgc3VjY2VzcyBjYWxsIGJhY2sgYXQgdGhlIGVuZC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSByZWN2X21ldGhvZCAtIFRoZSBUaHJpZnQgU2VydmljZSBDbGllbnQgcmVjZWl2ZSBtZXRob2QgZm9yIHRoZSBjYWxsLlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IEEgbmV3IGpRdWVyeSBYSFIgb2JqZWN0LlxuICAgICAqIEB0aHJvd3Mge3N0cmluZ30gSWYgdGhlIGpRdWVyeSB2ZXJzaW9uIGlzIHByaW9yIHRvIDEuNSBvciBpZiBqUXVlcnkgaXMgbm90IGZvdW5kLlxuICAgICAqL1xuICAgIGpxUmVxdWVzdDogZnVuY3Rpb24oY2xpZW50LCBwb3N0RGF0YSwgYXJncywgcmVjdl9tZXRob2QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqUXVlcnkgPT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICAgICB0eXBlb2YgalF1ZXJ5LkRlZmVycmVkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgJ1RocmlmdC5qcyByZXF1aXJlcyBqUXVlcnkgMS41KyB0byB1c2UgYXN5bmNocm9ub3VzIHJlcXVlc3RzJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0aHJpZnRUcmFuc3BvcnQgPSB0aGlzO1xuXG4gICAgICAgIHZhciBqcVhIUiA9IGpRdWVyeS5hamF4KHtcbiAgICAgICAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICAgICAgICBkYXRhOiBwb3N0RGF0YSxcbiAgICAgICAgICAgIHR5cGU6ICdQT1NUJyxcbiAgICAgICAgICAgIGNhY2hlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICBkYXRhVHlwZTogJ3RleHQgdGhyaWZ0JyxcbiAgICAgICAgICAgIGNvbnZlcnRlcnM6IHtcbiAgICAgICAgICAgICAgICAndGV4dCB0aHJpZnQnIDogZnVuY3Rpb24ocmVzcG9uc2VEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocmlmdFRyYW5zcG9ydC5zZXRSZWN2QnVmZmVyKHJlc3BvbnNlRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHJlY3ZfbWV0aG9kLmNhbGwoY2xpZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250ZXh0OiBjbGllbnQsXG4gICAgICAgICAgICBzdWNjZXNzOiBqUXVlcnkubWFrZUFycmF5KGFyZ3MpLnBvcCgpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBqcVhIUjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYnVmZmVyIHRvIHByb3ZpZGUgdGhlIHByb3RvY29sIHdoZW4gZGVzZXJpYWxpemluZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYnVmIC0gVGhlIGJ1ZmZlciB0byBzdXBwbHkgdGhlIHByb3RvY29sLlxuICAgICAqL1xuICAgIHNldFJlY3ZCdWZmZXI6IGZ1bmN0aW9uKGJ1Zikge1xuICAgICAgICB0aGlzLnJlY3ZfYnVmID0gYnVmO1xuICAgICAgICB0aGlzLnJlY3ZfYnVmX3N6ID0gdGhpcy5yZWN2X2J1Zi5sZW5ndGg7XG4gICAgICAgIHRoaXMud3BvcyA9IHRoaXMucmVjdl9idWYubGVuZ3RoO1xuICAgICAgICB0aGlzLnJwb3MgPSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHRyYW5zcG9ydCBpcyBvcGVuLCBYSFIgYWx3YXlzIHJldHVybnMgdHJ1ZS5cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gQWx3YXlzIFRydWUuXG4gICAgICovICAgIFxuICAgIGlzT3BlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPcGVucyB0aGUgdHJhbnNwb3J0IGNvbm5lY3Rpb24sIHdpdGggWEhSIHRoaXMgaXMgYSBub3AuXG4gICAgICovICAgIFxuICAgIG9wZW46IGZ1bmN0aW9uKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIHRyYW5zcG9ydCBjb25uZWN0aW9uLCB3aXRoIFhIUiB0aGlzIGlzIGEgbm9wLlxuICAgICAqLyAgICBcbiAgICBjbG9zZTogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSByZXNwb25zZVxuICAgICAqIGJ1ZmZlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuIC0gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIHJldHVybi5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBDaGFyYWN0ZXJzIHNlbnQgYnkgdGhlIHNlcnZlci5cbiAgICAgKi9cbiAgICByZWFkOiBmdW5jdGlvbihsZW4pIHtcbiAgICAgICAgdmFyIGF2YWlsID0gdGhpcy53cG9zIC0gdGhpcy5ycG9zO1xuXG4gICAgICAgIGlmIChhdmFpbCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdpdmUgPSBsZW47XG5cbiAgICAgICAgaWYgKGF2YWlsIDwgbGVuKSB7XG4gICAgICAgICAgICBnaXZlID0gYXZhaWw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmV0ID0gdGhpcy5yZWFkX2J1Zi5zdWJzdHIodGhpcy5ycG9zLCBnaXZlKTtcbiAgICAgICAgdGhpcy5ycG9zICs9IGdpdmU7XG5cbiAgICAgICAgLy9jbGVhciBidWYgd2hlbiBjb21wbGV0ZT9cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZW50aXJlIHJlc3BvbnNlIGJ1ZmZlci5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBDaGFyYWN0ZXJzIHNlbnQgYnkgdGhlIHNlcnZlci5cbiAgICAgKi9cbiAgICByZWFkQWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjdl9idWY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNlbmQgYnVmZmVyIHRvIGJ1Zi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYnVmIC0gVGhlIGJ1ZmZlciB0byBzZW5kLlxuICAgICAqLyAgICBcbiAgICB3cml0ZTogZnVuY3Rpb24oYnVmKSB7XG4gICAgICAgIHRoaXMuc2VuZF9idWYgPSBidWY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNlbmQgYnVmZmVyLlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBzZW5kIGJ1ZmZlci5cbiAgICAgKi8gXG4gICAgZ2V0U2VuZEJ1ZmZlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmRfYnVmO1xuICAgIH1cblxufTtcblxuXG4vKipcbiAqIENvbnN0cnVjdG9yIEZ1bmN0aW9uIGZvciB0aGUgV2ViU29ja2V0IHRyYW5zcG9ydC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IFt1cmxdIC0gVGhlIFVSTCB0byBjb25uZWN0IHRvLlxuICogQGNsYXNzZGVzYyBUaGUgQXBhY2hlIFRocmlmdCBUcmFuc3BvcnQgbGF5ZXIgcGVyZm9ybXMgYnl0ZSBsZXZlbCBJL08gXG4gKiBiZXR3ZWVuIFJQQyBjbGllbnRzIGFuZCBzZXJ2ZXJzLiBUaGUgSmF2YVNjcmlwdCBUV2ViU29ja2V0VHJhbnNwb3J0IG9iamVjdCBcbiAqIHVzZXMgdGhlIFdlYlNvY2tldCBwcm90b2NvbC4gVGFyZ2V0IHNlcnZlcnMgbXVzdCBpbXBsZW1lbnQgV2ViU29ja2V0LlxuICogKHNlZTogbm9kZS5qcyBleGFtcGxlIHNlcnZlcl9odHRwLmpzKS5cbiAqIEBleGFtcGxlXG4gKiAgIHZhciB0cmFuc3BvcnQgPSBuZXcgVGhyaWZ0LlRXZWJTb2NrZXRUcmFuc3BvcnQoXCJodHRwOi8vbG9jYWxob3N0Ojg1ODVcIik7XG4gKi9cblRocmlmdC5UV2ViU29ja2V0VHJhbnNwb3J0ID0gZnVuY3Rpb24odXJsKSB7XG4gICAgdGhpcy5fX3Jlc2V0KHVybCk7XG59O1xuXG5UaHJpZnQuVFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUgPSB7XG4gICAgX19yZXNldDogZnVuY3Rpb24odXJsKSB7XG4gICAgICB0aGlzLnVybCA9IHVybDsgICAgICAgICAgICAgLy9XaGVyZSB0byBjb25uZWN0XG4gICAgICB0aGlzLnNvY2tldCA9IG51bGw7ICAgICAgICAgLy9UaGUgd2ViIHNvY2tldFxuICAgICAgdGhpcy5jYWxsYmFja3MgPSBbXTsgICAgICAgIC8vUGVuZGluZyBjYWxsYmFja3NcbiAgICAgIHRoaXMuc2VuZF9wZW5kaW5nID0gW107ICAgICAvL0J1ZmZlcnMvQ2FsbGJhY2sgcGFpcnMgd2FpdGluZyB0byBiZSBzZW50XG4gICAgICB0aGlzLnNlbmRfYnVmID0gJyc7ICAgICAgICAgLy9PdXRib3VuZCBkYXRhLCBpbW11dGFibGUgdW50aWwgc2VudFxuICAgICAgdGhpcy5yZWN2X2J1ZiA9ICcnOyAgICAgICAgIC8vSW5ib3VuZCBkYXRhXG4gICAgICB0aGlzLnJiX3dwb3MgPSAwOyAgICAgICAgICAgLy9OZXR3b3JrIHdyaXRlIHBvc2l0aW9uIGluIHJlY2VpdmUgYnVmZmVyXG4gICAgICB0aGlzLnJiX3Jwb3MgPSAwOyAgICAgICAgICAgLy9DbGllbnQgcmVhZCBwb3NpdGlvbiBpbiByZWNlaXZlIGJ1ZmZlclxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kcyB0aGUgY3VycmVudCBXUyByZXF1ZXN0IGFuZCByZWdpc3RlcnMgY2FsbGJhY2suIFRoZSBhc3luYyBcbiAgICAgKiBwYXJhbWV0ZXIgaXMgaWdub3JlZCAoV1MgZmx1c2ggaXMgYWx3YXlzIGFzeW5jKSBhbmQgdGhlIGNhbGxiYWNrIFxuICAgICAqIGZ1bmN0aW9uIHBhcmFtZXRlciBpcyByZXF1aXJlZC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYXN5bmMgLSBJZ25vcmVkLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjYWxsYmFjayAtIFRoZSBjbGllbnQgY29tcGxldGlvbiBjYWxsYmFjay5cbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfHN0cmluZ30gTm90aGluZyAodW5kZWZpbmVkKSBcbiAgICAgKi9cbiAgICBmbHVzaDogZnVuY3Rpb24oYXN5bmMsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBpZiAodGhpcy5pc09wZW4oKSkge1xuICAgICAgICAvL1NlbmQgZGF0YSBhbmQgcmVnaXN0ZXIgYSBjYWxsYmFjayB0byBpbnZva2UgdGhlIGNsaWVudCBjYWxsYmFja1xuICAgICAgICB0aGlzLnNvY2tldC5zZW5kKHRoaXMuc2VuZF9idWYpOyBcbiAgICAgICAgdGhpcy5jYWxsYmFja3MucHVzaCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGNsaWVudENhbGxiYWNrID0gY2FsbGJhY2s7ICAgIFxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihtc2cpIHtcbiAgICAgICAgICAgIHNlbGYuc2V0UmVjdkJ1ZmZlcihtc2cpO1xuICAgICAgICAgICAgY2xpZW50Q2FsbGJhY2soKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KCkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vUXVldWUgdGhlIHNlbmQgdG8gZ28gb3V0IF9fb25PcGVuXG4gICAgICAgIHRoaXMuc2VuZF9wZW5kaW5nLnB1c2goe1xuICAgICAgICAgIGJ1ZjogdGhpcy5zZW5kX2J1ZixcbiAgICAgICAgICBjYjogIGNhbGxiYWNrXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfX29uT3BlbjogZnVuY3Rpb24oKSB7IFxuICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICBpZiAodGhpcy5zZW5kX3BlbmRpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vSWYgdGhlIHVzZXIgbWFkZSBjYWxscyBiZWZvcmUgdGhlIGNvbm5lY3Rpb24gd2FzIGZ1bGx5IFxuICAgICAgICAgIC8vb3Blbiwgc2VuZCB0aGVtIG5vd1xuICAgICAgICAgIHRoaXMuc2VuZF9wZW5kaW5nLmZvckVhY2goZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgIHRoaXMuc29ja2V0LnNlbmQoZWxlbS5idWYpO1xuICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLnB1c2goKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgdmFyIGNsaWVudENhbGxiYWNrID0gZWxlbS5jYjsgICAgXG4gICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24obXNnKSB7XG4gICAgICAgICAgICAgICAgICBzZWxmLnNldFJlY3ZCdWZmZXIobXNnKTtcbiAgICAgICAgICAgICAgICAgIGNsaWVudENhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgIH0oKSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuc2VuZF9wZW5kaW5nID0gW107XG4gICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgX19vbkNsb3NlOiBmdW5jdGlvbihldnQpIHsgXG4gICAgICB0aGlzLl9fcmVzZXQodGhpcy51cmwpO1xuICAgIH0sXG4gICAgIFxuICAgIF9fb25NZXNzYWdlOiBmdW5jdGlvbihldnQpIHtcbiAgICAgIGlmICh0aGlzLmNhbGxiYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja3Muc2hpZnQoKShldnQuZGF0YSk7XG4gICAgICB9XG4gICAgfSxcbiAgICAgXG4gICAgX19vbkVycm9yOiBmdW5jdGlvbihldnQpIHsgXG4gICAgICBjb25zb2xlLmxvZyhcIlRocmlmdCBXZWJTb2NrZXQgRXJyb3I6IFwiICsgZXZ0LnRvU3RyaW5nKCkpO1xuICAgICAgdGhpcy5zb2NrZXQuY2xvc2UoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYnVmZmVyIHRvIHVzZSB3aGVuIHJlY2VpdmluZyBzZXJ2ZXIgcmVzcG9uc2VzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBidWYgLSBUaGUgYnVmZmVyIHRvIHJlY2VpdmUgc2VydmVyIHJlc3BvbnNlcy5cbiAgICAgKi9cbiAgICBzZXRSZWN2QnVmZmVyOiBmdW5jdGlvbihidWYpIHtcbiAgICAgICAgdGhpcy5yZWN2X2J1ZiA9IGJ1ZjtcbiAgICAgICAgdGhpcy5yZWN2X2J1Zl9zeiA9IHRoaXMucmVjdl9idWYubGVuZ3RoO1xuICAgICAgICB0aGlzLndwb3MgPSB0aGlzLnJlY3ZfYnVmLmxlbmd0aDtcbiAgICAgICAgdGhpcy5ycG9zID0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc3BvcnQgaXMgb3BlblxuICAgICAqIEByZWFkb25seVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBcbiAgICAgKi8gICAgXG4gICAgaXNPcGVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0ICYmIHRoaXMuc29ja2V0LnJlYWR5U3RhdGUgPT0gdGhpcy5zb2NrZXQuT1BFTjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT3BlbnMgdGhlIHRyYW5zcG9ydCBjb25uZWN0aW9uXG4gICAgICovICAgIFxuICAgIG9wZW46IGZ1bmN0aW9uKCkge1xuICAgICAgLy9JZiBPUEVOL0NPTk5FQ1RJTkcvQ0xPU0lORyBpZ25vcmUgYWRkaXRpb25hbCBvcGVuc1xuICAgICAgaWYgKHRoaXMuc29ja2V0ICYmIHRoaXMuc29ja2V0LnJlYWR5U3RhdGUgIT0gdGhpcy5zb2NrZXQuQ0xPU0VEKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vSWYgdGhlcmUgaXMgbm8gc29ja2V0IG9yIHRoZSBzb2NrZXQgaXMgY2xvc2VkOlxuICAgICAgdGhpcy5zb2NrZXQgPSBuZXcgV2ViU29ja2V0KHRoaXMudXJsKTtcbiAgICAgIHRoaXMuc29ja2V0Lm9ub3BlbiA9IHRoaXMuX19vbk9wZW4uYmluZCh0aGlzKTsgXG4gICAgICB0aGlzLnNvY2tldC5vbm1lc3NhZ2UgPSB0aGlzLl9fb25NZXNzYWdlLmJpbmQodGhpcyk7IFxuICAgICAgdGhpcy5zb2NrZXQub25lcnJvciA9IHRoaXMuX19vbkVycm9yLmJpbmQodGhpcyk7IFxuICAgICAgdGhpcy5zb2NrZXQub25jbG9zZSA9IHRoaXMuX19vbkNsb3NlLmJpbmQodGhpcyk7IFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIHRyYW5zcG9ydCBjb25uZWN0aW9uXG4gICAgICovICAgIFxuICAgIGNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc29ja2V0LmNsb3NlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSByZXNwb25zZVxuICAgICAqIGJ1ZmZlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuIC0gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIHJldHVybi5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBDaGFyYWN0ZXJzIHNlbnQgYnkgdGhlIHNlcnZlci5cbiAgICAgKi9cbiAgICByZWFkOiBmdW5jdGlvbihsZW4pIHtcbiAgICAgICAgdmFyIGF2YWlsID0gdGhpcy53cG9zIC0gdGhpcy5ycG9zO1xuXG4gICAgICAgIGlmIChhdmFpbCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdpdmUgPSBsZW47XG5cbiAgICAgICAgaWYgKGF2YWlsIDwgbGVuKSB7XG4gICAgICAgICAgICBnaXZlID0gYXZhaWw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmV0ID0gdGhpcy5yZWFkX2J1Zi5zdWJzdHIodGhpcy5ycG9zLCBnaXZlKTtcbiAgICAgICAgdGhpcy5ycG9zICs9IGdpdmU7XG5cbiAgICAgICAgLy9jbGVhciBidWYgd2hlbiBjb21wbGV0ZT9cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZW50aXJlIHJlc3BvbnNlIGJ1ZmZlci5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBDaGFyYWN0ZXJzIHNlbnQgYnkgdGhlIHNlcnZlci5cbiAgICAgKi9cbiAgICByZWFkQWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjdl9idWY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNlbmQgYnVmZmVyIHRvIGJ1Zi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYnVmIC0gVGhlIGJ1ZmZlciB0byBzZW5kLlxuICAgICAqLyAgICBcbiAgICB3cml0ZTogZnVuY3Rpb24oYnVmKSB7XG4gICAgICAgIHRoaXMuc2VuZF9idWYgPSBidWY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNlbmQgYnVmZmVyLlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBzZW5kIGJ1ZmZlci5cbiAgICAgKi8gXG4gICAgZ2V0U2VuZEJ1ZmZlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmRfYnVmO1xuICAgIH1cblxufTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhIFRocmlmdCBKU09OIHByb3RvY29sIGluc3RhbmNlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1RocmlmdC5UcmFuc3BvcnR9IHRyYW5zcG9ydCAtIFRoZSB0cmFuc3BvcnQgdG8gc2VyaWFsaXplIHRvL2Zyb20uXG4gKiBAY2xhc3NkZXNjIEFwYWNoZSBUaHJpZnQgUHJvdG9jb2xzIHBlcmZvcm0gc2VyaWFsaXphdGlvbiB3aGljaCBlbmFibGVzIGNyb3NzIFxuICogbGFuZ3VhZ2UgUlBDLiBUaGUgUHJvdG9jb2wgdHlwZSBpcyB0aGUgSmF2YVNjcmlwdCBicm93c2VyIGltcGxlbWVudGF0aW9uIFxuICogb2YgdGhlIEFwYWNoZSBUaHJpZnQgVEpTT05Qcm90b2NvbC5cbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIHByb3RvY29sICA9IG5ldyBUaHJpZnQuUHJvdG9jb2wodHJhbnNwb3J0KTtcbiAqL1xuVGhyaWZ0LlRKU09OUHJvdG9jb2wgPSBUaHJpZnQuUHJvdG9jb2wgPSBmdW5jdGlvbih0cmFuc3BvcnQpIHtcbiAgICB0aGlzLnRzdGFjayA9IFtdO1xuICAgIHRoaXMudHBvcyA9IFtdO1xuICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xufTtcblxuLyoqXG4gKiBUaHJpZnQgSURMIHR5cGUgSWQgdG8gc3RyaW5nIG1hcHBpbmcuXG4gKiBAcmVhZG9ubHlcbiAqIEBzZWUge0BsaW5rIFRocmlmdC5UeXBlfVxuICovXG5UaHJpZnQuUHJvdG9jb2wuVHlwZSA9IHt9O1xuVGhyaWZ0LlByb3RvY29sLlR5cGVbVGhyaWZ0LlR5cGUuQk9PTF0gPSAnXCJ0ZlwiJztcblRocmlmdC5Qcm90b2NvbC5UeXBlW1RocmlmdC5UeXBlLkJZVEVdID0gJ1wiaThcIic7XG5UaHJpZnQuUHJvdG9jb2wuVHlwZVtUaHJpZnQuVHlwZS5JMTZdID0gJ1wiaTE2XCInO1xuVGhyaWZ0LlByb3RvY29sLlR5cGVbVGhyaWZ0LlR5cGUuSTMyXSA9ICdcImkzMlwiJztcblRocmlmdC5Qcm90b2NvbC5UeXBlW1RocmlmdC5UeXBlLkk2NF0gPSAnXCJpNjRcIic7XG5UaHJpZnQuUHJvdG9jb2wuVHlwZVtUaHJpZnQuVHlwZS5ET1VCTEVdID0gJ1wiZGJsXCInO1xuVGhyaWZ0LlByb3RvY29sLlR5cGVbVGhyaWZ0LlR5cGUuU1RSVUNUXSA9ICdcInJlY1wiJztcblRocmlmdC5Qcm90b2NvbC5UeXBlW1RocmlmdC5UeXBlLlNUUklOR10gPSAnXCJzdHJcIic7XG5UaHJpZnQuUHJvdG9jb2wuVHlwZVtUaHJpZnQuVHlwZS5NQVBdID0gJ1wibWFwXCInO1xuVGhyaWZ0LlByb3RvY29sLlR5cGVbVGhyaWZ0LlR5cGUuTElTVF0gPSAnXCJsc3RcIic7XG5UaHJpZnQuUHJvdG9jb2wuVHlwZVtUaHJpZnQuVHlwZS5TRVRdID0gJ1wic2V0XCInO1xuXG4vKipcbiAqIFRocmlmdCBJREwgdHlwZSBzdHJpbmcgdG8gSWQgbWFwcGluZy5cbiAqIEByZWFkb25seVxuICogQHNlZSB7QGxpbmsgVGhyaWZ0LlR5cGV9XG4gKi9cblRocmlmdC5Qcm90b2NvbC5SVHlwZSA9IHt9O1xuVGhyaWZ0LlByb3RvY29sLlJUeXBlLnRmID0gVGhyaWZ0LlR5cGUuQk9PTDtcblRocmlmdC5Qcm90b2NvbC5SVHlwZS5pOCA9IFRocmlmdC5UeXBlLkJZVEU7XG5UaHJpZnQuUHJvdG9jb2wuUlR5cGUuaTE2ID0gVGhyaWZ0LlR5cGUuSTE2O1xuVGhyaWZ0LlByb3RvY29sLlJUeXBlLmkzMiA9IFRocmlmdC5UeXBlLkkzMjtcblRocmlmdC5Qcm90b2NvbC5SVHlwZS5pNjQgPSBUaHJpZnQuVHlwZS5JNjQ7XG5UaHJpZnQuUHJvdG9jb2wuUlR5cGUuZGJsID0gVGhyaWZ0LlR5cGUuRE9VQkxFO1xuVGhyaWZ0LlByb3RvY29sLlJUeXBlLnJlYyA9IFRocmlmdC5UeXBlLlNUUlVDVDtcblRocmlmdC5Qcm90b2NvbC5SVHlwZS5zdHIgPSBUaHJpZnQuVHlwZS5TVFJJTkc7XG5UaHJpZnQuUHJvdG9jb2wuUlR5cGUubWFwID0gVGhyaWZ0LlR5cGUuTUFQO1xuVGhyaWZ0LlByb3RvY29sLlJUeXBlLmxzdCA9IFRocmlmdC5UeXBlLkxJU1Q7XG5UaHJpZnQuUHJvdG9jb2wuUlR5cGUuc2V0ID0gVGhyaWZ0LlR5cGUuU0VUO1xuXG4vKipcbiAqIFRoZSBUSlNPTlByb3RvY29sIHZlcnNpb24gbnVtYmVyLlxuICogQHJlYWRvbmx5XG4gKiBAY29uc3Qge251bWJlcn0gVmVyc2lvblxuICogQG1lbWJlcm9mIFRocmlmdC5Qcm90b2NvbFxuICovXG4gVGhyaWZ0LlByb3RvY29sLlZlcnNpb24gPSAxO1xuXG5UaHJpZnQuUHJvdG9jb2wucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcgdHJhbnNwb3J0LlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEByZXR1cm5zIHtUaHJpZnQuVHJhbnNwb3J0fSBUaGUgdW5kZXJseWluZyB0cmFuc3BvcnQuXG4gICAgICovIFxuICAgIGdldFRyYW5zcG9ydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgYmVnaW5uaW5nIG9mIGEgVGhyaWZ0IFJQQyBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIHNlcnZpY2UgbWV0aG9kIHRvIGNhbGwuXG4gICAgICogQHBhcmFtIHtUaHJpZnQuTWVzc2FnZVR5cGV9IG1lc3NhZ2VUeXBlIC0gVGhlIHR5cGUgb2YgbWV0aG9kIGNhbGwuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNlcWlkIC0gVGhlIHNlcXVlbmNlIG51bWJlciBvZiB0aGlzIGNhbGwgKGFsd2F5cyAwIGluIEFwYWNoZSBUaHJpZnQpLlxuICAgICAqL1xuICAgIHdyaXRlTWVzc2FnZUJlZ2luOiBmdW5jdGlvbihuYW1lLCBtZXNzYWdlVHlwZSwgc2VxaWQpIHtcbiAgICAgICAgdGhpcy50c3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy50cG9zID0gW107XG5cbiAgICAgICAgdGhpcy50c3RhY2sucHVzaChbVGhyaWZ0LlByb3RvY29sLlZlcnNpb24sICdcIicgK1xuICAgICAgICAgICAgbmFtZSArICdcIicsIG1lc3NhZ2VUeXBlLCBzZXFpZF0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIHRoZSBlbmQgb2YgYSBUaHJpZnQgUlBDIG1lc3NhZ2UuXG4gICAgICovXG4gICAgd3JpdGVNZXNzYWdlRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9iaiA9IHRoaXMudHN0YWNrLnBvcCgpO1xuXG4gICAgICAgIHRoaXMud29iaiA9IHRoaXMudHN0YWNrLnBvcCgpO1xuICAgICAgICB0aGlzLndvYmoucHVzaChvYmopO1xuXG4gICAgICAgIHRoaXMud2J1ZiA9ICdbJyArIHRoaXMud29iai5qb2luKCcsJykgKyAnXSc7XG5cbiAgICAgICAgdGhpcy50cmFuc3BvcnQud3JpdGUodGhpcy53YnVmKTtcbiAgICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgYmVnaW5uaW5nIG9mIGEgc3RydWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHN0cnVjdC5cbiAgICAgKi9cbiAgICB3cml0ZVN0cnVjdEJlZ2luOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHRoaXMudHBvcy5wdXNoKHRoaXMudHN0YWNrLmxlbmd0aCk7XG4gICAgICAgIHRoaXMudHN0YWNrLnB1c2goe30pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIHRoZSBlbmQgb2YgYSBzdHJ1Y3QuXG4gICAgICovXG4gICAgd3JpdGVTdHJ1Y3RFbmQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBwID0gdGhpcy50cG9zLnBvcCgpO1xuICAgICAgICB2YXIgc3RydWN0ID0gdGhpcy50c3RhY2tbcF07XG4gICAgICAgIHZhciBzdHIgPSAneyc7XG4gICAgICAgIHZhciBmaXJzdCA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzdHJ1Y3QpIHtcbiAgICAgICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0ciArPSAnLCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0ciArPSBrZXkgKyAnOicgKyBzdHJ1Y3Rba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0ciArPSAnfSc7XG4gICAgICAgIHRoaXMudHN0YWNrW3BdID0gc3RyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIHRoZSBiZWdpbm5pbmcgb2YgYSBzdHJ1Y3QgZmllbGQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZmllbGQuXG4gICAgICogQHBhcmFtIHtUaHJpZnQuUHJvdG9jb2wuVHlwZX0gZmllbGRUeXBlIC0gVGhlIGRhdGEgdHlwZSBvZiB0aGUgZmllbGQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZpZWxkSWQgLSBUaGUgZmllbGQncyB1bmlxdWUgaWRlbnRpZmllci5cbiAgICAgKi9cbiAgICB3cml0ZUZpZWxkQmVnaW46IGZ1bmN0aW9uKG5hbWUsIGZpZWxkVHlwZSwgZmllbGRJZCkge1xuICAgICAgICB0aGlzLnRwb3MucHVzaCh0aGlzLnRzdGFjay5sZW5ndGgpO1xuICAgICAgICB0aGlzLnRzdGFjay5wdXNoKHsgJ2ZpZWxkSWQnOiAnXCInICtcbiAgICAgICAgICAgIGZpZWxkSWQgKyAnXCInLCAnZmllbGRUeXBlJzogVGhyaWZ0LlByb3RvY29sLlR5cGVbZmllbGRUeXBlXVxuICAgICAgICB9KTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIHRoZSBlbmQgb2YgYSBmaWVsZC5cbiAgICAgKi9cbiAgICB3cml0ZUZpZWxkRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy50c3RhY2sucG9wKCk7XG4gICAgICAgIHZhciBmaWVsZEluZm8gPSB0aGlzLnRzdGFjay5wb3AoKTtcblxuICAgICAgICB0aGlzLnRzdGFja1t0aGlzLnRzdGFjay5sZW5ndGggLSAxXVtmaWVsZEluZm8uZmllbGRJZF0gPSAneycgK1xuICAgICAgICAgICAgZmllbGRJbmZvLmZpZWxkVHlwZSArICc6JyArIHZhbHVlICsgJ30nO1xuICAgICAgICB0aGlzLnRwb3MucG9wKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIGVuZCBvZiB0aGUgc2V0IG9mIGZpZWxkcyBmb3IgYSBzdHJ1Y3QuXG4gICAgICovXG4gICAgd3JpdGVGaWVsZFN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL25hXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIGJlZ2lubmluZyBvZiBhIG1hcCBjb2xsZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7VGhyaWZ0LlR5cGV9IGtleVR5cGUgLSBUaGUgZGF0YSB0eXBlIG9mIHRoZSBrZXkuXG4gICAgICogQHBhcmFtIHtUaHJpZnQuVHlwZX0gdmFsVHlwZSAtIFRoZSBkYXRhIHR5cGUgb2YgdGhlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZV0gLSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBtYXAgKGlnbm9yZWQpLlxuICAgICAqL1xuICAgIHdyaXRlTWFwQmVnaW46IGZ1bmN0aW9uKGtleVR5cGUsIHZhbFR5cGUsIHNpemUpIHtcbiAgICAgICAgdGhpcy50cG9zLnB1c2godGhpcy50c3RhY2subGVuZ3RoKTtcbiAgICAgICAgdGhpcy50c3RhY2sucHVzaChbVGhyaWZ0LlByb3RvY29sLlR5cGVba2V5VHlwZV0sXG4gICAgICAgICAgICBUaHJpZnQuUHJvdG9jb2wuVHlwZVt2YWxUeXBlXSwgMF0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIHRoZSBlbmQgb2YgYSBtYXAuXG4gICAgICovXG4gICAgd3JpdGVNYXBFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcCA9IHRoaXMudHBvcy5wb3AoKTtcblxuICAgICAgICBpZiAocCA9PSB0aGlzLnRzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgodGhpcy50c3RhY2subGVuZ3RoIC0gcCAtIDEpICUgMiAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy50c3RhY2sucHVzaCgnJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2l6ZSA9ICh0aGlzLnRzdGFjay5sZW5ndGggLSBwIC0gMSkgLyAyO1xuXG4gICAgICAgIHRoaXMudHN0YWNrW3BdW3RoaXMudHN0YWNrW3BdLmxlbmd0aCAtIDFdID0gc2l6ZTtcblxuICAgICAgICB2YXIgbWFwID0gJ30nO1xuICAgICAgICB2YXIgZmlyc3QgPSB0cnVlO1xuICAgICAgICB3aGlsZSAodGhpcy50c3RhY2subGVuZ3RoID4gcCArIDEpIHtcbiAgICAgICAgICAgIHZhciB2ID0gdGhpcy50c3RhY2sucG9wKCk7XG4gICAgICAgICAgICB2YXIgayA9IHRoaXMudHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFwID0gJywnICsgbWFwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoISBpc05hTihrKSkgeyBrID0gJ1wiJyArIGsgKyAnXCInOyB9IC8vanNvbiBcImtleXNcIiBuZWVkIHRvIGJlIHN0cmluZ3NcbiAgICAgICAgICAgIG1hcCA9IGsgKyAnOicgKyB2ICsgbWFwO1xuICAgICAgICB9XG4gICAgICAgIG1hcCA9ICd7JyArIG1hcDtcblxuICAgICAgICB0aGlzLnRzdGFja1twXS5wdXNoKG1hcCk7XG4gICAgICAgIHRoaXMudHN0YWNrW3BdID0gJ1snICsgdGhpcy50c3RhY2tbcF0uam9pbignLCcpICsgJ10nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIHRoZSBiZWdpbm5pbmcgb2YgYSBsaXN0IGNvbGxlY3Rpb24uXG4gICAgICogQHBhcmFtIHtUaHJpZnQuVHlwZX0gZWxlbVR5cGUgLSBUaGUgZGF0YSB0eXBlIG9mIHRoZSBlbGVtZW50cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSAtIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGxpc3QuXG4gICAgICovXG4gICAgd3JpdGVMaXN0QmVnaW46IGZ1bmN0aW9uKGVsZW1UeXBlLCBzaXplKSB7XG4gICAgICAgIHRoaXMudHBvcy5wdXNoKHRoaXMudHN0YWNrLmxlbmd0aCk7XG4gICAgICAgIHRoaXMudHN0YWNrLnB1c2goW1RocmlmdC5Qcm90b2NvbC5UeXBlW2VsZW1UeXBlXSwgc2l6ZV0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIHRoZSBlbmQgb2YgYSBsaXN0LlxuICAgICAqL1xuICAgIHdyaXRlTGlzdEVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwID0gdGhpcy50cG9zLnBvcCgpO1xuXG4gICAgICAgIHdoaWxlICh0aGlzLnRzdGFjay5sZW5ndGggPiBwICsgMSkge1xuICAgICAgICAgICAgdmFyIHRtcFZhbCA9IHRoaXMudHN0YWNrW3AgKyAxXTtcbiAgICAgICAgICAgIHRoaXMudHN0YWNrLnNwbGljZShwICsgMSwgMSk7XG4gICAgICAgICAgICB0aGlzLnRzdGFja1twXS5wdXNoKHRtcFZhbCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRzdGFja1twXSA9ICdbJyArIHRoaXMudHN0YWNrW3BdLmpvaW4oJywnKSArICddJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgYmVnaW5uaW5nIG9mIGEgc2V0IGNvbGxlY3Rpb24uXG4gICAgICogQHBhcmFtIHtUaHJpZnQuVHlwZX0gZWxlbVR5cGUgLSBUaGUgZGF0YSB0eXBlIG9mIHRoZSBlbGVtZW50cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSAtIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGxpc3QuXG4gICAgICovXG4gICAgd3JpdGVTZXRCZWdpbjogZnVuY3Rpb24oZWxlbVR5cGUsIHNpemUpIHtcbiAgICAgICAgdGhpcy50cG9zLnB1c2godGhpcy50c3RhY2subGVuZ3RoKTtcbiAgICAgICAgdGhpcy50c3RhY2sucHVzaChbVGhyaWZ0LlByb3RvY29sLlR5cGVbZWxlbVR5cGVdLCBzaXplXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIGVuZCBvZiBhIHNldC5cbiAgICAgKi9cbiAgICB3cml0ZVNldEVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwID0gdGhpcy50cG9zLnBvcCgpO1xuXG4gICAgICAgIHdoaWxlICh0aGlzLnRzdGFjay5sZW5ndGggPiBwICsgMSkge1xuICAgICAgICAgICAgdmFyIHRtcFZhbCA9IHRoaXMudHN0YWNrW3AgKyAxXTtcbiAgICAgICAgICAgIHRoaXMudHN0YWNrLnNwbGljZShwICsgMSwgMSk7XG4gICAgICAgICAgICB0aGlzLnRzdGFja1twXS5wdXNoKHRtcFZhbCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRzdGFja1twXSA9ICdbJyArIHRoaXMudHN0YWNrW3BdLmpvaW4oJywnKSArICddJztcbiAgICB9LFxuXG4gICAgLyoqIFNlcmlhbGl6ZXMgYSBib29sZWFuICovXG4gICAgd3JpdGVCb29sOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLnRzdGFjay5wdXNoKHZhbHVlID8gMSA6IDApO1xuICAgIH0sXG5cbiAgICAvKiogU2VyaWFsaXplcyBhIG51bWJlciAqL1xuICAgIHdyaXRlQnl0ZTogZnVuY3Rpb24oaTgpIHtcbiAgICAgICAgdGhpcy50c3RhY2sucHVzaChpOCk7XG4gICAgfSxcblxuICAgIC8qKiBTZXJpYWxpemVzIGEgbnVtYmVyICovXG4gICAgd3JpdGVJMTY6IGZ1bmN0aW9uKGkxNikge1xuICAgICAgICB0aGlzLnRzdGFjay5wdXNoKGkxNik7XG4gICAgfSxcblxuICAgIC8qKiBTZXJpYWxpemVzIGEgbnVtYmVyICovXG4gICAgd3JpdGVJMzI6IGZ1bmN0aW9uKGkzMikge1xuICAgICAgICB0aGlzLnRzdGFjay5wdXNoKGkzMik7XG4gICAgfSxcblxuICAgIC8qKiBTZXJpYWxpemVzIGEgbnVtYmVyICovXG4gICAgd3JpdGVJNjQ6IGZ1bmN0aW9uKGk2NCkge1xuICAgICAgICB0aGlzLnRzdGFjay5wdXNoKGk2NCk7XG4gICAgfSxcblxuICAgIC8qKiBTZXJpYWxpemVzIGEgbnVtYmVyICovXG4gICAgd3JpdGVEb3VibGU6IGZ1bmN0aW9uKGRibCkge1xuICAgICAgICB0aGlzLnRzdGFjay5wdXNoKGRibCk7XG4gICAgfSxcblxuICAgIC8qKiBTZXJpYWxpemVzIGEgc3RyaW5nICovXG4gICAgd3JpdGVTdHJpbmc6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAvLyBXZSBkbyBub3QgZW5jb2RlIHVyaSBjb21wb25lbnRzIGZvciB3aXJlIHRyYW5zZmVyOlxuICAgICAgICBpZiAoc3RyID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRzdGFjay5wdXNoKG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY29uY2F0IG1heSBiZSBzbG93ZXIgdGhhbiBidWlsZGluZyBhIGJ5dGUgYnVmZmVyXG4gICAgICAgICAgICB2YXIgZXNjYXBlZFN0cmluZyA9ICcnO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2ggPSBzdHIuY2hhckF0KGkpOyAgICAgIC8vIGEgc2luZ2xlIGRvdWJsZSBxdW90ZTogXCJcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXFwiJykge1xuICAgICAgICAgICAgICAgICAgICBlc2NhcGVkU3RyaW5nICs9ICdcXFxcXFxcIic7IC8vIHdyaXRlIG91dCBhczogXFxcIlxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcXFxcJykgeyAgICAvLyBhIHNpbmdsZSBiYWNrc2xhc2hcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlZFN0cmluZyArPSAnXFxcXFxcXFwnOyAvLyB3cml0ZSBvdXQgYXMgZG91YmxlIGJhY2tzbGFzaCBcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnXFxiJykgeyAgICAvLyBhIHNpbmdsZSBiYWNrc3BhY2U6IGludmlzaWJsZVxuICAgICAgICAgICAgICAgICAgICBlc2NhcGVkU3RyaW5nICs9ICdcXFxcYic7ICAvLyB3cml0ZSBvdXQgYXM6IFxcYlwiXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1xcZicpIHsgICAgLy8gYSBzaW5nbGUgZm9ybWZlZWQ6IGludmlzaWJsZVxuICAgICAgICAgICAgICAgICAgICBlc2NhcGVkU3RyaW5nICs9ICdcXFxcZic7ICAvLyB3cml0ZSBvdXQgYXM6IFxcZlwiXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1xcbicpIHsgICAgLy8gYSBzaW5nbGUgbmV3bGluZTogaW52aXNpYmxlXG4gICAgICAgICAgICAgICAgICAgIGVzY2FwZWRTdHJpbmcgKz0gJ1xcXFxuJzsgIC8vIHdyaXRlIG91dCBhczogXFxuXCJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnXFxyJykgeyAgICAvLyBhIHNpbmdsZSByZXR1cm46IGludmlzaWJsZVxuICAgICAgICAgICAgICAgICAgICBlc2NhcGVkU3RyaW5nICs9ICdcXFxccic7ICAvLyB3cml0ZSBvdXQgYXM6IFxcclwiXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1xcdCcpIHsgICAgLy8gYSBzaW5nbGUgdGFiOiBpbnZpc2libGVcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlZFN0cmluZyArPSAnXFxcXHQnOyAgLy8gd3JpdGUgb3V0IGFzOiBcXHRcIlxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVzY2FwZWRTdHJpbmcgKz0gY2g7ICAgICAvLyBFbHNlIGl0IG5lZWQgbm90IGJlIGVzY2FwZWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRzdGFjay5wdXNoKCdcIicgKyBlc2NhcGVkU3RyaW5nICsgJ1wiJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqIFNlcmlhbGl6ZXMgYSBzdHJpbmcgKi9cbiAgICB3cml0ZUJpbmFyeTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIHRoaXMud3JpdGVTdHJpbmcoc3RyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICAgQGNsYXNzXG4gICAgICAgQG5hbWUgQW5vblJlYWRNZXNzYWdlQmVnaW5SZXR1cm5cbiAgICAgICBAcHJvcGVydHkge3N0cmluZ30gZm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgc2VydmljZSBtZXRob2QuXG4gICAgICAgQHByb3BlcnR5IHtUaHJpZnQuTWVzc2FnZVR5cGV9IG10eXBlIC0gVGhlIHR5cGUgb2YgbWVzc2FnZSBjYWxsLlxuICAgICAgIEBwcm9wZXJ0eSB7bnVtYmVyfSByc2VxaWQgLSBUaGUgc2VxdWVuY2UgbnVtYmVyIG9mIHRoZSBtZXNzYWdlICgwIGluIFRocmlmdCBSUEMpLlxuICAgICAqL1xuICAgIC8qKiBcbiAgICAgKiBEZXNlcmlhbGl6ZXMgdGhlIGJlZ2lubmluZyBvZiBhIG1lc3NhZ2UuIFxuICAgICAqIEByZXR1cm5zIHtBbm9uUmVhZE1lc3NhZ2VCZWdpblJldHVybn1cbiAgICAgKi9cbiAgICByZWFkTWVzc2FnZUJlZ2luOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yc3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5ycG9zID0gW107XG5cbiAgICAgICAgaWYgKHR5cGVvZiBKU09OICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgSlNPTi5wYXJzZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5yb2JqID0gSlNPTi5wYXJzZSh0aGlzLnRyYW5zcG9ydC5yZWFkQWxsKCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBqUXVlcnkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLnJvYmogPSBqUXVlcnkucGFyc2VKU09OKHRoaXMudHJhbnNwb3J0LnJlYWRBbGwoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJvYmogPSBldmFsKHRoaXMudHJhbnNwb3J0LnJlYWRBbGwoKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgciA9IHt9O1xuICAgICAgICB2YXIgdmVyc2lvbiA9IHRoaXMucm9iai5zaGlmdCgpO1xuXG4gICAgICAgIGlmICh2ZXJzaW9uICE9IFRocmlmdC5Qcm90b2NvbC5WZXJzaW9uKSB7XG4gICAgICAgICAgICB0aHJvdyAnV3JvbmcgdGhyaWZ0IHByb3RvY29sIHZlcnNpb246ICcgKyB2ZXJzaW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgci5mbmFtZSA9IHRoaXMucm9iai5zaGlmdCgpO1xuICAgICAgICByLm10eXBlID0gdGhpcy5yb2JqLnNoaWZ0KCk7XG4gICAgICAgIHIucnNlcWlkID0gdGhpcy5yb2JqLnNoaWZ0KCk7XG5cblxuICAgICAgICAvL2dldCB0byB0aGUgbWFpbiBvYmpcbiAgICAgICAgdGhpcy5yc3RhY2sucHVzaCh0aGlzLnJvYmouc2hpZnQoKSk7XG5cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfSxcblxuICAgIC8qKiBEZXNlcmlhbGl6ZXMgdGhlIGVuZCBvZiBhIG1lc3NhZ2UuICovXG4gICAgcmVhZE1lc3NhZ2VFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIH0sXG5cbiAgICAvKiogXG4gICAgICogRGVzZXJpYWxpemVzIHRoZSBiZWdpbm5pbmcgb2YgYSBzdHJ1Y3QuIFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZV0gLSBUaGUgbmFtZSBvZiB0aGUgc3RydWN0IChpZ25vcmVkKVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IC0gQW4gb2JqZWN0IHdpdGggYW4gZW1wdHkgc3RyaW5nIGZuYW1lIHByb3BlcnR5XG4gICAgICovICAgIFxuICAgIHJlYWRTdHJ1Y3RCZWdpbjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB2YXIgciA9IHt9O1xuICAgICAgICByLmZuYW1lID0gJyc7XG5cbiAgICAgICAgLy9pbmNhc2UgdGhpcyBpcyBhbiBhcnJheSBvZiBzdHJ1Y3RzXG4gICAgICAgIGlmICh0aGlzLnJzdGFja1t0aGlzLnJzdGFjay5sZW5ndGggLSAxXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICB0aGlzLnJzdGFjay5wdXNoKHRoaXMucnN0YWNrW3RoaXMucnN0YWNrLmxlbmd0aCAtIDFdLnNoaWZ0KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfSxcblxuICAgIC8qKiBEZXNlcmlhbGl6ZXMgdGhlIGVuZCBvZiBhIHN0cnVjdC4gKi9cbiAgICByZWFkU3RydWN0RW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMucnN0YWNrW3RoaXMucnN0YWNrLmxlbmd0aCAtIDJdIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHRoaXMucnN0YWNrLnBvcCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAgIEBjbGFzc1xuICAgICAgIEBuYW1lIEFub25SZWFkRmllbGRCZWdpblJldHVyblxuICAgICAgIEBwcm9wZXJ0eSB7c3RyaW5nfSBmbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCAoYWx3YXlzICcnKS5cbiAgICAgICBAcHJvcGVydHkge1RocmlmdC5UeXBlfSBmdHlwZSAtIFRoZSBkYXRhIHR5cGUgb2YgdGhlIGZpZWxkLlxuICAgICAgIEBwcm9wZXJ0eSB7bnVtYmVyfSBmaWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGZpZWxkLlxuICAgICAqL1xuICAgIC8qKiBcbiAgICAgKiBEZXNlcmlhbGl6ZXMgdGhlIGJlZ2lubmluZyBvZiBhIGZpZWxkLiBcbiAgICAgKiBAcmV0dXJucyB7QW5vblJlYWRGaWVsZEJlZ2luUmV0dXJufVxuICAgICAqL1xuICAgIHJlYWRGaWVsZEJlZ2luOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHIgPSB7fTtcblxuICAgICAgICB2YXIgZmlkID0gLTE7XG4gICAgICAgIHZhciBmdHlwZSA9IFRocmlmdC5UeXBlLlNUT1A7XG5cbiAgICAgICAgLy9nZXQgYSBmaWVsZElkXG4gICAgICAgIGZvciAodmFyIGYgaW4gKHRoaXMucnN0YWNrW3RoaXMucnN0YWNrLmxlbmd0aCAtIDFdKSkge1xuICAgICAgICAgICAgaWYgKGYgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpZCA9IHBhcnNlSW50KGYsIDEwKTtcbiAgICAgICAgICAgIHRoaXMucnBvcy5wdXNoKHRoaXMucnN0YWNrLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIHZhciBmaWVsZCA9IHRoaXMucnN0YWNrW3RoaXMucnN0YWNrLmxlbmd0aCAtIDFdW2ZpZF07XG5cbiAgICAgICAgICAgIC8vcmVtb3ZlIHNvIHdlIGRvbid0IHNlZSBpdCBhZ2FpblxuICAgICAgICAgICAgZGVsZXRlIHRoaXMucnN0YWNrW3RoaXMucnN0YWNrLmxlbmd0aCAtIDFdW2ZpZF07XG5cbiAgICAgICAgICAgIHRoaXMucnN0YWNrLnB1c2goZmllbGQpO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaWQgIT0gLTEpIHtcblxuICAgICAgICAgICAgLy9zaG91bGQgb25seSBiZSAxIG9mIHRoZXNlIGJ1dCB0aGlzIGlzIHRoZSBvbmx5XG4gICAgICAgICAgICAvL3dheSB0byBtYXRjaCBhIGtleVxuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiAodGhpcy5yc3RhY2tbdGhpcy5yc3RhY2subGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKFRocmlmdC5Qcm90b2NvbC5SVHlwZVtpXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdHlwZSA9IFRocmlmdC5Qcm90b2NvbC5SVHlwZVtpXTtcbiAgICAgICAgICAgICAgICB0aGlzLnJzdGFja1t0aGlzLnJzdGFjay5sZW5ndGggLSAxXSA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnN0YWNrW3RoaXMucnN0YWNrLmxlbmd0aCAtIDFdW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgci5mbmFtZSA9ICcnO1xuICAgICAgICByLmZ0eXBlID0gZnR5cGU7XG4gICAgICAgIHIuZmlkID0gZmlkO1xuXG4gICAgICAgIHJldHVybiByO1xuICAgIH0sXG5cbiAgICAvKiogRGVzZXJpYWxpemVzIHRoZSBlbmQgb2YgYSBmaWVsZC4gKi9cbiAgICByZWFkRmllbGRFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcG9zID0gdGhpcy5ycG9zLnBvcCgpO1xuXG4gICAgICAgIC8vZ2V0IGJhY2sgdG8gdGhlIHJpZ2h0IHBsYWNlIGluIHRoZSBzdGFja1xuICAgICAgICB3aGlsZSAodGhpcy5yc3RhY2subGVuZ3RoID4gcG9zKSB7XG4gICAgICAgICAgICB0aGlzLnJzdGFjay5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAgIEBjbGFzc1xuICAgICAgIEBuYW1lIEFub25SZWFkTWFwQmVnaW5SZXR1cm5cbiAgICAgICBAcHJvcGVydHkge1RocmlmdC5UeXBlfSBrdHlwZSAtIFRoZSBkYXRhIHR5cGUgb2YgdGhlIGtleS5cbiAgICAgICBAcHJvcGVydHkge1RocmlmdC5UeXBlfSB2dHlwZSAtIFRoZSBkYXRhIHR5cGUgb2YgdGhlIHZhbHVlLlxuICAgICAgIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaXplIC0gVGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgbWFwLlxuICAgICAqL1xuICAgIC8qKiBcbiAgICAgKiBEZXNlcmlhbGl6ZXMgdGhlIGJlZ2lubmluZyBvZiBhIG1hcC4gXG4gICAgICogQHJldHVybnMge0Fub25SZWFkTWFwQmVnaW5SZXR1cm59XG4gICAgICovXG4gICAgcmVhZE1hcEJlZ2luOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMucnN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgZmlyc3QgPSBtYXAuc2hpZnQoKTtcbiAgICAgICAgaWYgKGZpcnN0IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICB0aGlzLnJzdGFjay5wdXNoKG1hcCk7XG4gICAgICAgICAgbWFwID0gZmlyc3Q7XG4gICAgICAgICAgZmlyc3QgPSBtYXAuc2hpZnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByID0ge307XG4gICAgICAgIHIua3R5cGUgPSBUaHJpZnQuUHJvdG9jb2wuUlR5cGVbZmlyc3RdO1xuICAgICAgICByLnZ0eXBlID0gVGhyaWZ0LlByb3RvY29sLlJUeXBlW21hcC5zaGlmdCgpXTtcbiAgICAgICAgci5zaXplID0gbWFwLnNoaWZ0KCk7XG5cblxuICAgICAgICB0aGlzLnJwb3MucHVzaCh0aGlzLnJzdGFjay5sZW5ndGgpO1xuICAgICAgICB0aGlzLnJzdGFjay5wdXNoKG1hcC5zaGlmdCgpKTtcblxuICAgICAgICByZXR1cm4gcjtcbiAgICB9LFxuXG4gICAgLyoqIERlc2VyaWFsaXplcyB0aGUgZW5kIG9mIGEgbWFwLiAqL1xuICAgIHJlYWRNYXBFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlYWRGaWVsZEVuZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgICBAY2xhc3NcbiAgICAgICBAbmFtZSBBbm9uUmVhZENvbEJlZ2luUmV0dXJuXG4gICAgICAgQHByb3BlcnR5IHtUaHJpZnQuVHlwZX0gZXR5cGUgLSBUaGUgZGF0YSB0eXBlIG9mIHRoZSBlbGVtZW50LlxuICAgICAgIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaXplIC0gVGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICAgKi9cbiAgICAvKiogXG4gICAgICogRGVzZXJpYWxpemVzIHRoZSBiZWdpbm5pbmcgb2YgYSBsaXN0LiBcbiAgICAgKiBAcmV0dXJucyB7QW5vblJlYWRDb2xCZWdpblJldHVybn1cbiAgICAgKi9cbiAgICByZWFkTGlzdEJlZ2luOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLnJzdGFja1t0aGlzLnJzdGFjay5sZW5ndGggLSAxXTtcblxuICAgICAgICB2YXIgciA9IHt9O1xuICAgICAgICByLmV0eXBlID0gVGhyaWZ0LlByb3RvY29sLlJUeXBlW2xpc3Quc2hpZnQoKV07XG4gICAgICAgIHIuc2l6ZSA9IGxpc3Quc2hpZnQoKTtcblxuICAgICAgICB0aGlzLnJwb3MucHVzaCh0aGlzLnJzdGFjay5sZW5ndGgpO1xuICAgICAgICB0aGlzLnJzdGFjay5wdXNoKGxpc3QpO1xuXG4gICAgICAgIHJldHVybiByO1xuICAgIH0sXG5cbiAgICAvKiogRGVzZXJpYWxpemVzIHRoZSBlbmQgb2YgYSBsaXN0LiAqL1xuICAgIHJlYWRMaXN0RW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZWFkRmllbGRFbmQoKTtcbiAgICB9LFxuXG4gICAgLyoqIFxuICAgICAqIERlc2VyaWFsaXplcyB0aGUgYmVnaW5uaW5nIG9mIGEgc2V0LiBcbiAgICAgKiBAcmV0dXJucyB7QW5vblJlYWRDb2xCZWdpblJldHVybn1cbiAgICAgKi9cbiAgICByZWFkU2V0QmVnaW46IGZ1bmN0aW9uKGVsZW1UeXBlLCBzaXplKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRMaXN0QmVnaW4oZWxlbVR5cGUsIHNpemUpO1xuICAgIH0sXG5cbiAgICAvKiogRGVzZXJpYWxpemVzIHRoZSBlbmQgb2YgYSBzZXQuICovXG4gICAgcmVhZFNldEVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRMaXN0RW5kKCk7XG4gICAgfSxcblxuICAgIC8qKiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIGEgdmFsdWUgcHJvcGVydHkgc2V0IHRvIFxuICAgICAqICBGYWxzZSB1bmxlc3MgdGhlIG5leHQgbnVtYmVyIGluIHRoZSBwcm90b2NvbCBidWZmZXIgXG4gICAgICogIGlzIDEsIGluIHdoaWNoIGNhc2UgdGhlIHZhbHVlIHByb3BlcnR5IGlzIFRydWUgKi9cbiAgICByZWFkQm9vbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByID0gdGhpcy5yZWFkSTMyKCk7XG5cbiAgICAgICAgaWYgKHIgIT09IG51bGwgJiYgci52YWx1ZSA9PSAnMScpIHtcbiAgICAgICAgICAgIHIudmFsdWUgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgci52YWx1ZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfSxcblxuICAgIC8qKiBSZXR1cm5zIHRoZSBhbiBvYmplY3Qgd2l0aCBhIHZhbHVlIHByb3BlcnR5IHNldCB0byB0aGUgXG4gICAgICAgIG5leHQgdmFsdWUgZm91bmQgaW4gdGhlIHByb3RvY29sIGJ1ZmZlciAqL1xuICAgIHJlYWRCeXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZEkzMigpO1xuICAgIH0sXG5cbiAgICAvKiogUmV0dXJucyB0aGUgYW4gb2JqZWN0IHdpdGggYSB2YWx1ZSBwcm9wZXJ0eSBzZXQgdG8gdGhlIFxuICAgICAgICBuZXh0IHZhbHVlIGZvdW5kIGluIHRoZSBwcm90b2NvbCBidWZmZXIgKi9cbiAgICByZWFkSTE2OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZEkzMigpO1xuICAgIH0sXG5cbiAgICAvKiogUmV0dXJucyB0aGUgYW4gb2JqZWN0IHdpdGggYSB2YWx1ZSBwcm9wZXJ0eSBzZXQgdG8gdGhlIFxuICAgICAgICBuZXh0IHZhbHVlIGZvdW5kIGluIHRoZSBwcm90b2NvbCBidWZmZXIgKi9cbiAgICByZWFkSTMyOiBmdW5jdGlvbihmKSB7XG4gICAgICAgIGlmIChmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGYgPSB0aGlzLnJzdGFja1t0aGlzLnJzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByID0ge307XG5cbiAgICAgICAgaWYgKGYgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgaWYgKGYubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgci52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgci52YWx1ZSA9IGYuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChmIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgIGZvciAodmFyIGkgaW4gZikge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yc3RhY2sucHVzaChmW2ldKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgZltpXTtcblxuICAgICAgICAgICAgICAgIHIudmFsdWUgPSBpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByLnZhbHVlID0gZjtcbiAgICAgICAgICAgIHRoaXMucnN0YWNrLnBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfSxcblxuICAgIC8qKiBSZXR1cm5zIHRoZSBhbiBvYmplY3Qgd2l0aCBhIHZhbHVlIHByb3BlcnR5IHNldCB0byB0aGUgXG4gICAgICAgIG5leHQgdmFsdWUgZm91bmQgaW4gdGhlIHByb3RvY29sIGJ1ZmZlciAqL1xuICAgIHJlYWRJNjQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkSTMyKCk7XG4gICAgfSxcblxuICAgIC8qKiBSZXR1cm5zIHRoZSBhbiBvYmplY3Qgd2l0aCBhIHZhbHVlIHByb3BlcnR5IHNldCB0byB0aGUgXG4gICAgICAgIG5leHQgdmFsdWUgZm91bmQgaW4gdGhlIHByb3RvY29sIGJ1ZmZlciAqL1xuICAgIHJlYWREb3VibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkSTMyKCk7XG4gICAgfSxcblxuICAgIC8qKiBSZXR1cm5zIHRoZSBhbiBvYmplY3Qgd2l0aCBhIHZhbHVlIHByb3BlcnR5IHNldCB0byB0aGUgXG4gICAgICAgIG5leHQgdmFsdWUgZm91bmQgaW4gdGhlIHByb3RvY29sIGJ1ZmZlciAqL1xuICAgIHJlYWRTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgciA9IHRoaXMucmVhZEkzMigpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9LFxuXG4gICAgLyoqIFJldHVybnMgdGhlIGFuIG9iamVjdCB3aXRoIGEgdmFsdWUgcHJvcGVydHkgc2V0IHRvIHRoZSBcbiAgICAgICAgbmV4dCB2YWx1ZSBmb3VuZCBpbiB0aGUgcHJvdG9jb2wgYnVmZmVyICovXG4gICAgcmVhZEJpbmFyeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRTdHJpbmcoKTtcbiAgICB9LFxuXG4gICAgLyoqIFxuICAgICAqIE1ldGhvZCB0byBhcmJpdHJhcmlseSBza2lwIG92ZXIgZGF0YSAqL1xuICAgIHNraXA6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgdmFyIHJldCwgaTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFRocmlmdC5UeXBlLlNUT1A6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICAgIGNhc2UgVGhyaWZ0LlR5cGUuQk9PTDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkQm9vbCgpO1xuXG4gICAgICAgICAgICBjYXNlIFRocmlmdC5UeXBlLkJZVEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZEJ5dGUoKTtcblxuICAgICAgICAgICAgY2FzZSBUaHJpZnQuVHlwZS5JMTY6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZEkxNigpO1xuXG4gICAgICAgICAgICBjYXNlIFRocmlmdC5UeXBlLkkzMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkSTMyKCk7XG5cbiAgICAgICAgICAgIGNhc2UgVGhyaWZ0LlR5cGUuSTY0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRJNjQoKTtcblxuICAgICAgICAgICAgY2FzZSBUaHJpZnQuVHlwZS5ET1VCTEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZERvdWJsZSgpO1xuXG4gICAgICAgICAgICBjYXNlIFRocmlmdC5UeXBlLlNUUklORzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkU3RyaW5nKCk7XG5cbiAgICAgICAgICAgIGNhc2UgVGhyaWZ0LlR5cGUuU1RSVUNUOlxuICAgICAgICAgICAgICAgIHRoaXMucmVhZFN0cnVjdEJlZ2luKCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gdGhpcy5yZWFkRmllbGRCZWdpbigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmV0LmZ0eXBlID09IFRocmlmdC5UeXBlLlNUT1ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2tpcChyZXQuZnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRGaWVsZEVuZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlYWRTdHJ1Y3RFbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICAgICAgY2FzZSBUaHJpZnQuVHlwZS5NQVA6XG4gICAgICAgICAgICAgICAgcmV0ID0gdGhpcy5yZWFkTWFwQmVnaW4oKTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmV0LnNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJzdGFjay5sZW5ndGggPiB0aGlzLnJwb3NbdGhpcy5ycG9zLmxlbmd0aCAtIDFdICsgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucnN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2tpcChyZXQua3R5cGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNraXAocmV0LnZ0eXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkTWFwRW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICAgIGNhc2UgVGhyaWZ0LlR5cGUuU0VUOlxuICAgICAgICAgICAgICAgIHJldCA9IHRoaXMucmVhZFNldEJlZ2luKCk7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHJldC5zaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5za2lwKHJldC5ldHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVhZFNldEVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgICBjYXNlIFRocmlmdC5UeXBlLkxJU1Q6XG4gICAgICAgICAgICAgICAgcmV0ID0gdGhpcy5yZWFkTGlzdEJlZ2luKCk7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHJldC5zaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5za2lwKHJldC5ldHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVhZExpc3RFbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuLyoqXG4gKiBJbml0aWFsaXplcyBhIE11dGlscGxleFByb3RvY29sIEltcGxlbWVudGF0aW9uIGFzIGEgV3JhcHBlciBmb3IgVGhyaWZ0LlByb3RvY29sXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuVGhyaWZ0Lk11bHRpcGxleFByb3RvY29sID0gZnVuY3Rpb24gKHNydk5hbWUsIHRyYW5zLCBzdHJpY3RSZWFkLCBzdHJpY3RXcml0ZSkge1xuICAgIFRocmlmdC5Qcm90b2NvbC5jYWxsKHRoaXMsIHRyYW5zLCBzdHJpY3RSZWFkLCBzdHJpY3RXcml0ZSk7XG4gICAgdGhpcy5zZXJ2aWNlTmFtZSA9IHNydk5hbWU7XG59O1xuVGhyaWZ0LmluaGVyaXRzKFRocmlmdC5NdWx0aXBsZXhQcm90b2NvbCwgVGhyaWZ0LlByb3RvY29sLCAnbXVsdGlwbGV4UHJvdG9jb2wnKTtcblxuLyoqIE92ZXJyaWRlIHdyaXRlTWVzc2FnZUJlZ2luIG1ldGhvZCBvZiBwcm90b3R5cGUqL1xuVGhyaWZ0Lk11bHRpcGxleFByb3RvY29sLnByb3RvdHlwZS53cml0ZU1lc3NhZ2VCZWdpbiA9IGZ1bmN0aW9uIChuYW1lLCB0eXBlLCBzZXFpZCkge1xuXG4gICAgaWYgKHR5cGUgPT09IFRocmlmdC5NZXNzYWdlVHlwZS5DQUxMIHx8IHR5cGUgPT09IFRocmlmdC5NZXNzYWdlVHlwZS5PTkVXQVkpIHtcbiAgICAgICAgVGhyaWZ0LlByb3RvY29sLnByb3RvdHlwZS53cml0ZU1lc3NhZ2VCZWdpbi5jYWxsKHRoaXMsIHRoaXMuc2VydmljZU5hbWUgKyBcIjpcIiArIG5hbWUsIHR5cGUsIHNlcWlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBUaHJpZnQuUHJvdG9jb2wucHJvdG90eXBlLndyaXRlTWVzc2FnZUJlZ2luLmNhbGwodGhpcywgbmFtZSwgdHlwZSwgc2VxaWQpO1xuICAgIH1cbn07XG5cblRocmlmdC5NdWx0aXBsZXhlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNlcWlkID0gMDtcbn07XG5cbi8qKiBJbnN0YW50aWF0ZXMgYSBtdWx0aXBsZXhlZCBjbGllbnQgZm9yIGEgc3BlY2lmaWMgc2VydmljZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VydmljZU5hbWUgLSBUaGUgdHJhbnNwb3J0IHRvIHNlcmlhbGl6ZSB0by9mcm9tLlxuICogQHBhcmFtIHtUaHJpZnQuU2VydmljZUNsaWVudH0gU0NsIC0gVGhlIFNlcnZpY2UgQ2xpZW50IENsYXNzXG4gKiBAcGFyYW0ge1RocmlmdC5UcmFuc3BvcnR9IHRyYW5zcG9ydCAtIFRocmlmdC5UcmFuc3BvcnQgaW5zdGFuY2Ugd2hpY2ggcHJvdmlkZXMgcmVtb3RlIGhvc3Q6cG9ydFxuICogQGV4YW1wbGVcbiAqICAgIHZhciBtcCA9IG5ldyBUaHJpZnQuTXVsdGlwbGV4ZXIoKTtcbiAqICAgIHZhciB0cmFuc3BvcnQgPSBuZXcgVGhyaWZ0LlRyYW5zcG9ydChcImh0dHA6Ly9sb2NhbGhvc3Q6OTA5MC9mb28udGhyaWZ0XCIpO1xuICogICAgdmFyIHByb3RvY29sID0gbmV3IFRocmlmdC5Qcm90b2NvbCh0cmFuc3BvcnQpO1xuICogICAgdmFyIGNsaWVudCA9IG1wLmNyZWF0ZUNsaWVudCgnQXV0aFNlcnZpY2UnLCBBdXRoU2VydmljZUNsaWVudCwgdHJhbnNwb3J0KTtcbiovXG5UaHJpZnQuTXVsdGlwbGV4ZXIucHJvdG90eXBlLmNyZWF0ZUNsaWVudCA9IGZ1bmN0aW9uIChzZXJ2aWNlTmFtZSwgU0NsLCB0cmFuc3BvcnQpIHtcbiAgICBpZiAoU0NsLkNsaWVudCkge1xuICAgICAgICBTQ2wgPSBTQ2wuQ2xpZW50O1xuICAgIH1cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgU0NsLnByb3RvdHlwZS5uZXdfc2VxaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuc2VxaWQgKz0gMTtcbiAgICAgICAgcmV0dXJuIHNlbGYuc2VxaWQ7XG4gICAgfTtcbiAgICB2YXIgY2xpZW50ID0gbmV3IFNDbChuZXcgVGhyaWZ0Lk11bHRpcGxleFByb3RvY29sKHNlcnZpY2VOYW1lLCB0cmFuc3BvcnQpKTtcblxuICAgIHJldHVybiBjbGllbnQ7XG59O1xuXG5cblxuXG4vL1xuLy8gSW50ZW5kZWQgZm9yIGluY2x1c2lvbiBhZnRlciB0aGUgYmFzZSwgZXh0ZXJuYWwgdGhyaWZ0LmpzIHNvdXJjZSBhbmQgZ2VuZXJhdGVkIGNvZGUuICBcbi8vIFRoaXMgb3ZlcnJpZGVzIHRoZSBmbGF0LW91dCBpbmNvcnJlY3QgdGhyaWZ0IGNvZGUgdGhhdCBuZWVkcyB0byBiZSByZXBhaXJlZC5cbi8vXG4vLyBOb3RlOiBpdCB3b3VsZCBiZSBiZXR0ZXIgaWYgdGhlc2UgZml4ZXMgY291bGQgYmUgaW50ZWdyYXRlZCBkaXJlY3RseSBpbnRvIHRoZSBcbi8vIHRocmlmdCByZXBvLCBidXQgdGhlIG92ZXJoZWFkIGFuZCB0dXJuLWFyb3VuZCB0aW1lIG9mIGRvaW5nIHRoaXMgcHJvcGVybHkgaXMsIFxuLy8gYXQgdGhlIG1vbWVudCwgbm90IGEgZ29vZCBmaXQgdG8gdGhlIG91ciBkZXZlbG9wbWVudCBwcm9jZXNzLlxuLy9cblxuXG4vLyBPdmVycmlkZSBUWEhSVHJhbnNwb3J0LmZsdXNoXG4vL1xuLy8gVGhlIHRyYW5zcG9ydCBmbHVzaCBtZXRob2QgaXMgKmJyb2tlbiouICBJdCB2aW9sYXRlcyB0aGUgYmFzaWMgcnVsZSB0aGFuIFxuLy8gYXN5bmNocm9ub3VzIGZ1bmN0aW9ucyBtdXN0ICphbHdheXMqIGNhbGwgdGhlIGNhbGxiYWNrLCBldmVuIG9uIGVycm9ycyBhbmQgXG4vLyBleGNlcHRpb25zLiAgVGhlIGJhc2UgMC45LjIgaW1wbGVtZW50YXRpb24gb25seSBjYWxscyB0aGUgY2FsbGJhY2sgb24gXG4vLyBzdGF0dXMgMjAwIGFuZCBuZXZlciBpbnZva2VzIHRoZSBjbGllbnQgY2FsbGJhY2sgb24gSFRUUCBzdGF0dXMgZXJyb3JzLlxuLy8gXG5UaHJpZnQuVFhIUlRyYW5zcG9ydC5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbihhc3luYywgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKChhc3luYyAmJiAhY2FsbGJhY2spIHx8IHRoaXMudXJsID09PSB1bmRlZmluZWQgfHwgdGhpcy51cmwgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmRfYnVmO1xuICAgIH1cblxuICAgIHZhciB4cmVxID0gdGhpcy5nZXRYbWxIdHRwUmVxdWVzdE9iamVjdCgpO1xuXG4gICAgaWYgKHhyZXEub3ZlcnJpZGVNaW1lVHlwZSkge1xuICAgICAgICB4cmVxLm92ZXJyaWRlTWltZVR5cGUoJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICB9XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgLy9JZ25vcmUgWEhSIGNhbGxiYWNrcyB1bnRpbCB0aGUgZGF0YSBhcnJpdmVzLCB0aGVuIGNhbGwgdGhlXG4gICAgICAgIC8vICBjbGllbnQncyBjYWxsYmFja1xuICAgICAgICAvLz09PT09PT09XG4gICAgICAgIC8vIEJFR0lOIENPREUgUEFUQ0ggXG4gICAgICAgIC8vPT09PT09PT1cbiAgICAgICAgLypcbiAgICAgICAgICB4cmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IFxuICAgICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjbGllbnRDYWxsYmFjayA9IGNhbGxiYWNrOyAgICBcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PSA0ICYmIHRoaXMuc3RhdHVzID09IDIwMCkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2V0UmVjdkJ1ZmZlcih0aGlzLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgY2xpZW50Q2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KCkpO1xuICAgICAgICAqL1xuICAgICAgICAvLz09PT09PT09XG4gICAgICAgIC8vIE1PRElGSUVEIENPREVcbiAgICAgICAgLy89PT09PT09PVxuICAgICAgICB4cmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PSA0KSB7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBUaGUgaW5jb21pbmcgY2FsbGJhY2sgZG9lc24ndCBhY3R1YWxseSB0YWtlIGFuIGVycm9yIG9iamVjdFxuICAgICAgICAgICAgICAgIC8vIChhbm90aGVyIGxpbWl0YXRpb24gb2YgdGhlIHRocmlmdCBjb2RlKSBzbyB0aGVyZSdzIG5vIHdheVxuICAgICAgICAgICAgICAgIC8vIHRvIHByb3Blcmx5IG1vdmUgdGhlIHN0YXR1cyBjb2RlIGVycm9yIGJhY2sgdG8gY2xpZW50IGNhbGxiYWNrLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gVG8gd29ya2Fyb3VuZCB0aGlzLCBzaG9ydCBvZiBtYWtpbmcgc2lnbmZpY2FudCBwYXRjaGVzIHRvIHRoZVxuICAgICAgICAgICAgICAgIC8vIFRocmlmdCBsaWJyYXJ5LCB3ZSAqcmVseSBvbiB0aGUgZmFjdCB0aGF0IHdlJ3JlIHVzaW5nIGEgSlNPTlxuICAgICAgICAgICAgICAgIC8vIHByb3RvY29sKiBhbmQgc2V0IHRoZSBidWZmZXIgdG8gaW52YWxpZCBKU09OLiAgVGhlIHRydWUgZXJyb3JcbiAgICAgICAgICAgICAgICAvLyBnZXRzIGxvc3QsIGJ1dCBhdCBsZWFzdCB0aGUgY2xpZW50IGlzIGluZm9ybWVkIG9mICphKiBmYWlsdXJlXG4gICAgICAgICAgICAgICAgLy8gcmF0aGVyIHRoYW4gcmFkaW8gc2lsZW5jZS5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIHZhciBlcnIgPSAodGhpcy5zdGF0dXMgPT0gMjAwKSA/IGZhbHNlIDogdHJ1ZTtcbiAgICAgICAgICAgICAgICBzZWxmLnNldFJlY3ZCdWZmZXIoZXJyID8gXCJodHRwX3N0YXR1c19ub3RfMjAwXCIgOiB0aGlzLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy89PT09PT09PVxuICAgICAgICAvLyBFTkQgQ09ERSBQQVRDSFxuICAgICAgICAvLz09PT09PT09XG4gICAgfVxuXG4gICAgeHJlcS5vcGVuKCdQT1NUJywgdGhpcy51cmwsICEhYXN5bmMpO1xuICAgIHhyZXEuc2VuZCh0aGlzLnNlbmRfYnVmKTtcbiAgICBpZiAoYXN5bmMgJiYgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh4cmVxLnJlYWR5U3RhdGUgIT0gNCkge1xuICAgICAgICB0aHJvdyAnZW5jb3VudGVyZWQgYW4gdW5rbm93biBhamF4IHJlYWR5IHN0YXRlOiAnICsgeHJlcS5yZWFkeVN0YXRlO1xuICAgIH1cblxuICAgIGlmICh4cmVxLnN0YXR1cyAhPSAyMDApIHtcbiAgICAgICAgdGhyb3cgJ2VuY291bnRlcmVkIGEgdW5rbm93biByZXF1ZXN0IHN0YXR1czogJyArIHhyZXEuc3RhdHVzO1xuICAgIH1cblxuICAgIHRoaXMucmVjdl9idWYgPSB4cmVxLnJlc3BvbnNlVGV4dDtcbiAgICB0aGlzLnJlY3ZfYnVmX3N6ID0gdGhpcy5yZWN2X2J1Zi5sZW5ndGg7XG4gICAgdGhpcy53cG9zID0gdGhpcy5yZWN2X2J1Zi5sZW5ndGg7XG4gICAgdGhpcy5ycG9zID0gMDtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmNyb3V0b25fdGhyaWZ0ID0gY3JvdXRvbl90aHJpZnQ7XG5tb2R1bGUuZXhwb3J0cy5UaHJpZnQgPSBUaHJpZnQ7XG59KSgpOyIsIi8vIFByb3ZpZGUgYW4gSFRNTCBkZWJ1ZyBvdmVybGF5IERJViB3aXRoIHN0YXR1cyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcnVubmluZ1xuLy8gY3J1bnRpbWUuXG4vL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjcikge1xuICAgIGNyLm9uKFwib3B0aW9ucy5zZXRfZGVidWdcIiwgZnVuY3Rpb24oY3IsIGVuYWJsZWQpIHtcbiAgICAgICAgdXBkYXRlRGVidWdPdmVybGF5KGNyLCBlbmFibGVkKTtcbiAgICB9KTtcbn07XG5cbnZhciBnRGVidWdPdmVybGF5RW5hYmxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiB1cGRhdGVEZWJ1Z092ZXJsYXkoY3IsIGVuYWJsZWQpIHtcbiAgICBcbiAgICAvLyBJZ25vcmUgdGhlIGNhc2Ugb2YgZGVidWdnaW5nIGJlaW5nIGVuYWJsZWQgdGhlbiBkaXNhYmxlZCBmb3JcbiAgICAvLyByZWFzb25zIG9mIGVuZ2luZWVyaW5nIHByaW9yaXRpemF0aW9uIChub3QgY29ycmVjdG5lc3MhKS5cbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZ0RlYnVnT3ZlcmxheUVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGdEZWJ1Z092ZXJsYXlFbmFibGVkID0gdHJ1ZTtcblxuICAgIGNyLm9uKFwic3BhbnNfcmVjb3JkZWRcIiwgZnVuY3Rpb24oc3BhbnMpIHtcbiAgICAgICAgdmFyIGksIGxpbmssIGRpdjtcbiAgICAgICAgdmFyIG9wdHMgPSBjci5vcHRpb25zKCk7XG5cbiAgICAgICAgLy8gRm9yIG5vdyBhc3N1bWUgaHR0cCBhbmQgYXNzdW1lIHRoZSBwb3J0IG9mIHRoZSB3ZWJcbiAgICAgICAgLy8gc2VydmVyLlxuICAgICAgICB2YXIgaG9zdCA9IG9wdHMuc2VydmljZV9ob3N0O1xuICAgICAgICBpZiAoaG9zdC5tYXRjaCgvXmFwaVsuLV0vKSkge1xuICAgICAgICAgICAgaG9zdCA9IGhvc3QucmVwbGFjZSgvXmFwaVsuLV0vLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXJsID0gXCJodHRwOi8vXCIgKyBob3N0ICsgXCI6MTAwMDEvXCIgKyBvcHRzLmFjY2Vzc190b2tlbiArIFwiL1wiO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBlbGVtZW50IGlzIHRoZXJlLCBhcyBzb21lIGluLXBhZ2Ugc2NyaXB0IG1pZ2h0IGhhdmVcbiAgICAgICAgLy8gY2xlYXJlZCB0aGUgQk9EWSwgZXRjLlxuICAgICAgICB2YXIgb3ZlcmxheSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidHJhY2VndWlkZV9vdmVybGF5XCIpO1xuICAgICAgICBpZiAoIW92ZXJsYXkpIHtcbiAgICAgICAgICAgIG92ZXJsYXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgb3ZlcmxheS5pZCA9IFwidHJhY2VndWlkZV9vdmVybGF5XCI7XG4gICAgICAgICAgICBvdmVybGF5LnN0eWxlLnBvc2l0aW9uID0gXCJmaXhlZFwiO1xuICAgICAgICAgICAgb3ZlcmxheS5zdHlsZS5ib3R0b20gPSBcIjBcIjtcbiAgICAgICAgICAgIG92ZXJsYXkuc3R5bGUucmlnaHQgPSBcIjBcIjtcbiAgICAgICAgICAgIG92ZXJsYXkuc3R5bGUud2lkdGggPSBcIjI0MHB4XCI7XG4gICAgICAgICAgICBvdmVybGF5LnN0eWxlLmhlaWdodCA9IFwiMTIwcHhcIjtcbiAgICAgICAgICAgIG92ZXJsYXkuc3R5bGUucGFkZGluZyA9IFwiNHB4XCI7XG4gICAgICAgICAgICBvdmVybGF5LnN0eWxlLmJvcmRlciA9IFwic29saWQgMXB4ICNGRkZcIjtcbiAgICAgICAgICAgIG92ZXJsYXkuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCIjMDA2MGEyXCI7XG4gICAgICAgICAgICBvdmVybGF5LnN0eWxlLmNvbG9yID0gXCIjRkZGXCI7XG4gICAgICAgICAgICBvdmVybGF5LnN0eWxlLmZvbnRTaXplID0gXCIxMnB4XCI7XG4gICAgICAgICAgICBvdmVybGF5LnN0eWxlLmZvbnRGYW1pbHkgPSBcInNhbnMtc2VyaWZcIjtcbiAgICAgICAgICAgIG92ZXJsYXkuc3R5bGUub3BhY2l0eSA9IFwiMC43XCI7XG5cbiAgICAgICAgICAgIHZhciBjbG9zZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBjbG9zZS5zdHlsZS5mbG9hdCA9IFwicmlnaHRcIjtcbiAgICAgICAgICAgIGNsb3NlLnN0eWxlLmN1cnNvciA9IFwicG9pbnRlclwiO1xuICAgICAgICAgICAgY2xvc2Uuc3R5bGUuY29sb3IgPSBcIiNGRkZcIjtcbiAgICAgICAgICAgIGNsb3NlLm9uY2xpY2sgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgICAgICBvdmVybGF5LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjbG9zZS5pbm5lckhUTUwgPSBcIlhcIjtcbiAgICAgICAgICAgIG92ZXJsYXkuYXBwZW5kQ2hpbGQoY2xvc2UpO1xuXG4gICAgICAgICAgICBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgICAgICAgICBsaW5rLmhyZWYgPSB1cmw7XG4gICAgICAgICAgICBsaW5rLnN0eWxlLmNvbG9yID0gXCIjRkZGXCI7XG4gICAgICAgICAgICBsaW5rLnN0eWxlLmZvbnRXZWlnaHQgPSBcImJvbGRcIjtcbiAgICAgICAgICAgIGxpbmsuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwidHJhY2VndWlkZS5pb1wiKSApO1xuICAgICAgICAgICAgdmFyIHRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHRpdGxlLmFwcGVuZENoaWxkKGxpbmspO1xuICAgICAgICAgICAgb3ZlcmxheS5hcHBlbmRDaGlsZCh0aXRsZSk7XG5cbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob3ZlcmxheSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIga01heFNwYW5zID0gNDtcbiAgICAgICAgdmFyIHRvdGFsTGlua3MgPSAwO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvdmVybGF5LmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IG92ZXJsYXkuY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5jbGFzc05hbWUgPT0gXCJ0cmFjZWd1aWRlX3NwYW5cIikge1xuICAgICAgICAgICAgICAgIHRvdGFsTGlua3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGFkZGVkIGtNYXhTcGFucysxIGxpbmVzIGJlbG93IHRoZVxuICAgICAgICAvLyAnaGVhZGVyJywgdGhlbiBkb24ndCBhZGQgYW55dGhpbmcgZWxzZS5cbiAgICAgICAgaWYgKHRvdGFsTGlua3MgPiBrTWF4U3BhbnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvIGEgcHJpbWl0aXZlIHRyYWNlIGpvaW5pbmcgaGVyZTogb25seSBzaG93IG9uZSBsaW5rIHBlclxuICAgICAgICAvLyB0cmFjZSAoaS5lLiBvbmUgbGluayBwZXIgc2V0IG9mIHNwYW5zIHRoYXQgd2lsbCBiZVxuICAgICAgICAvLyBjb21iaW5lZCkuIFdlIG1ha2UgdGhlIChwb3NzaWJseSBub3QgdHJ1ZSkgYXNzdW1wdGlvbiB0aGF0XG4gICAgICAgIC8vIGFsbCBzcGFucyBpbiBhIHRyYWNlIHdpbGwgYXJyaXZlIGluIHRoZSBzYW1lIGV2ZW50IChqdXN0IHRvXG4gICAgICAgIC8vIGtlZXAgdGhpbmdzIHNpbXBsZSkuXG4gICAgICAgIHZhciBqb2luZWRTcGFucyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGpvaW5lZFNwYW5zLnB1c2goe1xuICAgICAgICAgICAgICAgIGpvaW5faWRzIDogc3BhbnNbaV0uam9pbl9pZHMsXG4gICAgICAgICAgICAgICAgc3VtbWFyeSA6IHNwYW5zW2ldLnNwYW5fbmFtZSxcbiAgICAgICAgICAgICAgICBvbGRlc3RfbWljcm9zIDogc3BhbnNbaV0ub2xkZXN0X21pY3JvcyxcbiAgICAgICAgICAgICAgICB5b3VuZ2VzdF9taWNyb3MgOiBzcGFuc1tpXS55b3VuZ2VzdF9taWNyb3MsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgam9pbmVkU3BhbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBpICsgMTsgaiA8IGpvaW5lZFNwYW5zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKChqb2luZWRTcGFuc1tqXS5vbGRlc3RfbWljcm9zIDw9IGpvaW5lZFNwYW5zW2ldLnlvdW5nZXN0X21pY3JvcyAmJlxuICAgICAgICAgICAgICAgICAgICAgam9pbmVkU3BhbnNbal0ueW91bmdlc3RfbWljcm9zID49IGpvaW5lZFNwYW5zW2ldLm9sZGVzdF9taWNyb3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqb2luZWRTcGFuc1tqXS5vbGRlc3RfbWljcm9zIDwgam9pbmVkU3BhbnNbaV0ub2xkZXN0X21pY3Jvcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgam9pbmVkU3BhbnNbaV0uc3VtbWFyeSA9IGpvaW5lZFNwYW5zW2pdLnN1bW1hcnkgKyBcIiwgXCIgKyBqb2luZWRTcGFuc1tpXS5zdW1tYXJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgam9pbmVkU3BhbnNbaV0ub2xkZXN0X21pY3JvcyA9IGpvaW5lZFNwYW5zW2pdLm9sZGVzdF9taWNyb3M7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqb2luZWRTcGFuc1tpXS5zdW1tYXJ5ICs9IFwiLCBcIiArIGpvaW5lZFNwYW5zW2pdLnN1bW1hcnk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGpvaW5lZFNwYW5zW2pdLnlvdW5nZXN0X21pY3JvcyA+IGpvaW5lZFNwYW5zW2ldLnlvdW5nZXN0X21pY3Jvcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgam9pbmVkU3BhbnNbaV0ueW91bmdlc3RfbWljcm9zID0gam9pbmVkU3BhbnNbal0ueW91bmdlc3RfbWljcm9zO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGpvaW5lZFNwYW5zW2pdID0gam9pbmVkU3BhbnNbam9pbmVkU3BhbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGpvaW5lZFNwYW5zID0gam9pbmVkU3BhbnMuc2xpY2UoMCwgam9pbmVkU3BhbnMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIGogPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGpvaW5lZFNwYW5zLmxlbmd0aCAmJiB0b3RhbExpbmtzIDw9IGtNYXhTcGFuczsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgam9pbl9rZXkgPSBcIlwiO1xuICAgICAgICAgICAgdmFyIGpvaW5fdXJsX3ZhbCA9IFwiXCI7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gam9pbmVkU3BhbnNbaV0uam9pbl9pZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoam9pbmVkU3BhbnNbaV0uam9pbl9pZHMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBQcmVmZXIgZW5kX3VzZXJfaWQgaWYgaXQgZXhpc3RzXG4gICAgICAgICAgICAgICAgICAgIGlmIChqb2luX2tleSA9PT0gXCJcIiB8fCBrZXkgPT0gXCJlbmRfdXNlcl9pZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqb2luX2tleSA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpvaW5fdXJsX3ZhbCA9IGVuY29kZVVSSUNvbXBvbmVudChqb2luZWRTcGFuc1tpXS5qb2luX2lkc1trZXldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqb2luX2tleSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgZGl2LmNsYXNzTmFtZSA9IFwidHJhY2VndWlkZV9zcGFuXCI7XG5cbiAgICAgICAgICAgIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgaGFsZndheSBwb2ludCBiZXR3ZWVuIHRoZSBlbmRwb2ludHMgaW4gY2FzZVxuICAgICAgICAgICAgLy8gc29tZSBmdXJ0aGVyIHRpbWUgY29ycmVjdGlvbiBoYXBwZW5zLlxuICAgICAgICAgICAgdmFyIG1pY3JvcyA9IE1hdGgucm91bmQoam9pbmVkU3BhbnNbaV0ueW91bmdlc3RfbWljcm9zIC8gMiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqb2luZWRTcGFuc1tpXS5vbGRlc3RfbWljcm9zIC8gMik7XG4gICAgICAgICAgICBsaW5rLmhyZWYgPSB1cmwgKyBcInRyYWNlL1wiICsgam9pbl9rZXkgK1xuICAgICAgICAgICAgICAgIFwiP2pvaW5fdmFsPVwiICsgam9pbl91cmxfdmFsICtcbiAgICAgICAgICAgICAgICBcIiZhdF9taWNyb3M9XCIgKyBtaWNyb3M7XG4gICAgICAgICAgICBsaW5rLnN0eWxlLmNvbG9yID0gXCIjRkZGXCI7XG4gICAgICAgICAgICBsaW5rLnN0eWxlLndoaXRlU3BhY2UgPSBcIm5vd3JhcFwiO1xuICAgICAgICAgICAgbGluay5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShqb2luZWRTcGFuc1tpXS5zdW1tYXJ5KSk7XG4gICAgICAgICAgICBkaXYuYXBwZW5kQ2hpbGQobGluayk7XG5cbiAgICAgICAgICAgIG92ZXJsYXkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgICAgICAgIHRvdGFsTGlua3MrKztcbiAgICAgICAgfVxuICAgIH0pO1xufVxuIiwiLy8gQ29sbGVjdCByZWxldmFudCBpbmZvIGFib3V0IHRoZSBlbnZpcm9ubWVudCB3ZSdyZSBydW5uaW5nIGluXG4vL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjcikge1xuXG4gICAgdmFyIGF0dHJzID0ge307XG5cbiAgICBhdHRycy5uYXZpZ2F0b3JfYXZhaWxhYmxlID0gbmF2aWdhdG9yID8gXCJ0cnVlXCIgOiBcImZhbHNlXCI7XG4gICAgaWYgKG5hdmlnYXRvcikge1xuICAgICAgICBhdHRycy5uYXZpZ2F0b3JfYXBwX2NvZGVfbmFtZSA9IG5hdmlnYXRvci5hcHBDb2RlTmFtZTtcbiAgICAgICAgYXR0cnMubmF2aWdhdG9yX2FwcF9uYW1lICAgICAgPSBuYXZpZ2F0b3IuYXBwTmFtZTtcbiAgICAgICAgYXR0cnMubmF2aWdhdG9yX2FwcF92ZXJzaW9uICAgPSBuYXZpZ2F0b3IuYXBwVmVyc2lvbjtcbiAgICAgICAgYXR0cnMubmF2aWdhdG9yX2RvX25vdF90cmFjayAgPSBuYXZpZ2F0b3IuZG9Ob3RUcmFjaztcbiAgICAgICAgYXR0cnMubmF2aWdhdG9yX2xhbmd1YWdlICAgICAgPSBuYXZpZ2F0b3IubGFuZ3VhZ2U7XG4gICAgICAgIGF0dHJzLm5hdmlnYXRvcl9sYW5ndWFnZXMgICAgID0gbmF2aWdhdG9yLmxhbmd1YWdlcztcbiAgICAgICAgYXR0cnMubmF2aWdhdG9yX3BsYXRmb3JtICAgICAgPSBuYXZpZ2F0b3IucGxhdGZvcm07XG4gICAgICAgIGF0dHJzLm5hdmlnYXRvcl9wcm9kdWN0ICAgICAgID0gbmF2aWdhdG9yLnByb2R1Y3Q7XG4gICAgICAgIGF0dHJzLm5hdmlnYXRvcl9wcm9kdWN0X3N1YiAgID0gbmF2aWdhdG9yLnByb2R1Y3RTdWI7XG4gICAgICAgIGF0dHJzLm5hdmlnYXRvcl91c2VyX2FnZW50ICAgID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICAgICAgYXR0cnMubmF2aWdhdG9yX3ZlbmRvciAgICAgICAgPSBuYXZpZ2F0b3IudmVuZG9yO1xuICAgICAgICBhdHRycy5uYXZpZ2F0b3JfdmVuZG9yX3N1YiAgICA9IG5hdmlnYXRvci52ZW5kb3JTdWI7XG4gICAgfVxuXG4gICAgYXR0cnMuc2NyZWVuX2F2YWlsYWJsZSA9IHNjcmVlbiA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiO1xuICAgIGlmIChzY3JlZW4pIHtcbiAgICAgICAgYXR0cnMuc2NyZWVuX3dpZHRoICA9IHNjcmVlbi53aWR0aDtcbiAgICAgICAgYXR0cnMuc2NyZWVuX2hlaWdodCA9IHNjcmVlbi5oZWlnaHQ7XG4gICAgfVxuXG4gICAgYXR0cnMud2luZG93X2F2YWlsYWJsZSA9IHdpbmRvdyA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiO1xuICAgIGlmICh3aW5kb3cpIHtcbiAgICAgICAgYXR0cnMud2luZG93X2lubmVyX3dpZHRoICA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICBhdHRycy53aW5kb3dfaW5uZXJfaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIH1cblxuICAgIGF0dHJzLmRvY3VtZW50X2F2YWlsYWJsZSA9IGRvY3VtZW50ID8gXCJ0cnVlXCIgOiBcImZhbHNlXCI7XG4gICAgaWYgKGRvY3VtZW50KSB7XG4gICAgICAgIGF0dHJzLmRvY3VtZW50X2RvbWFpbiAgICAgICA9IGRvY3VtZW50LmRvbWFpbjtcbiAgICAgICAgYXR0cnMuZG9jdW1lbnRfdXJpICAgICAgICAgID0gZG9jdW1lbnQuZG9jdW1lbnRVUkk7XG4gICAgICAgIGF0dHJzLmRvY3VtZW50X3JlZmVycmVyICAgICA9IGRvY3VtZW50LnJlZmVycmVyO1xuICAgICAgICBhdHRycy5kb2N1bWVudF9kb2N0eXBlICAgICAgPSBkb2N1bWVudC5kb2N0eXBlO1xuICAgIH1cblxuXG4gICAgdmFyIG1lbW9yeUF2YWlsYWJsZSA9ICh3aW5kb3cgJiYgd2luZG93LnBlcmZvcm1hbmNlICYmIHdpbmRvdy5wZXJmb3JtYW5jZS5tZW1vcnkpO1xuICAgIGF0dHJzLnBlcmZvcm1hbmNlX21lbW9yeV9hdmFpbGFibGUgPSBtZW1vcnlBdmFpbGFibGUgPyBcInRydWVcIiA6IFwiZmFsc2VcIjtcbiAgICBpZiAobWVtb3J5QXZhaWxhYmxlKSB7XG4gICAgICAgIHZhciBtZW0gPSBwZXJmb3JtYW5jZS5tZW1vcnk7XG4gICAgICAgIGF0dHJzLnBlcmZvcm1hbmNlX21lbW9yeV9qc19oZWFwX3NpemVfbGltaXQgPSBtZW0uanNIZWFwU2l6ZUxpbWl0O1xuICAgICAgICBhdHRycy5wZXJmb3JtYW5jZV9tZW1vcnlfdG90YWxfanNfaGVhcF9zaXplID0gbWVtLnRvdGFsSlNIZWFwU2l6ZTtcbiAgICAgICAgYXR0cnMucGVyZm9ybWFuY2VfbWVtb3J5X3VzZWRfanNfaGVhcF9zaXplICA9IG1lbS51c2VkSlNIZWFwU2l6ZTtcbiAgICB9XG5cbiAgICBjci5hdHRyaWJ1dGVzKGF0dHJzKTtcbn07XG4iLCIvLyBBdXRvLWluc3RydW1lbnQgQUpBWCBjYWxscy5cbi8vXG4vLyBDaHJvbWUgNDEgKGF0IGxlYXN0KSwgZG9lcyBub3QgYWxsb3cgdGhlIFhNTEh0dHBSZXF1ZXN0IG9iamVjdFxuLy8gdG8gYmUgdXNlZCBpbiBhIHR5cGljYWwgSlMgcHJvdG90eXBlIGluaGVyaXRhbmNlIHBhdHRlcm46IGkuZS4gXG4vLyBpbmhlcml0aW5nIGFuZCBvdmVycmlkaW5nIGZ1bmN0aW9ucyBkb2Vzbid0IFwianVzdCB3b3JrXCIgZm9yIFhNTEh0dHBSZXF1ZXN0LlxuLy8gR2l2ZW4gdGhlIFhIUiB2ZXJzaW9ucyBhbmQgYmVoYXZpb3JhbCAvIHByb3BlcnR5IGRpZmZlcmVuY2VzXG4vLyBiZXR3ZWVuIGJyb3dzZXJzIGZvciB0aGlzIG9iamVjdCwgcmVpbXBsZW1lbnRpbmcgYSBmdWxsIHByb3h5IHZpYVxuLy8gY29tcG9zaXRpb24gaXMgYSBiaXQgb2YgbmlnaHRtYXJlLlxuLy9cbi8vIFRoZSBhcHByb2FjaCBoZXJlIGlzIHRvIHByb3h5IG9uIHRoZSBnbG9iYWwgcHJvdG90eXBlIGFuZCBhdHRhY2hcbi8vIG5ldyBwcm9wZXJ0aWVzIHRvIHRoZSBvYmplY3RzIGFzIHRoZSBjYWxscyBjb21lIHRocm91Z2guIFNsaWdodGx5XG4vLyBsZXNzIGVsZWdhbnQsIGJ1dCB3b3Jrcy5cbi8vIFxuLy8gVXNlZnVsOlxuLy8gLSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvWE1MSHR0cFJlcXVlc3Rcbi8vIC0gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy85MTgxMDkwL2lzLW9ubG9hZC1lcXVhbC10by1yZWFkeXN0YXRlLTQtaW4teG1saHR0cHJlcXVlc3Rcbi8vIC0gaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvYmxvYi9tYXN0ZXIvc3JjL2FqYXgveGhyLmpzXG4vLyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L2Jsb2IvbWFzdGVyL3NyYy9hamF4LmpzXG4vL1xuXG52YXIga01heFVSTFNuaXBwZXRMZW5ndGggPSA2NDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3IpIHtcbiAgICBpZiAoIXdpbmRvdy5YTUxIdHRwUmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3hpZWQgPSB7XG4gICAgICAgIG9wZW4gOiBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUub3BlbixcbiAgICAgICAgc2VuZCA6IFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5zZW5kLFxuICAgIH07XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uKG1ldGhvZCwgdXJsKSB7XG4gICAgICAgIGlmIChza2lwSW5zdHJ1bWVudGF0aW9uKGNyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHByb3hpZWQub3Blbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNwYW4gPSBjci5zcGFuKFwiWE1MSHR0cFJlcXVlc3RcIik7XG4gICAgICAgIGNyLnNwYW5Gb3JPYmplY3QodGhpcywgc3Bhbik7XG4gICAgICAgIHRoaXMuX19jcl91cmwgPSB1cmw7XG5cbiAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgICAgdmFyIGJhc2VVUkwgPSB1cmwuc3BsaXQoXCI/XCIpWzBdO1xuICAgICAgICAgICAgc3Bhbi5ldmVudChcImNyL3NwYW5fYXR0cmlidXRlc1wiLCB7XG4gICAgICAgICAgICAgICAgc2hvcnRfdXJsIDogYmFzZVVSTCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9wZW5QYXlsb2FkID0ge1xuICAgICAgICAgICAgYXJndW1lbnRzIDogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSZWNvcmQgZG9jdW1lbnQgY29va2llcyBpZiB0aGVyZSBhcmUgYW55XG4gICAgICAgIGlmIChkb2N1bWVudCAmJiBkb2N1bWVudC5jb29raWUpIHtcbiAgICAgICAgICAgIHZhciBjb29raWVzID0gZG9jdW1lbnQuY29va2llLnNwbGl0KFwiO1wiKTtcbiAgICAgICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29raWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gY29va2llc1tpXS5zcGxpdChcIj1cIiwgMik7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gcGFydHNbMF0ucmVwbGFjZSgvXlxccysvLFwiXCIpLnJlcGxhY2UoL1xccyskLywgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFba2V5XSA9IGRlY29kZVVSSUNvbXBvbmVudChwYXJ0c1sxXSk7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIG9wZW5QYXlsb2FkLmNvb2tpZXMgPSBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVjb3JkIHRoZSBVUkwgb2YgdGhlIEFKQVggcmVxdWVzdCBhcyB0aGUgbWVzc2FnZS5cbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIGlmIChtZXNzYWdlICYmIG1lc3NhZ2UubGVuZ3RoID4ga01heFVSTFNuaXBwZXRMZW5ndGgpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnN1YnN0cigwLCBrTWF4VVJMU25pcHBldExlbmd0aCAtIDEpICsgXCLigKZcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNwYW4uZXZlbnQoXCJYTUxIdHRwUmVxdWVzdC5vcGVuXCIsIG1lc3NhZ2UsIG9wZW5QYXlsb2FkKTtcblxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJyZWFkeXN0YXRlY2hhbmdlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PSA0KSB7XG4gICAgICAgICAgICAgICAgLy8gRG8gKkFMTCogYnJvd3NlcnMgc2VuZCByZWFkeVN0YXRlIDQgZXZlbiBvbiBlcnJvcj8gIElmIG5vdCxcbiAgICAgICAgICAgICAgICAvLyB0aGUgc3BhbiB3aWxsIG5ldmVyIGNsb3NlLlxuXG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlVHlwZSA9IHRoaXMucmVzcG9uc2VUeXBlO1xuICAgICAgICAgICAgICAgIHZhciBwYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICB1cmwgICAgICAgICAgOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZCAgICAgICA6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVycyAgICAgIDogZ2V0UmVzcG9uc2VIZWFkZXJzKHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMgICAgICAgOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dCAgIDogdGhpcy5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVR5cGUgOiByZXNwb25zZVR5cGUsXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIFRoZSByZXNwb25zZVRleHQgcHJvcGVydHkgaXMgb25seSB2YWxpZCBpZiB0aGUgcmVzcG9uc2VUeXBlIGlzIFxuICAgICAgICAgICAgICAgIC8vICcnIG9yICd0ZXh0Jy4gIFRoZXJlIGFyZSBvdGhlciB0eXBlcyBsaWtlICdhcnJheWJ1ZmZlcicgZm9yIHdoaWNoXG4gICAgICAgICAgICAgICAgLy8gYXR0ZW1wdGluZyB0byByZWFkIHJlc3BvbnNlVGV4dCB3aWxsIHRocm91Z2ggYW4gZXhjZXB0aW9uLlxuICAgICAgICAgICAgICAgIHZhciB2YWxpZFJlc3BvbnNlVHlwZSA9IChyZXNwb25zZVR5cGUgPT09IFwiXCIgfHwgcmVzcG9uc2VUeXBlID09IFwidGV4dFwiKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsaWRSZXNwb25zZVR5cGUgJiYgdGhpcy5yZXNwb25zZVRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGlzcGxheSB0aGUgcGF5bG9hZCBhcyBKU09OIGlmIGl0J3MgcGFyc2VhYmxlIGFzIHN1Y2hcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQucmVzcG9uc2VKU09OID0gSlNPTi5wYXJzZSh0aGlzLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQucmVzcG9uc2VUZXh0ID0gdGhpcy5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLnJlc3BvbnNlID0gdGhpcy5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgIT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uZXJyb3IoXCJIVFRQIHN0YXR1cyBlcnJvclwiLCB0aGlzLnN0YXR1cyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3Bhbi5ldmVudChcIlhNTEh0dHBSZXF1ZXN0LnJlYWR5c3RhdGUuZG9uZVwiLCBwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICBzcGFuLmVuZCgpO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PSAyKSB7XG5cbiAgICAgICAgICAgICAgICBzcGFuLmV2ZW50KFwiWE1MSHR0cFJlcXVlc3QucmVhZHlzdGF0ZS5oZWFkZXJzX3JlY2VpdmVkXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVycyA6IGdldFJlc3BvbnNlSGVhZGVycyh0aGlzKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICB2YXIgcmVzdWx0ID0gcHJveGllZC5vcGVuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgLy8gVE9ETzogY2hlY2sgdGhlIGhlYWRlcnMgdG8gc2VlIGlmIHdlIGhhdmUgYW4gaW5zdHJ1bWVudGVkIHNlcnZlciBvbiB0aGVcbiAgICAgICAgLy8gYmFja2VuZD8gT3IgaWYgaXQncyBub3QgZ29pbmcgdG8gYmUgYSBDT1JTIHJlcXVlc3Q/XG4gICAgICAgIC8vXG4gICAgICAgIC8vIFVuZm9ydHVuYXRlbHksIHRoZSBzZXJ2ZXIgbmVlZHMgdG8gc2V0IGV4cGxpY2l0bHkgc2V0IFxuICAgICAgICAvLyBcIkFjY2Vzcy1Db250cm9sLUFsbG93LUhlYWRlcnNcIiB0byBhbGxvdyB0aGVzZSBvbiBhbnkgQ09SUyByZXF1ZXN0IFxuICAgICAgICAvLyBvciBlbHNlIGFuIGVycm9yIGlzIGdlbmVyYXRlZC5cbiAgICAgICAgXG4gICAgICAgIC8vICAgIHRoaXMuc2V0UmVxdWVzdEhlYWRlcihcIlgtVHJhY2VndWlkZS1SdW50aW1lLUdVSURcIiwgY3IuZ3VpZCgpKTtcbiAgICAgICAgLy8gICAgdGhpcy5zZXRSZXF1ZXN0SGVhZGVyKFwiWC1UcmFjZWd1aWRlLVNwYW4tR1VJRFwiLCBzcGFuLmd1aWQoKSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgaWYgKHNraXBJbnN0cnVtZW50YXRpb24oY3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJveGllZC5zZW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIFxuICAgICAgICAvLyBJZiBpdCdzIGEgc2luZ2xlIGFyZ3VtZW50IHRoYXQgY2FuIGJlIHBhcnNlZCBhcyBKU09OLCB0aGVuIFxuICAgICAgICAvLyBwYXJzZSBhcyBKU09OLlxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhWzBdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgdGhlIGVycm9yXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3Iuc3BhbkZvck9iamVjdCh0aGlzKS5ldmVudChcIlhNTEh0dHBSZXF1ZXN0LnNlbmRcIiwge1xuICAgICAgICAgICAgdXJsICA6IHRoaXMuX19jcl91cmwsXG4gICAgICAgICAgICBkYXRhIDogZGF0YSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm94aWVkLnNlbmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufTtcblxuZnVuY3Rpb24gc2tpcEluc3RydW1lbnRhdGlvbihjcikge1xuICAgIC8vIEVhcmx5IG91dCBvZiB0aGUgcnVudGltZSBpcyBkaXNhYmxlZCBvciBpZiB0aGUgWE1MSHR0cFJlcXVlc3RcbiAgICAvLyBpcyB0aGUgcnVudGltZSdzIG93biBidWZmZXIgZmx1c2ggKGkuZS4gYXZvaWQgcmVjdXJzaXZlIHBheWxvYWRcbiAgICAvLyBjYXB0dXJlISkuXG4gICAgdmFyIHN0YXR1cyA9IGNyLnN0YXR1cygpO1xuICAgIHJldHVybiAoIXN0YXR1cy5lbmFibGVkIHx8IHN0YXR1cy5mbHVzaEFjdGl2ZSk7XG59XG5cbi8vIE5vcm1hbGl6ZSB0aGUgZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIG91dHB1dFxuZnVuY3Rpb24gZ2V0UmVzcG9uc2VIZWFkZXJzKHhocikge1xuICAgIHZhciByYXcgPSB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCk7XG4gICAgcmV0dXJuIHJhdy5yZXBsYWNlKC9cXHIvZywgXCJcIikucmVwbGFjZSgvXlxccysvLFwiXCIpLnJlcGxhY2UoL1xccyskLyxcIlwiKS5zcGxpdCgvXFxuLyk7XG59XG4iLCIvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXG4vLyBTdGFuZGFyZCBldmVudCBob29rc1xuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuLy9cbi8vIE5vdGU6IFwic3RhbmRhcmRcIiB3ZWIgYW55dGhpbmcgaXMgYWx3YXlzIGEgbWVzcy4gQSBjb25zY2lvdXMgY2hvaWNlIG5lZWRzIFxuLy8gdG8gYmUgbWFkZSBoZXJlIGJldHdlZW4gYnJlYWR0aCBvZiBzdXBwb3J0IGZvciBkaWZmZXJlbnQgY29uZmlndXJhdGlvbnNcbi8vIHZpYSBwb2x5ZmlsbGluZywgZXRjLiBhbmQga2VlcGluZyB0aGUgcnVudGltZSBmb290cHJpbnQgdGlueS4gIFxuLy8gXG4vLyBGb3IgdGhlIG5lYXIgdGVybSwgdGhlIGxhdGVzdCB2ZXJzaW9uIG9mIENocm9tZSBpcyBiZWluZyBhc3N1bWVkIGFuZCBhbnkgXG4vLyBwb2x5ZmlsbCBhbmQgY29tcGF0aWJpbGl0eSBpc3N1ZXMgYXJlIGJlaW5nIGRlZmVycmVkIHRvIGEgbGF0ZXIgZGF0ZS5cbi8vIERlc3BpdGUganVzdCBzYXlpbmcgdGhhdCBDaHJvbWUgaXMgdGhlIHRhcmdldCwgdGhlIE1vemlsbGEgRGV2ZWxvcGVyIE5ldHdvcmtcbi8vIGN1cnJlbnRseSBoYXMgdGhlIGJlc3QgcmVmZXJlbmNlIG9uIGV2ZW50cyB0aGF0IGNhbiBiZSBob29rZWQgaW50bzpcbi8vXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9FdmVudHNcblxudmFyIGtDcmVhdGVQYWdlVmlld1NwYW4gPSBmYWxzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3IpIHtcblxuICAgIC8vIE1pZ2h0IGhhcHBlbiBpZiBpbnZva2VkLCBmb3IgZXhhbXBsZSwgaW5zaWRlIGEgd2ViIHdvcmtlclxuICAgIGlmICghZG9jdW1lbnQpIHtcbiAgICAgICAgY3IuZXJyb3IoXCJObyBkb2N1bWVudCBvYmplY3QgYXZhaWxhYmxlIHRvIGNydW50aW1lXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghd2luZG93KSB7XG4gICAgICAgIGNyLmVycm9yKFwiTm8gd2luZG93IG9iamVjdCBhdmFpbGFibGUgdG8gY3J1bnRpbWVcIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9ICAgIFxuXG4gICAgaWYgKGtDcmVhdGVQYWdlVmlld1NwYW4pIHtcbiAgICAgICAgdmFyIHNwYW5QYWdlVmlldyA9IGNyLnNwYW4oXCJjci9wYWdlX3ZpZXdcIik7XG4gICAgICAgIHNwYW5QYWdlVmlldy5ldmVudChcImNyL3BhZ2Vfdmlld1wiLCB7XG4gICAgICAgICAgICB1cmwgIDogZG9jdW1lbnQuVVJMLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBjci5ldmVudChcImNyL2RvbV9ldmVudHMvRE9NQ29udGVudExvYWRlZFwiLCB7XG4gICAgICAgICAgICB1cmwgICAgIDogZG9jdW1lbnQuVVJMLFxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZWFkeXN0YXRlY2hhbmdlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3IuZXZlbnQoXCJjci9kb21fZXZlbnRzL3JlYWR5c3RhdGVjaGFuZ2VcIiwge1xuICAgICAgICAgICAgcmVhZHlfc3RhdGUgICAgIDogZG9jdW1lbnQucmVhZHlTdGF0ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIpIHtcbiAgICAgICAgICAgIGlmIChwZXJmb3JtYW5jZSAmJiBwZXJmb3JtYW5jZS50aW1pbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXRyb2FjdGl2ZWx5IGNyZWF0ZSBzcGFucyBhbmQgbG9nIHJlY29yZHMgZm9yIHRoZSBwYWdlIGxvYWQgdGltZXNcbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEzMDQ1NzY3L3BhZ2UtbG9hZC10aW1lLXdpdGgtamF2YXNjcmlwdFxuICAgICAgICAgICAgICAgIGNyLnNwYW5NYW51YWwoXCJicm93c2VyL3RpbWVfdG9fZmlyc3RfYnl0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVyZm9ybWFuY2UudGltaW5nLnJlcXVlc3RTdGFydCAqIDEwMDAuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcmZvcm1hbmNlLnRpbWluZy5yZXNwb25zZVN0YXJ0ICogMTAwMC4wKTtcbiAgICAgICAgICAgICAgICBjci5zcGFuTWFudWFsKFwiYnJvd3Nlci9yZXNwb25zZV90cmFuc2ZlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVyZm9ybWFuY2UudGltaW5nLnJlc3BvbnNlU3RhcnQgKiAxMDAwLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJmb3JtYW5jZS50aW1pbmcucmVzcG9uc2VFbmQgKiAxMDAwLjApO1xuICAgICAgICAgICAgICAgIGNyLnNwYW5NYW51YWwoXCJicm93c2VyL2RvbV9sb2FkaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJmb3JtYW5jZS50aW1pbmcuZG9tTG9hZGluZyAqIDEwMDAuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcmZvcm1hbmNlLnRpbWluZy5kb21JbnRlcmFjdGl2ZSAqIDEwMDAuMCk7XG4gICAgICAgICAgICAgICAgdmFyIHBhZ2VMb2FkU3BhbkdVSUQgPSBjci5zcGFuTWFudWFsKFwiYnJvd3Nlci9wYWdlX2xvYWRcIixcbiAgICAgICAgICAgICAgICAgICAgcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydCAqIDEwMDAuMCxcbiAgICAgICAgICAgICAgICAgICAgRGF0ZS5ub3coKSAqIDEwMDAuMCk7XG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VVUkwgPSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUuc3BsaXQoXCI/XCIpWzBdO1xuICAgICAgICAgICAgICAgICAgICBjci5sb2dSZWNvcmQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbl9ndWlkICAgICAgICAgICA6IHBhZ2VMb2FkU3BhbkdVSUQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFibGVfbmFtZSAgICAgICAgIDogXCJjci9zcGFuX2F0dHJpYnV0ZXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvcnRfdXJsICAgICAgIDogYmFzZVVSTCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUGVyIHRoZSBzcGVjLCBKU09OLnN0cmluZ2lmeShwZXJmb3JtYW5jZS50aW1pbmcpID09IFwie31cIiwgbWFudWFsbHkgYnVpbGRcbiAgICAgICAgICAgICAgICAvLyB0aGUgcGF5bG9hZC4gKGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTc2OTE3MylcbiAgICAgICAgICAgICAgICB2YXIgdGltaW5nUGF5bG9hZCA9IHt9O1xuICAgICAgICAgICAgICAgIHZhciBrZXk7XG4gICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gcGVyZm9ybWFuY2UudGltaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHBlcmZvcm1hbmNlLnRpbWluZ1trZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWluZ1BheWxvYWRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSB2YWx1ZXMgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IHRvIGluY3JlYXNlIHRoZSByZWFkYWJpbGl0eS5cbiAgICAgICAgICAgICAgICAvLyBUaGVyZSdzIGFuIGFyZ3VtZW50IHRoYXQgdGhlIHBheWxvYWQgdmFsdWVzIHNob3VsZCBiZSAxOjEgdG8gdGhlIGRvY3VtZW50ZWRcbiAgICAgICAgICAgICAgICAvLyBwZXJmb3JtYW5jZS50aW1pbmcgc3RydWN0dXJlIC0tIHdoaWNoIGlzIHJpZ2h0IHByb2JhYmx5IGRlcGVuZHMgb24gd2hhdFxuICAgICAgICAgICAgICAgIC8vIHdlIGV2ZW50dWFsbHkgd2FudCBjdXN0b21lcnMgdG8gYmUgYWJsZSB0byBkbyB3aXRoIHBheWxvYWRzLlxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aW1pbmdQYXlsb2FkLmZldGNoU3RhcnQ7XG4gICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gdGltaW5nUGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGltaW5nUGF5bG9hZFtrZXldID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltaW5nUGF5bG9hZFtrZXldIC09IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNyLmxvZ1JlY29yZCh7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcF9taWNyb3MgICAgOiAocGVyZm9ybWFuY2UudGltaW5nLmRvbUludGVyYWN0aXZlICogMTAwMC4wKSxcbiAgICAgICAgICAgICAgICAgICAgc3Bhbl9ndWlkICAgICAgICAgICA6IHBhZ2VMb2FkU3BhbkdVSUQsXG4gICAgICAgICAgICAgICAgICAgIHN0YWJsZV9uYW1lICAgICAgICAgOiBcImNyL3BlcmZvcm1hbmNlL3RpbWluZ19tc1wiLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlICAgICAgICAgICAgIDogXCJicm93c2VyIHBhZ2UgbG9hZCB0aW1pbmcgb2Zmc2V0cyBpbiBtaWxsaXNlY29uZHNcIixcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZCAgICAgICAgICAgICA6IHRpbWluZ1BheWxvYWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIE5PVEU6IHRoaXMgaXMgbGlrZWx5IGdyYXR1aXRvdXMgLS0gY2FwdHVyZSBhbnkgbW91c2UgY2xpY2sgdGhhdCB3ZVxuICAgIC8vIGNhbi4gVGhpcyBpcyBub3QgYXMgdXNlZnVsIGFzIGl0IG1pZ2h0IHNlZW0gc2luY2UgdGhlIGV2ZW50IGNhc2NhZGluZ1xuICAgIC8vIG1vZGVsIGxpa2VseSBmaWx0ZXJzIG91dCB0aGUgY2xpY2tzIG9mIGludGVyZXN0IChidXR0b25zLCBsaW5rcykgYW5kXG4gICAgLy8gdGh1cyBsZWF2ZXMgdGhlIGFjdHVhbCBpbnZlcnNlIHNldCBvZiB3aGF0IHdlJ2QgcmVhbGx5IGxpa2UgdG8ga25vdy5cbiAgICAvLyBDb3VsZCBzY2FuIHRoZSBkb2N1bWVudCBmb3IgXCJhXCIsIFwiYnV0dG9uXCIsIFwiLmJ0blwiIC0tIHRoZXJlIGFyZSBcbiAgICAvLyBwcm9iZSBlZmZlY3Qgcmlza3MgaW4gdGhhdCBhcHByb2FjaCwgYnV0IGl0J3MgYSBwb3NzaWJpbGl0eS4gIFBlcmhhcHNcbiAgICAvLyBpdCBjb3VsZCBiZSBhbiBvcHQtaW4uXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAvLyBUT0RPOiB3ZSBjYW4ndCBqdXN0IHBhc3MgaW4gdGhlIGV2dCBvYmplY3QgYXMgaXQgaGFzIGNpcmN1bGFyIFxuICAgICAgICAvLyByZWZlcmVuY2VzIGFuZCB0aGUgSlMgY3J1bnRpbWUgZG9lc24ndCBtYXJzaGFsIHRob3NlIGNvcnJlY3RseSB5ZXQuXG4gICAgICAgIHZhciBwYXlsb2FkID0ge1xuICAgICAgICAgICAgY2xpZW50WCAgICAgOiBldnQuY2xpZW50WCxcbiAgICAgICAgICAgIGNsaWVudFkgICAgIDogZXZ0LmNsaWVudFksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChldnQudGFyZ2V0KSB7XG4gICAgICAgICAgICBwYXlsb2FkLnRhcmdldF9pZCAgPSBldnQudGFyZ2V0LmlkO1xuICAgICAgICAgICAgcGF5bG9hZC5jbGFzc19uYW1lID0gZXZ0LnRhcmdldC5jbGFzc05hbWU7XG4gICAgICAgICAgICBwYXlsb2FkLnRhZ19uYW1lICAgPSBldnQudGFyZ2V0LnRhZ05hbWU7XG5cbiAgICAgICAgICAgIC8vIEdldCB0aGUgRE9NIHBhdGggdG8gdGhlIGNsaWNrZWQgZWxlbWVudFxuICAgICAgICAgICAgdmFyIHBhdGggPSBbIHBheWxvYWQudGFnX25hbWUgXTtcbiAgICAgICAgICAgIHZhciBlbGVtID0gZXZ0LnRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgd2hpbGUgKGVsZW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbS50YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGgucHVzaChlbGVtLnRhZ05hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbGVtID0gZWxlbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF5bG9hZC5wYXRoID0gcGF0aC5yZXZlcnNlKCkuam9pbihcIj5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY3IuZXZlbnQoXCJjci9kb21fZXZlbnRzL2NsaWNrXCIsIHBheWxvYWQpO1xuICAgIH0pO1xuXG4gICAgLy8gUGFnZSB1bmxvYWQgZXZlbnRzLi4uXG4gICAgLy9cbiAgICAvLyBGb3IgdGhlIHJlY29yZCwgQ2hyb21lIGRvZXNuJ3QgYWxsb3cgeW91IHRvIG92ZXJyaWRlIFxuICAgIC8vIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKSAtLSBzbyB3ZSBjYW4ndCBpbnRlcmNlcHQgdGhhdCBhbmQgZmx1c2guXG4gICAgLy9cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNyLmV2ZW50KFwiY3IvZG9tX2V2ZW50cy9iZWZvcmV1bmxvYWRcIik7XG4gICAgICAgIGlmIChrQ3JlYXRlUGFnZVZpZXdTcGFuKSB7XG4gICAgICAgICAgICBzcGFuUGFnZVZpZXcuZW5kKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOT1RFOiB0aGUgYnVmZmVyIGlzIGZsdXNoZWQgKnN5bmNocm9ub3VzbHkqIGhlcmUuXG4gICAgICAgIGNyLnNodXRkb3duKCk7XG4gICAgfSk7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInVubG9hZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNyLmV2ZW50KFwiY3IvZG9tX2V2ZW50cy91bmxvYWRcIik7XG4gICAgfSk7XG59O1xuXG5cblxuXG4iLCIvLyBQbGF0Zm9ybS1zcGVjaWZpYyBmdW5jdGlvbnMgdG8gZW5jYXBzdWxhdGUgdGhlIGRpZmZlcmVuY2VzIGZyb20gY3J1dGlubWUtY29tbW9uXG5cbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cbi8vIENvbnN0YW50c1xuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuXG52YXIga0Nvb2tpZVRpbWVUb0xpdmVTZWNvbmRzID0gNyAqIDI0ICogNjAgKiA2MDtcbnZhciBrVHJhY2VndWlkZVNlc3Npb25JZEtleSAgPSBcInRyYWNlZ3VpZGVfc2Vzc2lvbl9pZFwiO1xuXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXG4vLyBFeHBvcnRzXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXG5cbnZhciBsaWIgPSB7fTtcblxubGliLl90cmFjZWd1aWRlU2Vzc2lvbklkID0gY29va2llKGtUcmFjZWd1aWRlU2Vzc2lvbklkS2V5KTtcblxubGliLmlzTm9kZSA9IGZhbHNlO1xuXG5saWIuY29uc29sZSA9IGNvbnNvbGU7XG5cbmxpYi5ub3dNaWNyb3MgPSAoZnVuY3Rpb24oKSB7XG4gICAgLy8gSXMgYSBoaS1yZXMgdGltZXIgYXZhaWxhYmxlP1xuICAgIGlmIChwZXJmb3JtYW5jZSAmJlxuICAgICAgICBwZXJmb3JtYW5jZS5ub3cgJiZcbiAgICAgICAgcGVyZm9ybWFuY2UudGltaW5nICYmXG4gICAgICAgIHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQpIHtcblxuICAgICAgICB2YXIgc3RhcnQgPSBwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigoc3RhcnQgKyBwZXJmb3JtYW5jZS5ub3coKSkgKiAxMDAwLjApO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSBsb3ctcmVzIHRpbWVyIGlzIHRoZSBiZXN0IHdlIGNhbiBkb1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gRGF0ZS5ub3coKSAqIDEwMDAuMDtcbiAgICAgICAgfTtcbiAgICB9XG59KSgpO1xuXG4vLyBMb3ctcXVhbGl0eSBHVUlEOiB0aGlzIGlzIGp1c3QgYSA1My1iaXQgcmFuZG9tIGludGVnZXIhICg1MyBiaXRzIHNpbmNlIHRoZVxuLy8gYmFja2luZyBzdG9yZSBmb3IgdGhlIG51bWJlciBpcyBhIDY0LWJpdCBmbG9hdCkuXG5saWIuZ2VuZXJhdGVHVUlEID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDkwMDcxOTkyNTQ3NDA5OTIpLnRvU3RyaW5nKDEwKTtcbn07XG5cbmxpYi5nZXRUcmFjZWd1aWRlU2Vzc2lvbklkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGxpYi5fdHJhY2VndWlkZVNlc3Npb25JZDtcbn07XG5cbi8vIEdlbmVyYXRlIG9yIHJldXNlIHRoZSBleGlzdGluZyBydW50aW1lIEdVSURcbmxpYi5ydW50aW1lR1VJRCA9IGZ1bmN0aW9uKGdyb3VwTmFtZSkge1xuXG4gICAgLy8gVGhlIGJyb3dzZXIgbmVlZHMgdG8gYWNjb3VudCBmb3IgdGhlIGdyb3VwTmFtZSBmb3IgdGhlIGNhc2UgdGhhdCBtdWx0aXBsZVxuICAgIC8vIGxvZ2ljYWwgYXBwcy9zZXJ2aWNlcy9ydW50aW1lIGdyb3VwcyBtYXkgYmUgaG9zdGVkIG9uIHRoZSBzYW1lIGRvbWFpbiwgbWVhbmluZ1xuICAgIC8vIHRoZXkgKnNob3VsZCBub3QqIHNoYXJlIHRoZSBzYW1lIHJ1bnRpbWUgR1VJRC5cbiAgICB2YXIgY29va2llS2V5ID0gXCJ0cmFjZWd1aWRlX2d1aWRcIjtcbiAgICBpZiAoZ3JvdXBOYW1lKSB7XG4gICAgICAgIGNvb2tpZUtleSArPSBcIi9cIiArIGdyb3VwTmFtZTtcbiAgICB9XG5cbiAgICB2YXIgcnVudGltZUdVSUQgPSBjb29raWUoY29va2llS2V5KTtcblxuICAgIC8vIEEgc3BlY2lhbCBnbG9iYWwgX19jcl9vdmVycmlkZV9ydW50aW1lX2d1aWQgZXhpc3RzIGZvciB0ZXN0IGVudmlyb25tZW50c1xuICAgIC8vIHdoZXJlIGNvb2tpZXMgYW5kIGxvY2FsU3RvcmFnZSBhcmUgbm90IGF2YWlsYWJsZS5cbiAgICBpZiAoIXJ1bnRpbWVHVUlEICYmIHdpbmRvdyAmJiB3aW5kb3cuX19jcl9vdmVycmlkZV9ydW50aW1lX2d1aWQpIHtcbiAgICAgICAgcnVudGltZUdVSUQgPSB3aW5kb3cuX19jcl9vdmVycmlkZV9ydW50aW1lX2d1aWQ7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGEgR1VJRCBmcm9tIHRoZSBleGlzdGluZyBzZXNzaW9uIGFuZCBjcmVhdGUgdGhlIHJ1bnRpbWVcbiAgICAvLyBHVUlEIGJhc2VkIG9mZiBvZiB0aGF0IChpLmUuIGtlZXAgdGhlIHNhbWUgcnVudGltZSBHVUlEIGZvciBhbGwgXG4gICAgLy8gYnJvd3NlciBpbnN0YW5jZXMgaW4gdGhlIHNhbWUgc2Vzc2lvbikuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBubyBleGlzdGluZyBzZXNzaW9uLCBjcmVhdGUgYSBuZXcgcmFuZG9tIEdVSUQuXG4gICAgaWYgKCFydW50aW1lR1VJRCkge1xuICAgICAgICB2YXIgc2Vzc2lvbkdVSUQgPSBjb29raWUoXCJ0cmFjZWd1aWRlX3Nlc3Npb25fZ3VpZFwiKTtcbiAgICAgICAgaWYgKHNlc3Npb25HVUlEKSB7XG4gICAgICAgICAgICBydW50aW1lR1VJRCA9IHNlc3Npb25HVUlEO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcnVudGltZUdVSUQgPSBsaWIuZ2VuZXJhdGVHVUlEKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbHdheXMgd3JpdGUgYmFjayB0aGUgY29va2llIHRvIHJlbmV3IHRoZSBUVExcbiAgICBjb29raWUoY29va2llS2V5LCBydW50aW1lR1VJRCwga0Nvb2tpZVRpbWVUb0xpdmVTZWNvbmRzLCBcIi9cIik7XG5cbiAgICAvLyBBbHNvLCB3aGlsZSB3ZSdyZSBoZXJlLCBjaGVjayB0aGUgc3RhdHVzIG9mIGEgd2VsbC1rbm93biBrZXlcbiAgICAvLyB0aGF0IGNhbiBiZSB1c2VkIHRvIGNvb3JkaW5hdGUgd2l0aCB0aGUgc2VydmVyIHRvIHNldCBhIGpvaW4gSUQuXG4gICAgLy8gVGhlIHNlcnZlciBtYXkgaGF2ZSBhbHJlYWR5IHNldCB0aGlzIGtleSAtLSBvciBpZiBpdCBoYXNuJ3QsIHRoZVxuICAgIC8vIGJyb3dzZXIgY2FuIGdlbmVyYXRlIG9uZS5cbiAgICAvL1xuICAgIC8vIE5vdGUgdGhhdCBpdCdzIG9rIHRoYXQgdGhpcyBtaWdodCBiZSB1c2VkIGZvciBkaWZmZXJlbnRcbiAgICAvLyBydW50aW1lIGdyb3VwcyBpbiBkaWZmZXJlbnQgcHJvamVjdHM6IHRoZSBnb2FsIGhlcmUgaXMgb25seSB0b1xuICAgIC8vIHNldCBhbiBpZCBmb3IgdGhpcyBzZXNzaW9uLiBUaGlzIGNvbnZlbnRpb24gaXMgYWxzbyB1c2VkIGluXG4gICAgLy8gc3RhdGUuanMuXG4gICAgdmFyIHRyYWNlZ3VpZGVTZXNzaW9uSWQgPSBsaWIuZ2V0VHJhY2VndWlkZVNlc3Npb25JZCgpO1xuICAgIGlmICghdHJhY2VndWlkZVNlc3Npb25JZCkge1xuICAgICAgICB0cmFjZWd1aWRlU2Vzc2lvbklkID0gXCJydC1cIiArIHJ1bnRpbWVHVUlEO1xuICAgIH1cbiAgICBjb29raWUoa1RyYWNlZ3VpZGVTZXNzaW9uSWRLZXksIHRyYWNlZ3VpZGVTZXNzaW9uSWQsIGtDb29raWVUaW1lVG9MaXZlU2Vjb25kcywgXCIvXCIpO1xuXG4gICAgLy8gUmVjb3JkIHRoZSBzZXNzaW9uIElEIG5vdyB0aGF0IHdlJ3ZlIGZpZ3VyZWQgb3V0IGlmIHRoZXJlIHdhcyBhblxuICAgIC8vIGV4aXN0aW5nIG9uZSBvciBpZiB3ZSBuZWVkZWQgdG8gZ2VuZXJhdGUgbmV3IG9uZS5cbiAgICAvL1xuICAgIC8vIFRoZSBub3Qtc28td2VsbC1kZWZpbmVkIHBvaW50IGF0IHdoaWNoIHRoaXMgdmFyaWFibGUgaXMgaW5pdGlhbGl6ZWQgaXNcbiAgICAvLyB1bmZvcnR1bmF0ZSwgYnV0IHRoZSBpbml0aWFsaXphdGlvbiBvcmRlciBpcyBhIGJpdCBjb21wbGV4OiB3ZSBuZWVkIHRoZSBcbiAgICAvLyBncm91cE5hbWUgYmVmb3JlIHRoZSBydW50aW1lIEdVSUQgY2FuIGJlIGRldGVybWluZWQgLS0gdGhhdCdzIHVwIHRvIHRoZSBcbiAgICAvLyB1c2VyIHRvIHNwZWNpZnkgYXQgc29tZSBwb2ludCAtLSBhbmQgdGhlIHJ1bnRpbWUgR1VJRCBpcyBuZWVkZWQgdG8gXG4gICAgLy8gZ2VuZXJhdGUgdGhlIHNlc3Npb24gSUQgKFRPRE86IGRvZXMgaXQgaGF2ZSB0byBiZT8pLlxuICAgIGxpYi5fdHJhY2VndWlkZVNlc3Npb25JZCA9IHRyYWNlZ3VpZGVTZXNzaW9uSWQ7XG5cbiAgICByZXR1cm4gcnVudGltZUdVSUQ7XG59O1xuXG4vLyBEb2Vzbid0IG5lZWQgdG8gYmUgbG9uZy1saXZlZCBzdG9yYWdlLi4uIGp1c3QgbG9uZ2VyIHRoYW4gYSBwYWdlIGxvYWQuXG5saWIubG9jYWxTdG9yZSA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwidHJhY2VndWlkZS9cIiArIGtleSwgdmFsdWUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInRyYWNlZ3VpZGUvXCIgKyBrZXkpO1xufTtcblxudmFyIF9jb25zb2xlX29iaiAgID0gY29uc29sZTtcbnZhciBfY29uc29sZV9sb2cgICA9IGNvbnNvbGUubG9nO1xudmFyIF9jb25zb2xlX3dhcm4gID0gY29uc29sZS53YXJuO1xudmFyIF9jb25zb2xlX2Vycm9yID0gY29uc29sZS5lcnJvcjtcblxudmFyIGJhc2UgPSB7XG4gICAgbG9nICAgOiBmdW5jdGlvbihhcmdzKSB7IHJldHVybiBfY29uc29sZV9sb2cuYXBwbHkoX2NvbnNvbGVfb2JqLCBhcmdzKTsgfSxcbiAgICB3YXJuICA6IGZ1bmN0aW9uKGFyZ3MpIHsgcmV0dXJuIF9jb25zb2xlX3dhcm4uYXBwbHkoX2NvbnNvbGVfb2JqLCBhcmdzKTsgfSxcbiAgICBlcnJvciA6IGZ1bmN0aW9uKGFyZ3MpIHsgcmV0dXJuIF9jb25zb2xlX2Vycm9yLmFwcGx5KF9jb25zb2xlX29iaiwgYXJncyk7IH0sXG59O1xuXG5saWIubG9nZ2VyID0ge1xuICAgIGluZm8gIDogYmFzZS5sb2csXG4gICAgd2FybiAgOiBiYXNlLndhcm4sXG4gICAgZXJyb3IgOiBiYXNlLmVycm9yLFxuICAgIGZhdGFsIDogYmFzZS5lcnJvcixcbn07XG5cbmxpYi5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkZhdGFsIGV4Y2VwdGlvblwiKTtcbn07XG5cbi8vIFRPRE86IHN1cHBvcnQgdGhlIHNraXAgJiB1bmZpbHRlcmVkIGFyZ3NcbmxpYi5zdGFja1RyYWNlID0gZnVuY3Rpb24oc2tpcCwgdW5maWx0ZXJlZCkge1xuICAgIC8vIFRoaXMgYXBwcm9hY2ggb25seSB3b3JrcyBvbiBhIHN1YnNldCBvZiBicm93c2VycyFcbiAgICB2YXIgc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICBpZiAodHlwZW9mIHN0YWNrID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHN0YWNrID0gc3RhY2suc3BsaXQoXCJcXG5cIikuc2xpY2UoMyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN0YWNrW2ldID0gc3RhY2tbaV0ucmVwbGFjZSgvXlxccyphdFxccysvLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhY2s7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59O1xuXG52YXIgcHJveHlGaWxlbmFtZSA9IFwiPGJyb3dzZXI+XCI7XG5cbmxpYi5zZXRTb3VyY2VVcmwgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgaWYgKHR5cGVvZiB1cmwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFyIHBhcnRzID0gdXJsLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgcHJveHlGaWxlbmFtZSA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICAgIH1cbn07XG5cbi8vIFJldHVybnMgdGhlIHBsYWNlaG9sZGVyIGZvciB0aGUgZmlsZW5hbWUgaW4gYSBsb2cgcmVjb3JkLlxubGliLmRlZmF1bHRMb2dGaWxlbmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBwcm94eUZpbGVuYW1lO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBsaWI7XG5cbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cbi8vIEhlbHBlcnNcbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBjb3BpZWQgZGlyZWN0bHkgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbGl0ZWpzL2Jyb3dzZXItY29va2llLWxpdGUuXG4vLyBJdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgYW5kIGF1dGhvcmVkIGJ5IExhdXJpIFJvb2Rlbi5cbmZ1bmN0aW9uIGNvb2tpZShuYW1lLCB2YWx1ZSwgdHRsLCBwYXRoLCBkb21haW4sIHNlY3VyZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICB2YXIgbmV3Q29va2llID0gbmFtZSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSArXG4gICAgICAgICAgICAodHRsID8gXCI7IGV4cGlyZXM9XCIgKyBuZXcgRGF0ZSgrbmV3IERhdGUoKSsodHRsKjEwMDApKS50b1VUQ1N0cmluZygpIDogXCJcIikgK1xuICAgICAgICAgICAgKHBhdGggICA/IFwiOyBwYXRoPVwiICsgcGF0aCA6IFwiXCIpICtcbiAgICAgICAgICAgIChkb21haW4gPyBcIjsgZG9tYWluPVwiICsgZG9tYWluIDogXCJcIikgK1xuICAgICAgICAgICAgKHNlY3VyZSA/IFwiOyBzZWN1cmVcIiA6IFwiXCIpO1xuICAgICAgICBkb2N1bWVudC5jb29raWUgPSBuZXdDb29raWU7XG4gICAgICAgIHJldHVybiBuZXdDb29raWU7XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoKChcIjsgXCIrZG9jdW1lbnQuY29va2llKS5zcGxpdChcIjsgXCIrbmFtZStcIj1cIilbMV18fFwiXCIpLnNwbGl0KFwiO1wiKVswXSk7XG59XG5cbiIsIi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cbi8vIFBvbHlmaWxsc1xuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuLy8gXG4vLyBEb2VzIG5vdCBmaWxsIHBvbHlnb25zOyBub3JtYWxpemVzIHRoZSBKUyBlbnZpcm9ubWVudCBhY3Jvc3MgYnJvd3NlcnMuXG4vLyBUaGVyZSBhcmUgbGlicmFyaWVzIGZvciB0aGlzIHNvcnQgb2YgdGhpbmcuIFRoaXMgaXMganVzdCBhIGN1dCAmIHBhc3RlIG9mXG4vLyB0aGUgc3Vic2V0IG5lZWRlZC5cbi8vXG5cbi8vIFNlZTpcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9jcmVhdGVcbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTE0ODg1NDAvY29weS1wcm90b3R5cGUtZm9yLWluaGVyaXRhbmNlXG5pZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgIT0gJ2Z1bmN0aW9uJykge1xuICAgIE9iamVjdC5jcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBUZW1wID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwcm90b3R5cGUpIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdTZWNvbmQgYXJndW1lbnQgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm90b3R5cGUgIT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBUZW1wLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgVGVtcCgpO1xuICAgICAgICAgICAgVGVtcC5wcm90b3R5cGUgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9KSgpO1xufSIsIi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cbi8vIERlcGVuZGVuY2llc1xuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuXG52YXIgU3RhdGUgPSByZXF1aXJlKFwiLi9zcmMvc3RhdGUuanNcIik7XG5cbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cbi8vIEV4cG9ydGVkIEFQSVxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuXG52YXIgbGliID0ge307XG5cbi8vIENyZWF0ZXMgdGhlIFwic3RhdGVcIiBvYmplY3Qgd2hpY2ggY29udGFpbnMgdGhlIGNvcmUgZnVuY3Rpb25hbGl0eSBvZiB0aGUgXG4vLyBjbGllbnQgbGlicmFyeSBpbmNsdWRpbmcgdGhlIGJ1ZmZlcmluZyBhbmQgYWxsIHJhdy9sb3ctbGV2ZWwgbG9nZ2luZyBhbmQgXG4vLyBzcGFuIGNhbGxzIHdoaWNoIHRoZSBwbGF0Zm9ybS1kZXBlbmRlbnQgY29kZSBjYW4gY2FsbC4gIFRoZSBwbGF0Zm9ybSBcbi8vIGxpYnJhcmllcyBhcmUgaW50ZW5kZWQgdG8gYmUgc2xpbSB3cmFwcGVycyBvbiB0aGlzIFN0YXRlIG9iamVjdC5cbi8vXG4vLyBUaGUgXCJvcHRzXCIgYXJndW1lbnQgcGFzc2VzIGluIGFsbCB0aGUgcGxhdGZvcm0tZGVwZW5kZW50IGhvb2tzIGFuZCBcbi8vIGluZm9ybWF0aW9uLlxuLy9cbmxpYi5jcmVhdGVTdGF0ZSA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgICBcbiAgICAvLyBDaGVjayB0aGF0IHRoZSBuZWNlc3NhcnkgdGhyaWZ0IGNvbm5lY3Rpb24gcG9pbnRzIGFyZSB0aGVyZVxuICAgIGlmICghb3B0cy50aHJpZnRUeXBlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvcHRzLnRocmlmdFR5cGVzIHJlcXVpcmVkXCIpO1xuICAgIH1cbiAgICBpZiAoIW9wdHMudGhyaWZ0TGlicmFyeSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvcHRzLnRocmlmdExpYnJhcnkgcmVxdWlyZWRcIik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgdGhhdCBvdXIgcGFsLCB0aGUgcGxhdGZvcm0gYWJzdHJhY3Rpb24gbGF5ZXIsIGlzIGZ1bGx5IFxuICAgIC8vIHNwZWNpZmllZC5cbiAgICBpZiAoIW9wdHMucGxhdGZvcm0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib3B0LnBsYXRmb3JtIHJlcXVpcmVkXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMucGxhdGZvcm0ubm93TWljcm9zICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm93TWljcm9zIGlzIGEgcmVxdWlyZWQgcGxhdGZvcm0gZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5wbGF0Zm9ybS5nZW5lcmF0ZUdVSUQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZW5lcmF0ZUdVSUQgaXMgYSByZXF1aXJlZCBwbGF0Zm9ybSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRzLnBsYXRmb3JtLmNvbnNvbGUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29uc29sZSBpcyBub3QgYSB2YWxpZCBwbGF0Zm9ybSBvYmplY3RcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5wbGF0Zm9ybS5jb25zb2xlLmxvZyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbnNvbGUubG9nIGlzIG5vdCBhIHZhbGlkIHBsYXRmb3JtIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMucGxhdGZvcm0uY29uc29sZS53YXJuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29uc29sZS53YXJuIGlzIG5vdCBhIHZhbGlkIHBsYXRmb3JtIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMucGxhdGZvcm0uY29uc29sZS5lcnJvciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbnNvbGUuZXJyb3IgaXMgbm90IGEgdmFsaWQgcGxhdGZvcm0gZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5wbGF0Zm9ybS5sb2NhbFN0b3JlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29uc29sZS5sb2NhbFN0b3JlIGlzIG5vdCBhIHZhbGlkIHBsYXRmb3JtIGZ1bmN0aW9uXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgU3RhdGUoXG4gICAgICAgIG9wdHMudGhyaWZ0VHlwZXMsIFxuICAgICAgICBvcHRzLnRocmlmdExpYnJhcnksIFxuICAgICAgICBvcHRzLnBsYXRmb3JtLCBcbiAgICAgICAgb3B0cy5ldmVudHNcbiAgICApO1xufTtcblxubGliLmFwaSA9IHJlcXVpcmUoXCIuL3NyYy9hcGkuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gbGliO1xuIiwiLy8gRGVmaW5lcyB0aGUgY29tbW9uLCBjbGllbnQtZmFjaW5nIEFQSSBmb3IgY3J1bnRpbWUuIFRoZSBwbGF0Zm9ybS1zcGVjaWZpYyBBUEkgXG4vLyBtYXkgYmUgYSBzbGlnaHQgdmFyaWF0aW9uIG9mIHRoaXMgZGVwZW5kaW5nIG9uIHBsYXRmb3JtIGNhcGFiaWxpdGllcy5cbi8vXG4vLyBUaGUgY29kZSBoZXJlaW4gaXMgaW50ZW5kZWQgdG8gYSBzbGltIHN5bnRhY3RpYyBsYXllciBvdmVyIHRoZSBpbXBsZW1lbnRhdGlvblxuLy8gcHJvdmlkZWQgYnkgdGhlIFN0YXRlIG9iamVjdC5cblxudmFyIGltcCA9IG51bGw7XG5cbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cbi8vIEluaXRpYWxpemF0aW9uICYgQ29uZmlndXJhdGlvblxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuXG4vKipcbiAgICBUaGUgVHJhY2VndWlkZSBydW50aW1lIG9iamVjdC5cblxuICAgIFRoaXMgb2JqZWN0IGlzIG5vcm1hbGx5IGV4cG9zZWQgdG8gdGhlIGNvZGUgYXMgYSBzaW5nbGV0b24gYWNjZXNzaWJsZVxuICAgIHZpYSB0aGUgYGBjcmBgIHZhcmlhYmxlLlxuXG5cbiAgICBgYGBqc1xuICAgIHZhciBjciA9IHJlcXVpcmUoXCJybC1jcnVudGltZS1ub2RlXCIpO1xuXG4gICAgY3IuaW5pdGlhbGl6ZSh7XG4gICAgICAgIGFjY2Vzc190b2tlbiA6IFwiPHlvdXIgYWNjZXNzIHRva2VuIGhlcmU+XCIsXG4gICAgICAgIGdyb3VwX25hbWUgICA6IFwibXlfc2VydmljZV9uYW1lXCIsXG4gICAgfSk7XG5cbiAgICBjci5sb2coXCJUaGUgY3VycmVudCB0aW1lIGlzOlwiLCBuZXcgRGF0ZSgpKTtcbiAgICBgYGBcbiAqL1xuZnVuY3Rpb24gUnVudGltZSgpIHtcbn0gXG5cbi8qKlxuICAgIEBncm91cCBJbml0aWFsaXphdGlvblxuICAgIEBicmllZiBpbml0aWFsaXplIGFuZCBiZWdpbiBpbnN0cnVtZW50YXRpb24gcmVwb3J0aW5nXG4gICAgQHNpZ25hdHVyZSAgaW5pdGlhbGl6ZSAob3B0cylcblxuICAgIEluaXRpYWxpemVzIHRoZSBydW50aW1lIGxpYnJhcnkgYW5kIHN0YXJ0cyB0aGUgcmVwb3J0aW5nIGxvb3AuXG5cbiAgICAqIGBvcHRzYCBvYmplY3QgLSBzZWUgdGhlIGBvcHRpb25zKClgIG1ldGhvZCBmb3IgZGV0YWlscyBvbiB0aGUgdmFsaWRcbiAgICBzZXQgb2Ygb3B0aW9uc1xuXG4gICAgKkV4YW1wbGUqXG5cbiAgICBgYGBqc1xuICAgIGNyLmluaXRpYWxpemUoe1xuICAgICAgICBhY2Nlc3NfdG9rZW4gOiBcIjx5b3VyIGFjY2VzcyB0b2tlbiBoZXJlPlwiLFxuICAgICAgICBncm91cF9uYW1lICAgOiBcIm15X3NlcnZpY2VfbmFtZVwiLFxuICAgIH0pO1xuICAgIGBgYFxuXG4gICAgRm9yIGNvbnZlbmllbmNlLCBtYWtpbmcgbXVsdGlwbGUgY2FsbHMgdG8gYGluaXRpYWxpemUoKWAgaXMgdmFsaWQ6IGFsbFxuICAgIGNhbGxzIHdpbGwgYmUgdHJlYXRlZCBhcyBlcXVpdmFsZW50IHRvIGEgY2FsbCB0byBgb3B0aW9ucygpYCB3aXRoIHRoZVxuICAgIHNvbGUgZGlmZmVyZW5jZSB0aGF0IHRoZSByZXBvcnRpbmcgbG9vcCB3aWxsIGJlZ2luIG9uIHRoZSBmaXJzdCBjYWxsIHRoYXRcbiAgICBwcm92aWRlcyBpdCB3aXRoIHN1ZmZpY2llbnQgaW5mb3JtYXRpb24gdG8gYmVnaW4gcmVwb3J0aW5nLiAgVGhpc1xuICAgIGJlaGF2aW9yIGNhbiBiZSBoZWxwZnVsIGZvciBsaWJyYXJ5IGNvZGUgdGhhdCBtYXkgbm90IGEgY2xlYXIsIHNpbmdsZSBcbiAgICBlbnRyeS1wb2ludC5cbiAqL1xuUnVudGltZS5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHsgXG4gICAgcmV0dXJuIGltcC5pbml0aWFsaXplLmFwcGx5KGltcCwgYXJndW1lbnRzKTsgXG59O1xuXG4vKipcbiAgICBAZ3JvdXAgSW5pdGlhbGl6YXRpb25cbiAgICBAYnJpZWYgZGlzY29ubmVjdCBhbmQgY2xlYW4tdXAgaW5zdHJ1bWVudGF0aW9uIHJlcG9ydGluZ1xuICAgIEBzaWduYXR1cmUgc2h1dGRvd24gKClcblxuICAgIEV4cGxpY2l0bHkgc2h1dHMgZG93biB0aGUgcnVudGltZSBsaWJyYXJ5LiAgXG5cbiAgICBUaGlzIHN0b3BzIHRoZSByZXBvcnRpbmcgbG9vcC4gQW55IGluZm9ybWF0aW9uIHJlY29yZGVkIGFmdGVyXG4gICAgc2h1dGRvd24gaGFzIGJlZW4gY2FsbGVkIHdpbGwgYmUgaWdub3JlZC5cblxuICAgIFRoZSBydW50aW1lIHdpbGwgYXV0b21hdGljYWxseSBzaHV0IGRvd24gd2hlbiB0aGUgcHJvY2VzcyBleGl0czsgdGhpc1xuICAgIG1ldGhvZCBpcyBhdmFpbGFibGUgaWYgZXhwbGljaXQgY29udHJvbCBvdmVyIHRoZSBzaHV0ZG93biBpcyBkZXNpcmVkLlxuICovXG5SdW50aW1lLnByb3RvdHlwZS5zaHV0ZG93biA9IGZ1bmN0aW9uKCkgeyBcbiAgICByZXR1cm4gaW1wLnNodXRkb3duLmFwcGx5KGltcCwgYXJndW1lbnRzKTsgXG59O1xuXG4vKipcbiAgICBAZ3JvdXAgQ29uZmlndXJhdGlvblxuICAgIEBicmllZiBzZXQgaW5zdHJ1bWVudGF0aW9uIG9wdGlvbnNcbiAgICBAc2lnbmF0dXJlIG9wdGlvbnMgKG9wdHMpXG5cbiAgICBTZXRzIHRoZSBvcHRpb25zIGZvciB0aGUgcnVudGltZSBsaWJyYXJ5LlxuXG4gICAgOjo6IG1hcmtcbiAgICBTY3J1YmJlciBkb2N1bWVudGF0aW9uIGlzIG5lZWRlZCFcbiAgICA6OjpcblxuICAgICogYG9wdHNgIG9iamVjdCBcbiAgICAgICAgKiBgYWNjZXNzX3Rva2VuYCBzdHJpbmcgLSBzZXRzIHRoZSBwcm9qZWN0IGFjY2VzcyB0b2tlbiBmb3IgdGhlIHJ1bnRpbWVcbiAgICAgICAgKiBgZ3JvdXBfbmFtZWAgc3RyaW5nIC0gc2V0cyB0aGUgZ3JvdXAgbmFtZSBmb3IgdGhlIHJ1bnRpbWVcbiAgICAgICAgKiBgZW5hYmxlYCBib29sIC0gaWYgc2V0IHRvIGZhbHNlLCB3aWxsIGRpc2FibGUgdGhlIHJ1bnRpbWUgcmVwb3J0aW5nIGFuZFxuICAgICAgICAgICAgdHVybiBhbGwgcnVudGltZSBjYWxscyBpbnRvIG5vLW9wcy4gTm90ZTogaXQgaXMgY3VycmVudGx5ICpub3QqIHBvc3NpYmxlIHRvIFxuICAgICAgICAgICAgcmUtZW5hYmxlIHRoZSBydW50aW1lIG9uY2UgaXQgaXMgZGlzYWJsZWQuXG4gICAgICAgICogYHNjcnViYmVyYCBvYmplY3QgLSBzZXRzIHRoZSBkYXRhIHNjcnViYmluZyBvcHRpb25zXG4gICAgICAgICogYGVuZF91c2VyX2lkYCBzdHJpbmcgLSBzZXRzIHRoZSBgZW5kX3VzZXJfaWRgIGpvaW4gaWQuIFNlZSBub3RlIGJlbG93LlxuICAgICAgICAqIGBqb2luX2lkc2Agb2JqZWN0IC0gc2V0cyBnbG9iYWwgam9pbiBJRHMgdGhhdCB3aWxsIGJlIGluY2x1ZGVkIG9uIGFsbCBzcGFuc1xuICAgICAgICAgICAgY3JlYXRlZCBieSB0aGUgcnVudGltZS5cbiAgICAgICAgKiBgbG9nX3RvX3N0ZGlvYCBib29sIC0gZWNob3MgYGxvZ2AsIGB3YXJuYCwgYW5kIGBlcnJvcmAgdG8gYHN0ZG91dGAgYW5kIGBzdGRlcnJgLlxuICAgICAgICAgICAgSW4gdGhlIGNhc2Ugb2YgdGhlIGJyb3dzZXIsIHRoaXMgd2lsbCBlbmFibGluZyBlY2hvaW5nIHRvIHRoZSB3ZWIgYnJvd3NlclxuICAgICAgICAgICAgY29uc29sZS4gRGVmYXVsdCBmYWxzZS5cbiAgICAgICAgKiBgb3ZlcnJpZGVfY29uc29sZWAgYm9vbCAtIGlmIHRydWUsIGBjb25zb2xlLmxvZ2AsIGBjb25zb2xlLndhcm5gLCBhbmQgYGNvbnNvbGUuZXJyb3JgXG4gICAgICAgICAgICBjYWxscyB3aWxsIGF1dG9tYXRpY2FsbHkgY3JlYXRlZCBsb2cgcmVjb3Jkcy4gRGVmYXVsdCB0cnVlLlxuICAgICAgICAqIGByZWZyZXNoX2ludGVydmFsX21pbGxpc2AgaW50IC0gc2V0cyB0aGUgcmVwb3J0aW5nIGxvb3AgaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAgICAgICAgRGVmYXVsdCAyNTAwLlxuICAgICAgICAqIGBtYXhfbG9nX3JlY29yZHNgIGludCAtIHNldHMgdGhlIG1heGltdW0gbnVtYmVyIG9mIGxvZyByZWNvcmRzIHRoZSBydW50aW1lXG4gICAgICAgICAgICB3aWxsIGJ1ZmZlciBiZXR3ZWVuIHJlcG9ydHM7IG9ubHkgYSBzdWItc2FtcGxlIG9mIHRoZSByZWNvcmRzIHdpbGwgYmVcbiAgICAgICAgICAgIGtlcHQgYmV5b25kIHRoaXMgbWF4aW11bS4gRGVmYXVsdHMgdG8gMTAyNC5cbiAgICAgICAgKiBgbWF4X3NwYW5fcmVjb3Jkc2AgaW50IC0gc2V0cyB0aGUgbWF4aW11bSBudW1iZXIgb2Ygc3BhbiByZWNvcmRzIHRoZSBydW50aW1lXG4gICAgICAgICAgICB3aWxsIGJ1ZmZlciBiZXR3ZWVuIHJlcG9ydHM7IG9ubHkgYSBzdWItc2FtcGxlIG9mIHRoZSByZWNvcmRzIHdpbGwgYmVcbiAgICAgICAgICAgIGtlcHQgYmV5b25kIHRoaXMgbWF4aW11bS4gRGVmYXVsdHMgdG8gMTAyNC5cbiAgICAgICAgKiBgc2VydmljZV9ob3N0YCBzdHJpbmcgLSBleHBsaWNpdGx5IHNldHMgdGhlIHNlcnZpY2UgaG9zdG5hbWUuXG4gICAgICAgICogYHNlcnZpY2VfcG9ydGAgW2ludHxzdHJpbmddIC0gZXhwbGljaXRseSBzZXRzIHRoZSBzZXJ2aWNlIHBvcnRcbiAgICAgICAgKiBgY2VydGlmaWNhdGVfdmVyaWZpY2F0aW9uYCBib29sIC0gaWYgZmFsc2UsIGh0dHBzIGNvbW11bmljYXRpb24gd2lsbCBub3RcbiAgICAgICAgICAgIHZlcmlmeSBTU0wgY2VydGlmaWNhdGVzLiBUaGlzIGlzIGludGVuZGVkIGZvciBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHNcbiAgICAgICAgICAgIG9ubHkuIERlZmF1bHQgdHJ1ZS5cblxuICAgICoqYGFjY2Vzc190b2tlbmAgYW5kIGBncm91cF9uYW1lYCoqXG5cbiAgICBgYWNjZXNzX3Rva2VuYCBhbmQgYGdyb3VwX25hbWVgIGFyZSB0aGUgb25seSB0d28gcmVxdWlyZWQgY29uZmlndXJhdGlvblxuICAgIG9wdGlvbnMuIFRoZXkgbXVzdCBiZSBzcGVjaWZpZWQgYXMgcGFydCBvZiBhIGNhbGwgdG8gYGluaXRpYWxpemUoKWAgZm9yXG4gICAgdGhlIHJ1bnRpbWUgdG8gYmVnaW4gcmVwb3J0aW5nLlxuXG4gICAgKipgZW5kX3VzZXJfaWRgKipcblxuICAgIFRoZSBgZW5kX3VzZXJfaWRgIGlzIHVzZWZ1bCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIHRoZSBicm93c2VyIHJ1bnRpbWUsXG4gICAgd2hlcmUgYWxsIG9wZXJ0YXRpb25zIHdpbGwgYmUgbWFkZSBvbiBiZWhhbGYgb2YgYSBzaW5nbGUgdXNlci5cbiAgICBJZiB0aGUgd2ViIHNlcnZlciBpcyByZW5kZXJpbmcgdGhlIHNlcnZlZCBwYWdlIGFzIGEgdGVtcGxhdGUgYW5kIGhhcyBhY2Nlc3NcbiAgICB0byB0aGUgY3VycmVudCB1c2VyIGlkLCBpdCBtYXkgYmUgY29udmVuaWVudCB0byBzZXQgdGhpcyBhcyBwYXJ0IG9mIHRoZVxuICAgIHNjcmlwdCBpbml0aWFsaXphdGlvbi5cblxuICAgICpFeGFtcGxlKlxuXG4gICAgVGhpcyBleGFtcGxlIGFzc3VtZXMgYSBIYW5kbGViYXJzLWxpa2UgdGVtcGxhdGUgcmVuZGVyaW5nIHN5bnRheDpcbiAgICBcbiAgICBgYGBodG1sXG4gICAgPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCIgXG4gICAgICAgIHNyYz1cInNjcmlwdHMvcmwtY3J1bnRpbWUtYnJvd3Nlci5taW4uanNcIlxuICAgICAgICBkYXRhLWFjY2Vzc190b2tlbj1cInt7IGNvbmZpZy5hY2Nlc3NfdG9rZW4gfX1cIiBcbiAgICAgICAgZGF0YS1ncm91cF9uYW1lPVwibXlfd2ViX2FwcFwiIFxuICAgICAgICBkYXRhLWVuZF91c2VyX2lkPVwie3sgdXNlcl9wcm9maWxlLnVzZXJuYW1lIH19XCJcbiAgICAgICAgZGF0YS1nbG9iYWxfbmFtZT1cImNyXCI+PC9zY3JpcHQ+XG4gICAgYGBgXG5cbiAgICAqKmBzY3J1YmJlcmAqKlxuXG4gICAgVGhlIGRhdGEgc2NydWJiaW5nIGFsbG93cyBhIHNldCBvZiBjdXN0b20gcnVsZXMgd2hpY2ggd2lsbCBiZSBydW4gYWdhaW5zdCBcbiAgICBhbnkgbG9nIHJlY29yZCBkYXRhIGFuZCBwYXlsb2FkcyBiZWluZyBzZXQgdG8gdGhlIFRyYWNlZ3VpZGUgc2VydmVyLiAgVGhpcyBcbiAgICBhbGxvd3MgcGVyc29uYWwtaWRlbnRpZnlpbmcgaW5mb3JtYXRpb24gb3Igb3RoZXJ3aXNlIHNlY3VyaXR5LXNlbnNpdGl2ZSBcbiAgICBkYXRhIHRvIGJlIHJlbW92ZWQgb3IgcmVwbGFjZSBiZWZvcmUgYW55IGRhdGEgaXMgc2VudCB0byBUcmFjZWd1aWRlLlxuXG4gICAgVGhlIHNjcnViYmluZyBydWxlcyBhcmUgZ2VuZXJhbCBhbmQgZmxleGlibGUuIFNlZSB0aGUgIGZ1bGwgZGF0YSBzY3J1YmJpbmcgXG4gICAgZG9jdW1lbnRhdGlvbiBmb3IgZGV0YWlscyAoY29taW5nIHNvb24hKS5cblxuICAgICpFeGFtcGxlKlxuXG4gICAgYGBganNvblxuICAgIHtcbiAgICAgICAgXCJzY3J1YmJlclwiIDoge1xuICAgICAgICAgICAgXCJydWxlc1wiIDogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJtYXRjaFwiIDogWyBcImtleXNcIiwgXCJ1cmxfcXVlcnlfc3RyaW5nXCIgXSxcbiAgICAgICAgICAgICAgICAgICAgXCJvcFwiICAgIDogXCJyZW1vdmVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJrZXlzXCIgIDogWyBcInBhc3N3b3JkXCIsIFwiY2xpZW50X3NlY3JldFwiLCBcInJlZnJlc2hfdG9rZW5cIiBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwibWF0Y2hcIiA6IFwia2V5c1wiLFxuICAgICAgICAgICAgICAgICAgICBcIm9wXCIgICAgOiBcInJlcGxhY2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJrZXlzXCIgIDogWyBcImFwaV90b2tlblwiLCBcImhvbWVfYWRkcmVzc1wiLCBcInBob25lX251bWJlclwiIF0sXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIiA6IFwiPGhpZGRlbj5cIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgIH1cbiAgICBgYGBcbiAqL1xuUnVudGltZS5wcm90b3R5cGUub3B0aW9ucyA9IGZ1bmN0aW9uKCkgeyBcbiAgICByZXR1cm4gaW1wLm9wdGlvbnMuYXBwbHkoaW1wLCBhcmd1bWVudHMpOyBcbn07XG5cbi8qKlxuICAgIEBncm91cCBDb25maWd1cmF0aW9uXG4gICAgQGJyaWVmIHNldHMgYXR0cmlidXRlcyBvbiB0aGUgcnVudGltZVxuICAgIEBzaWduYXR1cmUgYXR0cmlidXRlcyAoKSAtPiBvYmplY3RcbiAgICBAc2lnbmF0dXJlIGF0dHJpYnV0ZXMgKGF0dHJzKVxuXG4gICAgOjo6IG1hcmtcbiAgICBBcyBmYXIgYXMgdGhlIGN1c3RvbWVyIGlzIGNvbmNlcm5lZCwgd2hhdCBhcmUgYXR0cmlidXRlcyBmb3IuLi4/XG4gICAgOjo6XG5cbiAgICBJZiBjYWxsZWQgd2l0aCBubyBhcmd1bWVudHMgcmV0dXJucyBhIG1hcCBvZiB0aGUgY3VycmVudCBhdHRyaWJ1dGVzXG4gICAgYXMgYSBzZXQgb2Yga2V5LXZhbHVlIHBhaXJzLlxuXG4gICAgTWVyZ2VzIGludG8gYWRkaXRpb25hbCBhdHRyaWJ1dGVzIHRoYXQgZGVzY3JpYmUgXG4gICAgdGhlIHJ1bnRpbWUuICBSZXBsYWNlcyBleGlzdGluZyBhdHRyaWJ1dGVzIGlmIHRoZSBrZXktdmFsdWUgcGFpciBhbHJlYWR5IGV4aXN0cy5cblxuICAgICogYGF0dHJzYCBvYmplY3QgLSBrZXktdmFsdWUgcGFpcnMgdG8gbWVyZ2UgaW50byB0aGUgcnVudGltZSBhdHRyaWJ1dGVzXG4gKi9cblJ1bnRpbWUucHJvdG90eXBlLmF0dHJpYnV0ZXMgPSBmdW5jdGlvbigpIHsgXG4gICAgcmV0dXJuIGltcC5ydW50aW1lQXR0cmlidXRlcy5hcHBseShpbXAsIGFyZ3VtZW50cyk7IFxufTtcblxuLyoqXG4gICAgQGdyb3VwIENvbmZpZ3VyYXRpb25cbiAgICBAYnJpZWYgcmV0dXJucyB0aGUgcnVudGltZSdzIGdsb2JhbGx5IHVuaXF1ZSBpbmRlbnRpZmllciBcbiAgICBAc2lnbmF0dXJlIGd1aWQgKCkgLT4gc3RyaW5nXG5cbiAgICBSZXR1cm5zIHRoZSBydW50aW1lJ3MgR1VJRFxuXG4gICAgKiBgcmV0dXJuYCBzdHJpbmcgLSB0aGUgcnVudGltZSBHVUlEXG4gKi9cblJ1bnRpbWUucHJvdG90eXBlLmd1aWQgPSBmdW5jdGlvbigpIHsgXG4gICAgcmV0dXJuIGltcC5ydW50aW1lR1VJRCgpOyBcbn07XG5cbi8qKlxuICAgIEBncm91cCBDb25maWd1cmF0aW9uXG4gICAgQGJyaWVmIHJldHVybnMgdHJ1ZSBpZiBpbnN0cnVtZW50YXRpb24gaXMgY3VycmVudGx5IGVuYWJsZWRcbiAgICBAc2lnbmF0dXJlIGVuYWJsZWQgKCkgLT4gYm9vbFxuXG4gICAgUmV0dXJucyB3aGV0aGVyIHRoZSBydW50aW1lIGlzIGVuYWJsZWQuXG5cbiAgICAqIGByZXR1cm5gIGJvb2wgLSByZXR1cm5zIHdoZXRoZXIgdGhlIHJ1bnRpbWUgaXMgY3VycmVudGx5IGVuYWJsZWQuXG4gKi9cblJ1bnRpbWUucHJvdG90eXBlLmVuYWJsZWQgPSBmdW5jdGlvbigpIHsgXG4gICAgcmV0dXJuIGltcC5nZXRFbmFibGVkKCk7IFxufTtcblxuLyoqIFxuICAgIEBncm91cCBDb25maWd1cmF0aW9uXG4gICAgQGJyaWVmIHJldHVybnMgdHJ1ZSBpZiB0aGUgcnVudGltZSBpcyBpbiB2ZXJib3NlIG1vZGVcbiAgICBAc2lnbmF0dXJlIHZlcmJvc2UgKCkgLT4gYm9vbFxuXG4gICAgUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHJ1bnRpbWUgaXMgaW4gdmVyYm9zZSBtb2RlLlxuXG4gICAgSW4gdGhpcyBtb2RlLCBhZGRpdGlvbmFsIHNwYW5zIGFuZCBsb2dzIGFyZSByZWNvcmRlZC4gSW50ZW5kZWQgZm9yXG4gICAgZGVidWdnaW5nIHB1cnBvc2VzLlxuXG4gICAgKiBgcmV0dXJuYCBib29sIC0gcmV0dXJucyB3aGV0aGVyIHRoZSBydW50aW1lIGlzIGN1cnJlbnRseSBlbmFibGVkLlxuICovXG5SdW50aW1lLnByb3RvdHlwZS52ZXJib3NlID0gZnVuY3Rpb24oKSB7IFxuICAgIHJldHVybiBpbXAuZ2V0VmVyYm9zZSgpOyBcbn07XG5cbi8qXG4gICAgRVhQRVJJTUVOVEFMIFxuICAgIFJldHVybnMgYSBzdGF0dXMgb2JqZWN0IGRlc2NyaWJpbmcgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHJ1bnRpbWUuXG4gKi9cblJ1bnRpbWUucHJvdG90eXBlLnN0YXR1cyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wLmdldFN0YXR1cygpOyB9O1xuXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXG4vLyBMb2dnaW5nXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXG5cbi8vIC0tIGNvbnNvbGUgb2JqZWN0IGNvbXBhdGlibGUgQVBJIC0tLSBcbi8vXG4vLyBUYWtlcyB2YXJpYWJsZSBudW1iZXJzIG9mIGFyZ3VtZW50cywgbG9nZ2luZyB0aGVtIGFzIGEgc3BhY2Utc2VwYXJhdGVkIFxuLy8gbGlzdC5cbi8vXG5cbi8qKlxuICAgIEBncm91cCBMb2dnaW5nXG4gICAgQGJyaWVmIGNyZWF0ZSBhIG5vcm1hbCBsb2cgcmVjb3JkIGFuZCBvcHRpb25hbCBwYXlsb2FkIGluZm9ybWF0aW9uXG4gICAgQHNpZ25hdHVyZSBsb2cgKGFueS4uLilcblxuICAgIFJlY29yZHMgYSBsb2cgc3RhdGVtZW50LiBUaGUgY2FsbCBzaWduYXR1cmUgaXMgaW50ZW5kZWQgdG8gYmUgdGhlIHNhbWVcbiAgICBhcyBgY29uc29sZS5sb2dgLlxuXG4gICAgTG9nIHN0YXRlbWVudHMgYXJlICpub3QqIGVjaG9lZCB0byBgc3Rkb3V0YCAob3IgdGhlIHdlYiBicm93c2VyIGNvbnNvbGUpIGJ5IFxuICAgIGRlZmF1bHQuICBVc2UgdGhlIGBsb2dfdG9fc3RkaW9gIG9wdGlvbiBpbiBgaW5pdGFsaXplKClgIG9yIGBvcHRpb24oKWAgdG8gXG4gICAgZW5hYmxlIGVjaG9pbmcuXG4gKi9cblJ1bnRpbWUucHJvdG90eXBlLmxvZyAgICAgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGltcC5sb2dBcmd1bWVudHNJbmZvKGFyZ3VtZW50cyk7IH07XG5cbi8qKlxuICAgIEBncm91cCBMb2dnaW5nXG4gICAgQGJyaWVmIGNyZWF0ZSBhIG5vcm1hbCBsb2cgcmVjb3JkIGFuZCBvcHRpb25hbCBwYXlsb2FkIGluZm9ybWF0aW9uXG4gICAgQHNpZ25hdHVyZSBpbmZvIChhbnkuLi4pXG5cbiAgICBSZWNvcmRzIGEgbG9nIHN0YXRlbWVudC4gVGhlIGNhbGwgc2lnbmF0dXJlIGlzIGludGVuZGVkIHRvIGJlIHRoZSBzYW1lXG4gICAgYXMgYGNvbnNvbGUubG9nYC4gIGBpbmZvKClgIGlzIGFuIGFsaWFzIGZvciBgbG9nKClgLlxuXG4gICAgTG9nIHN0YXRlbWVudHMgYXJlICpub3QqIGVjaG9lZCB0byBgc3Rkb3V0YCAob3IgdGhlIHdlYiBicm93c2VyIGNvbnNvbGUpIGJ5IFxuICAgIGRlZmF1bHQuICBVc2UgdGhlIGBsb2dfdG9fc3RkaW9gIG9wdGlvbiBpbiBgaW5pdGFsaXplKClgIG9yIGBvcHRpb24oKWAgdG8gXG4gICAgZW5hYmxlIGVjaG9pbmcuXG4gKi9cblJ1bnRpbWUucHJvdG90eXBlLmluZm8gICAgPSBmdW5jdGlvbigpIHsgXG4gICAgcmV0dXJuIGltcC5sb2dBcmd1bWVudHNJbmZvKGFyZ3VtZW50cyk7IFxufTtcblxuLyoqXG4gICAgQGdyb3VwIExvZ2dpbmdcbiAgICBAYnJpZWYgbG9nIGEgd2FybmluZyBhbmQgb3B0aW9uYWwgcGF5bG9hZCBpbmZvcm1hdGlvblxuICAgIEBzaWduYXR1cmUgd2FybiAoYW55Li4uKVxuXG4gICAgUmVjb3JkcyBhIGxvZyBzdGF0ZW1lbnQuIFRoZSBjYWxsIHNpZ25hdHVyZSBpcyBpbnRlbmRlZCB0byBiZSB0aGUgc2FtZVxuICAgIGFzIGBjb25zb2xlLndhcm5gLlxuXG4gICAgTG9nIHN0YXRlbWVudHMgYXJlICpub3QqIGVjaG9lZCB0byBgc3Rkb3V0YCAob3IgdGhlIHdlYiBicm93c2VyIGNvbnNvbGUpIGJ5IFxuICAgIGRlZmF1bHQuICBVc2UgdGhlIGBsb2dfdG9fc3RkaW9gIG9wdGlvbiBpbiBgaW5pdGFsaXplKClgIG9yIGBvcHRpb24oKWAgdG8gXG4gICAgZW5hYmxlIGVjaG9pbmcuXG4gKi9cblJ1bnRpbWUucHJvdG90eXBlLndhcm4gICAgPSBmdW5jdGlvbigpIHsgXG4gICAgcmV0dXJuIGltcC5sb2dBcmd1bWVudHNXYXJuKGFyZ3VtZW50cyk7IFxufTtcblxuLyoqXG4gICAgQGdyb3VwIExvZ2dpbmdcbiAgICBAYnJpZWYgbG9nIGFuIGVycm9yIGFuZCBvcHRpb25hbCBwYXlsb2FkIGluZm9ybWF0aW9uXG4gICAgQHNpZ25hdHVyZSBlcnJvciAoYW55Li4uKVxuXG4gICAgUmVjb3JkcyBhIGxvZyBzdGF0ZW1lbnQuIFRoZSBjYWxsIHNpZ25hdHVyZSBpcyBpbnRlbmRlZCB0byBiZSB0aGUgc2FtZVxuICAgIGFzIGBjb25zb2xlLmVycm9yYC5cblxuICAgIExvZyBzdGF0ZW1lbnRzIGFyZSAqbm90KiBlY2hvZWQgdG8gYHN0ZGVycmAgKG9yIHRoZSB3ZWIgYnJvd3NlciBjb25zb2xlKSBieSBcbiAgICBkZWZhdWx0LiAgVXNlIHRoZSBgbG9nX3RvX3N0ZGlvYCBvcHRpb24gaW4gYGluaXRhbGl6ZSgpYCBvciBgb3B0aW9uKClgIHRvIFxuICAgIGVuYWJsZSBlY2hvaW5nLlxuICovXG5SdW50aW1lLnByb3RvdHlwZS5lcnJvciAgID0gZnVuY3Rpb24oKSB7IHJldHVybiBpbXAubG9nQXJndW1lbnRzRXJyb3IoYXJndW1lbnRzKTsgfTtcblxuLyoqXG4gICAgQGdyb3VwIExvZ2dpbmdcbiAgICBAYnJpZWYgbG9nIGEgZmF0YWwgZXJyb3IgYW5kIG9wdGlvbmFsIHBheWxvYWQgaW5mb3JtYXRpb25cbiAgICBAc2lnbmF0dXJlIGZhdGFsIChhbnkuLi4pXG5cbiAgICBSZWNvcmRzIGEgbG9nIHN0YXRlbWVudCBhbmQgZXhpdHMgdGhlIHByb2Nlc3MuIFRoZSBjYWxsIHNpZ25hdHVyZSBpcyBpbnRlbmRlZCBcbiAgICB0byBiZSB0aGUgc2FtZSBhcyBgY29uc29sZS5lcnJvcmAgd2l0aCB0aGUgYWRkaXRpb24gdGhlIGNhbGwgd2lsbCB0ZXJtaW5hdGVcbiAgICB0aGUgcHJvY2VzcyBhZnRlciB0aGUgbG9nIHN0YXRlbWVudCBpcyBtYWRlLlxuXG4gICAgVGhlIHJ1bnRpbWUgKndpbGwqIGF0dGVtcHQgYSBmaW5hbCBmbHVzaCBvZiBidWZmZXJlZCBkYXRhIGJlZm9yZSBwcm9jZXNzXG4gICAgdGVybWluYXRpb24uXG5cbiAgICBPbiB0aGUgYnJvd3NlciwgdGhpcyBmdW5jdGlvbiBpcyBlcXVpdmFsZW50IHRvIGEgY2FsbCB0byBgZXJyb3JgIGFzIHRoZXJlXG4gICAgaXMgbm8gcHJvY2VzcyB0byB0ZXJtaW5hdGUgaW4gdGhlIGNvbnRleHQgb2YgYSBicm93c2VyLlxuICovXG5SdW50aW1lLnByb3RvdHlwZS5mYXRhbCAgID0gZnVuY3Rpb24oKSB7IFxuICAgIHJldHVybiBpbXAubG9nQXJndW1lbnRzRmF0YWwoYXJndW1lbnRzKTsgXG59O1xuXG4vLyAtLSBnbG9nIC8gc3ByaW50ZiBjb21wYXRpYmxlIEFQSSAtLS0gLy9cbi8vXG4vLyBUYWtlcyBzcHJpbnRmLWxpa2UgZm9ybWF0IHN0cmluZyBhcyBhIGZpcnN0IGFyZ3VtZW50IGZvbGxvd2VkIGJ5IGEgc2VyaWVzXG4vLyBvZiBkYXRhIG9iamVjdHMuXG4vL1xuXG5SdW50aW1lLnByb3RvdHlwZS5sb2dmICAgID0gZnVuY3Rpb24oKSB7IHJldHVybiBpbXAubG9nRm9ybWF0dGVkSW5mbyhhcmd1bWVudHMpOyB9O1xuUnVudGltZS5wcm90b3R5cGUuaW5mb2YgICA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wLmxvZ0Zvcm1hdHRlZEluZm8oYXJndW1lbnRzKTsgfTtcblJ1bnRpbWUucHJvdG90eXBlLndhcm5mICAgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGltcC5sb2dGb3JtYXR0ZWRXYXJuKGFyZ3VtZW50cyk7IH07XG5SdW50aW1lLnByb3RvdHlwZS5lcnJvcmYgID0gZnVuY3Rpb24oKSB7IHJldHVybiBpbXAubG9nRm9ybWF0dGVkRXJyb3IoYXJndW1lbnRzKTsgfTtcblJ1bnRpbWUucHJvdG90eXBlLmZhdGFsZiAgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGltcC5sb2dGb3JtYXR0ZWRGYXRhbChhcmd1bWVudHMpOyB9O1xuXG4vLyAtLSBsb2dnaW5nIGRpcmVjdGx5IHRvIGNvbnNvbGUgd2l0aG91dCBpbnN0cnVtZW50YXRpb24gLS0gLy9cblxuUnVudGltZS5wcm90b3R5cGUucGxhaW4gPSB7fTtcblJ1bnRpbWUucHJvdG90eXBlLnBsYWluLmxvZyAgID0gZnVuY3Rpb24oKSB7IHJldHVybiBpbXAucGxhaW5Mb2cuYXBwbHkoaW1wLCBhcmd1bWVudHMpOyB9O1xuUnVudGltZS5wcm90b3R5cGUucGxhaW4ud2FybiAgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGltcC5wbGFpbldhcm4uYXBwbHkoaW1wLCBhcmd1bWVudHMpOyB9O1xuUnVudGltZS5wcm90b3R5cGUucGxhaW4uZXJyb3IgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGltcC5wbGFpbkVycm9yLmFwcGx5KGltcCwgYXJndW1lbnRzKTsgfTtcblxuLy8gLS0gbG9nZ2luZyBhY3RpdmUgb25seSBpbiB2ZXJib3NlIG1vZGUgLS0gLy9cblxuUnVudGltZS5wcm90b3R5cGUudjEgPSB7fTtcblJ1bnRpbWUucHJvdG90eXBlLnYxLmxvZyAgID0gZnVuY3Rpb24oKSB7IHJldHVybiBpbXAudmVyYm9zZSgpID8gbGliLmxvZy5hcHBseShsaWIsIGFyZ3VtZW50cykgOiB1bmRlZmluZWQ7IH07XG5SdW50aW1lLnByb3RvdHlwZS52MS5pbmZvICA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wLnZlcmJvc2UoKSA/IGxpYi5pbmZvLmFwcGx5KGxpYiwgYXJndW1lbnRzKSA6IHVuZGVmaW5lZDsgfTtcblJ1bnRpbWUucHJvdG90eXBlLnYxLndhcm4gID0gZnVuY3Rpb24oKSB7IHJldHVybiBpbXAudmVyYm9zZSgpID8gbGliLndhcm4uYXBwbHkobGliLCBhcmd1bWVudHMpIDogdW5kZWZpbmVkOyB9O1xuUnVudGltZS5wcm90b3R5cGUudjEuZXJyb3IgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGltcC52ZXJib3NlKCkgPyBsaWIuZXJyb3IuYXBwbHkobGliLCBhcmd1bWVudHMpIDogdW5kZWZpbmVkOyB9O1xuXG4vLyAtLSBtaXNjZWxsYW5lb3VzIC0tIC8vXG5cbi8qKlxuICAgIEBncm91cCBMb2dnaW5nXG4gICAgQGJyaWVmIGxvZyBhbiBleGNlcHRpb24gb2JqZWN0IHdpdGggZXJyb3IgaW5mb3JtYXRpb25cbiAgICBAc2lnbmF0dXJlIGV4Y2VwdGlvbihlcnIpXG5cbiAgICBBIHNwZWNpYWwtY2FzZSBsb2cgY2FsbCB0aGF0IHdpbGwgbG9nIGV4Y2VwdGlvbiBvYmplY3RzIGluIGEgY29uc2lzdGVudCBcbiAgICBtYW5uZXIgdGhhdCBhbHNvIGNhcHR1cmVzIGFzIG11Y2ggYWdncmVnYXRlIGluZm9ybWF0aW9uIGFzIHBvc3NpYmxlLlxuXG4gICAgKiBgZXJyYCBhbnkgLSBhbnkgZXhjZXB0aW9uLWxpa2Ugb2JqZWN0XG4gKi9cblJ1bnRpbWUucHJvdG90eXBlLmV4Y2VwdGlvbiA9IGZ1bmN0aW9uKGUpIHsgXG4gICAgcmV0dXJuIGltcC5sb2dFeGNlcHRpb24oZSk7IFxufTtcblxuLypFWFBFUklNRU5UQUxcbiAgICBDcmVhdGUgYSBkZXRhaWxlZCBsb2cgcmVjb3JkIGZpZWxkLWJ5LWZpZWxkXG4gKi9cblJ1bnRpbWUucHJvdG90eXBlLmxvZ1JlY29yZCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wLmxvZ1JlY29yZC5hcHBseShpbXAsIGFyZ3VtZW50cyk7IH07XG5cbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cbi8vIEV2ZW50c1xuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuXG5SdW50aW1lLnByb3RvdHlwZS5ldmVudCAgICAgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGltcC5sb2dFdmVudC5hcHBseShpbXAsIGFyZ3VtZW50cyk7IH07XG5SdW50aW1lLnByb3RvdHlwZS5ldmVudFdyYXAgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGltcC5ldmVudFdyYXAuYXBwbHkoaW1wLCBhcmd1bWVudHMpOyB9O1xuXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXG4vLyBTcGFuc1xuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuXG4vKipcbiAgICBAZ3JvdXAgU3BhbnNcbiAgICBAYnJpZWYgY3JlYXRlIGEgbmV3IHNwYW4gZm9yIGFuIG9wZXJhdGlvblxuICAgIEBzaWduYXR1cmUgc3BhbiAob3BlcmF0aW9uKSAtPiBTcGFuSGFuZGxlXG4gICAgQHNpZ25hdHVyZSBzcGFuIChvcGVyYXRpb24sIGpvaW5JZEtleVZhbHVlcykgLT4gU3BhbkhhbmRsZVxuICAgIEBzaWduYXR1cmUgc3BhbiAob3BlcmF0aW9uLCBjYWxsdGhyb3VnaCkgLT4gYW55XG4gICAgQHNpZ25hdHVyZSBzcGFuIChvcGVyYXRpb24sIGpvaW5JZEtleVZhbHVlcywgY2FsbHRocm91Z2gpIC0+IGFueVxuXG4gICAgQ3JlYXRlcyBhIGhhbmRsZSBvYmplY3QgdG8gYSBuZXcgc3Bhbi5cblxuICAgICogYG9wZXJhdGlvbmAgc3RyaW5nIC0gdGhlIHN0cmluZyBuYW1lIG9mIHRoZSBvcGVyYXRpb24gdGhhdCByZXByZXNlbnRzXG4gICAgKiBgam9pbklkS2V5VmFsdWVzYCBvYmplY3QgLSBhIG1hcCBvZiBrZXktdmFsdWUgcGFpcnMgdGhhdCB3aWxsIGJlIGFkZGVkIHRvXG4gICAgICAgIHRoZSBzcGFuIGhhbmRsZVxuICAgICogYGNhbGx0aHJvdWdoYCBmKGhhbmRsZSkgLSBcbiAgICAgICAgKiBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBpbnZva2VkIHdpdGggYSBzaW5nbGUgYXJndW1lbnRcbiAgICAgICAgb2YgdGhlIHNwYW4gaGFuZGxlXG4gICAgICAgICogVGhlIHNwYW4gaXMgYXV0b21hdGljYWxsZWQgYGVuZCgpYCdlZCB1cG9uIHJldHVybiBvZiB0aGVcbiAgICAgICAgY2FsbHRocm91Z2hcbiAgICAgICAgKiBBbnkgZXhjZXB0aW9ucyB0aHJvdyBieSB0aGUgY2FsbHRocm91Z2ggd2lsbCBiZSBsb2dnZWQgYW5kIHBhc3NlZCBvbnRvXG4gICAgICAgIHRoZSBjYWxsZXJcbiAgICAgICAgKiBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBjYWxsIHRocm91Z2ggd2lsbCBiZWNvbWUgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGVcbiAgICAgICAgYHNwYW4oKWAgY2FsbFxuICAgICogYHJldHVybmAgYW55XG4gICAgICAgICogSWYgYGNhbGx0aHJvdWdoYCBpcyAqbm90KiBzcGVjaWZpZWQsIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSBhXG4gICAgICAgIGhhbmRsZSB0byB0aGUgbmV3bHkgY3JlYXRlZCBzcGFuXG4gICAgICAgICogSWYgYGNhbGx0aHJvdWdoYCBpcyBzcGVjaWZpZWQsIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSB0aGUgcmV0dXJuXG4gICAgICAgIHZhbHVlIG9mIHRoZSBjYWxsdGhyb3VnaFxuICovXG5SdW50aW1lLnByb3RvdHlwZS5zcGFuICAgICAgICA9IGZ1bmN0aW9uKCkgeyBcbiAgICByZXR1cm4gaW1wLnNwYW4uYXBwbHkoaW1wLCBhcmd1bWVudHMpOyBcbn07XG5cbi8qKlxuICAgIEBncm91cCBTcGFuc1xuICAgIEBicmllZiB3cmFwIGEgc3luY2hyb25vdXMgZnVuY3Rpb24gY2FsbCBpbiBhbiBvcGVyYXRpb25cbiAgICBAc2lnbmF0dXJlIGNhbGxTeW5jIChvcGVyYXRpb24sIGYsIFtzZWxmXSwgW2FyZzBdLCBbYXJnMV0sIC4uLikgLT4gYW55XG4gICAgQHNpZ25hdHVyZSBjYWxsU3luYyAob3BlcmF0aW9uLCBqb2luSWRzLCBmLCBbc2VsZl0sIFthcmcwXSwgW2FyZzFdLCAuLi4pIC0+IGFueVxuXG4gICAgSW52b2tlcyBhIGZ1bmN0aW9uIHNpbWlsYXJseSB0byB0aGUgbmF0aXZlIGBjYWxsYCBmdW5jdGlvbiBidXQgYWxzbyB3cmFwc1xuICAgIHRoZSBjYWxsIGluc2lkZSBhIHNwYW4gd2l0aCB0aGUgZ2l2ZW4gb3BlcmF0aW9uIG5hbWUuICBJdCB3aWxsIGF1dG9tYXRpY2FsbHlcbiAgICBsb2cgY2FsbCBhcmd1bWVudHMsIHJldHVybiB2YWx1ZXMsIGFuZCBhbnkgZXhjZXB0aW9uczsgdGhlIHNwYW4gaXRzZWxmIGlzXG4gICAgYXV0b21hdGljYWxseSBiZWd1biBhbmQgZW5kZWQgc2NvcGVkIHRvIHRoZSBjYWxsLlxuXG4gICAgVGhlIGludm9rZWQgZnVuY3Rpb24gbXVzdCBiZSBhIHN5bmNocm9ub3VzIGZ1bmN0aW9uLlxuXG4gICAgKiBgb3BlcmF0aW9uYCBzdHJpbmcgLSB0aGUgb3BlcmF0aW9uIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBjcmVhdGVkIHNwYW5cbiAgICAqIGBqb2luSWRzYCBvYmplY3QgLSBqb2luIElEcyB0byBzZXQgb24gdGhlIGNyZWF0ZWQgc3BhblxuICAgICogYGZgIGZ1bmN0aW9uIC0gdGhlIGZ1bmN0aW9uIHRvIGludm9rZVxuICAgICogYHNlbGZgIG9iamVjdCAtIHRoZSBgdGhpc2AgdmFsdWUgdG8gdXNlIHdoZW4gaW52b2tpbmcgYGZgXG4gICAgKiBgYXJnLi4uYCBhbnkgLSB0aGUgYXJndW1lbnRzIHRvIHBhc3Mgd2hlbiBpbnZva2luZyBgZmBcbiAgICAqIGByZXR1cm5gIGFueSAtIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBpbnZva2VkIGZ1bmN0aW9uIGBmYFxuXG5cbiAgICAqRXhhbXBsZSpcblxuICAgIGBgYGpzXG4gICAgZnVuY3Rpb24gYWRkIChhLCBiKSB7IFxuICAgICAgICByZXR1cm4gYSArIGI7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGFuIG9wZXJhdGlvbiBuYW1lZCBcIm15X2FkZF9vcGVyYXRpb25cIiBmb3IgdGhlIGNhbGwgdG8gdGhlXG4gICAgLy8gYWRkIGZ1bmN0aW9uLlxuICAgIHZhciByZXN1bHQgPSBjci5jYWxsU3luYyhcIm15X2FkZF9vcGVyYXRpb25cIiwgYWRkLCBudWxsLCA0MCwgMik7XG4gICAgY29uc29sZS5sb2cocmVzdWx0KTsgICAgLy8gcHJpbnRzIFwiNDJcIlxuICAgIGBgYFxuICovXG5SdW50aW1lLnByb3RvdHlwZS5jYWxsU3luYyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpbXAuY2FsbFN5bmMuYXBwbHkoaW1wLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gICAgQGdyb3VwIFNwYW5zXG4gICAgQGJyaWVmIHdyYXAgYSBzeW5jaHJvbm91cyBmdW5jdGlvbiBjYWxsIGluIGFuIG9wZXJhdGlvblxuICAgIEBzaWduYXR1cmUgYXBwbHlTeW5jIChvcGVyYXRpb24sIGYsIFtzZWxmXSwgW2FyZ3NdKSAtPiBhbnlcbiAgICBAc2lnbmF0dXJlIGFwcGx5U3luYyAob3BlcmF0aW9uLCBqb2luSWRzLCBmLCBbc2VsZl0sIFthcmdzXSkgLT4gYW55XG5cbiAgICBCZWhhdmVzIGV4YWN0bHkgdGhlIHNhbWUgYGNhbGxTeW5jYCBidXQgdGhlIGZ1bmN0aW9uIGFyZ3VtZW50cyBhcmUgcGFzc2VkXG4gICAgYXMgYW4gYXJyYXkuXG4gKi9cblJ1bnRpbWUucHJvdG90eXBlLmFwcGx5U3luYyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpbXAuYXBwbHlTeW5jLmFwcGx5KGltcCwgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICAgIEBncm91cCBTcGFuc1xuICAgIEBicmllZiB3cmFwIGFuIGFzeW5jaHJvbm91cyBmdW5jdGlvbiBjYWxsIGluIGFuIG9wZXJhdGlvblxuICAgIEBzaWduYXR1cmUgY2FsbEFzeW5jIChvcGVyYXRpb24sIGYsIFtzZWxmXSwgW2FyZzBdLCBbYXJnMV0sIC4uLiwgY2FsbGJhY2spIC0+IGFueVxuICAgIEBzaWduYXR1cmUgY2FsbEFzeW5jIChvcGVyYXRpb24sIGpvaW5JZHMsIGYsIFtzZWxmXSwgW2FyZzBdLCBbYXJnMV0sIC4uLiwgY2FsbGJhY2spIC0+IGFueVxuXG4gICAgVGhlIGFzeW5jaHJvbm91cyB2ZXJzaW9uIG9mIGBjYWxsU3luY2AuIFRoaXMgYXNzdW1lcyB0aGUgZmluYWwgYXJndW1lbnRcbiAgICB0byBgZmAgd2lsbCBiZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgaW52b2tlZCB3aGVuIHRoZSBhc3luY2hyb25vdXNcbiAgICBmdW5jdGlvbiBpcyBjb21wbGV0ZSBhbmQgdGhhdCB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgaXMgYW4gb3B0aW9uYWwgZXJyb3IgYXJndW1lbnQuXG5cblxuICAgICpFeGFtcGxlKlxuXG4gICAgYGBganNcbiAgICBmdW5jdGlvbiBhZGQgKGEsIGIsIGRvbmUpIHsgXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBUaGUgZmlyc3QgYXJndW1lbnQgaXMgdGhlIGVycm9yLCBpZiBvbmUgb2NjdXJyZWRcbiAgICAgICAgICAgIGRvbmUobnVsbCwgYSArIGIpO1xuICAgICAgICB9LCA1MCk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGFuIG9wZXJhdGlvbiBuYW1lZCBcIm15X2FkZF9vcGVyYXRpb25cIiBmb3IgdGhlIGNhbGwgdG8gdGhlXG4gICAgLy8gYWRkIGZ1bmN0aW9uLlxuICAgIGNyLmNhbGxBc3luYyhcIm15X2FkZF9vcGVyYXRpb25cIiwgYWRkLCBudWxsLCA0MCwgMiwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTsgICAgLy8gcHJpbnRzIFwiNDJcIlxuICAgIH0pO1xuICAgIGBgYCAgICBcbiAqL1xuUnVudGltZS5wcm90b3R5cGUuY2FsbEFzeW5jID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGltcC5jYWxsQXN5bmMuYXBwbHkoaW1wLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gICAgQGdyb3VwIFNwYW5zXG4gICAgQGJyaWVmIHdyYXAgYW4gYXN5bmNocm9ub3VzIGZ1bmN0aW9uIGNhbGwgaW4gYW4gb3BlcmF0aW9uXG4gICAgQHNpZ25hdHVyZSBhcHBseUFzeW5jIChvcGVyYXRpb24sIGYsIFtzZWxmXSwgW2FyZ3NdKSAtPiBhbnlcbiAgICBAc2lnbmF0dXJlIGFwcGx5QXN5bmMgKG9wZXJhdGlvbiwgam9pbklkcywgZiwgW3NlbGZdLCBbYXJnc10pIC0+IGFueVxuXG4gICAgQmVoYXZlcyBleGFjdGx5IGFzIGBjYWxsQXN5bmNgIHdpdGggdGhlIGV4Y2VwdGlvbiB0aGF0IHRoZSBhcmd1bWVudHMgdG8gdGhlXG4gICAgaW52b2tlZCBmdW5jdGlvbiBhcmUgcGFzc2VkIGFzIGFuIGFycmF5LiBUaGUgZmluYWwgZWxlbWVudCBvZiB0aGUgYXJyYXkgaXNcbiAgICBleHBlY3RlZCB0byBiZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKi9cblJ1bnRpbWUucHJvdG90eXBlLmFwcGx5QXN5bmMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaW1wLmFwcGx5QXN5bmMuYXBwbHkoaW1wLCBhcmd1bWVudHMpO1xufTtcblxuXG5cblJ1bnRpbWUucHJvdG90eXBlLnNwYW5XcmFwICAgID0gZnVuY3Rpb24oKSB7IHJldHVybiBpbXAuc3BhbldyYXAuYXBwbHkoaW1wLCBhcmd1bWVudHMpOyB9O1xuUnVudGltZS5wcm90b3R5cGUuc3BhblNlY3Rpb24gPSBmdW5jdGlvbigpIHsgcmV0dXJuIGltcC5zcGFuU2VjdGlvbi5hcHBseShpbXAsIGFyZ3VtZW50cyk7IH07XG5SdW50aW1lLnByb3RvdHlwZS5zcGFuTWFudWFsICA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wLnNwYW5NYW51YWwuYXBwbHkoaW1wLCBhcmd1bWVudHMpOyB9O1xuXG5SdW50aW1lLnByb3RvdHlwZS5zZXRBY3RpdmVTcGFuTmFtZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wLnNldEFjdGl2ZVNwYW5OYW1lLmFwcGx5KGltcCwgYXJndW1lbnRzKTsgfTtcblxuLypFWFBFUklNRU5UQUxcblxuICAgIElmIGNhbGxlZCB3aXRoIGFuIG9iamVjdCBhbmQgYSB0aGUgc3BhbiBoYW5kbGUsIHRoYXQgc3BhbiBoYW5kbGUgd2lsbCBiZVxuICAgIGFzc29jaWF0ZWQgd2l0aCB0aGUgb2JqZWN0LlxuXG4gICAgSWYgY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LiBSZXR1cm4gdGhlIHNwYW4gaGFuZGxlIGFzc29jaWF0ZWQgd2l0aCB0aGUgXG4gICAgZ2l2ZW4gb2JqZWN0IChlLmcuIEhUVFAgcmVxdWVzdCAgb2JqZWN0KSBpZiB0aGVyZSBpcyBvbmUuIElmIHRoZXJlIGlzIG5vdFxuICAgIGEgc3BhbiBoYW5kbGUgZm9yIHRoYXQgb2JqZWN0LCB0aGUgYWN0aXZlIHNwYW4gaXMgcmV0dXJuIChpZiBpdCBpcyBrbm93bikuXG4gICAgSWYgbm8gYWN0aXZlIHNwYW4ga25vd24sIGEgdmFsaWQgc3BhbiBoYW5kbGUgaW50ZXJmYWNlIGlzIHJldHVybmVkLCBidXQgXG4gICAgZG9lcyBub3QgY29ycmVzcG9uZCB0byBhbnkgcGFydGljdWxhciBzcGFuIChlLmcuIGFsbCBsb2dzIHJlY29yZGVkIHVzaW5nXG4gICAgdGhhdCBpbnRlcmZhY2UgZ2xvYmFsbHkpLlxuICovXG5SdW50aW1lLnByb3RvdHlwZS5zcGFuRm9yT2JqZWN0ID0gZnVuY3Rpb24ob2JqLCBoYW5kbGUpIHsgXG4gICAgcmV0dXJuIGltcC5zcGFuRm9yT2JqZWN0LmFwcGx5KGltcCwgYXJndW1lbnRzKTsgXG59O1xuXG4vLyBMaWJyYXJ5IGluc3RydW1lbnRhdGlvbiBoZWxwZXJzXG5SdW50aW1lLnByb3RvdHlwZS5nZXRBY3RpdmVKb2luSWRzID0gZnVuY3Rpb24oKSB7IHJldHVybiBpbXAuZ2V0QWN0aXZlSm9pbklkcy5hcHBseShpbXAsIGFyZ3VtZW50cyk7IH07XG5SdW50aW1lLnByb3RvdHlwZS5zZXRBY3RpdmVKb2luSWRzID0gZnVuY3Rpb24oKSB7IHJldHVybiBpbXAuc2V0QWN0aXZlSm9pbklkcy5hcHBseShpbXAsIGFyZ3VtZW50cyk7IH07XG5SdW50aW1lLnByb3RvdHlwZS5zZXRBY3RpdmVTcGFuICAgID0gZnVuY3Rpb24oKSB7IFxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHJldHVybiBpbXAuc2V0QWN0aXZlU3Bhbi5jYWxsKGltcCwgYXJndW1lbnRzWzBdLCBudWxsLCBbXSwgYXJndW1lbnRzWzFdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaW1wLnNldEFjdGl2ZVNwYW4uYXBwbHkoaW1wLCBhcmd1bWVudHMpO1xuICAgIH1cbn07XG5cbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cbi8vIENvdW50ZXJzICYgR2F1Z2VzIFxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuXG4vLyBUQkRcblJ1bnRpbWUucHJvdG90eXBlLmNvdW50ZXIgICAgID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHt9O1xuUnVudGltZS5wcm90b3R5cGUuZ2F1Z2UgICAgICAgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge307XG5cbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cbi8vIEJ1ZmZlciBDb250cm9sXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXG5cblJ1bnRpbWUucHJvdG90eXBlLnBhdXNlICAgPSBmdW5jdGlvbigpICAgICAgICAgICAgeyB0aHJvdyBuZXcgRXJyb3IoXCJOT1RfWUVUX0lNUExFTUVOVEVEXCIpOyB9O1xuUnVudGltZS5wcm90b3R5cGUucmVzdW1lICA9IGZ1bmN0aW9uKCkgICAgICAgICAgICB7IHRocm93IG5ldyBFcnJvcihcIk5PVF9ZRVRfSU1QTEVNRU5URURcIik7IH07XG5SdW50aW1lLnByb3RvdHlwZS5mbHVzaCAgID0gZnVuY3Rpb24oc3luY2hyb25vdXMsIGRvbmUpIHtcbiAgICByZXR1cm4gaW1wLmZsdXNoQnVmZmVyKHN5bmNocm9ub3VzLCBkb25lKTtcbn07XG5SdW50aW1lLnByb3RvdHlwZS5kaXNjYXJkID0gZnVuY3Rpb24oKSAgICAgICAgICAgIHsgaW1wLmRpc2NhcmRCdWZmZXJzKCk7IH07XG5cbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cbi8vIFJlcG9ydGluZ1xuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuXG5SdW50aW1lLnByb3RvdHlwZS5zdGF0cyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wLnJlcG9ydEJ1ZmZlclN0YXRzKCk7IH07XG5cbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cbi8vIEV2ZW50RW1pdHRlci1zdHlsZSBsaXN0ZW5lcnNcbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cblxuUnVudGltZS5wcm90b3R5cGUub24gICAgICAgICAgICAgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpbXAub24uYXBwbHkoaW1wLCBhcmd1bWVudHMpOyB9O1xuUnVudGltZS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpbXAucmVtb3ZlTGlzdGVuZXIuYXBwbHkoaW1wLCBhcmd1bWVudHMpOyB9O1xuUnVudGltZS5wcm90b3R5cGUub25jZSAgICAgICAgICAgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpbXAub25jZS5hcHBseShpbXAsIGFyZ3VtZW50cyk7IH07XG5cbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cbi8vIEV4cG9ydHNcbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cblxuLy8gU2luZ2xldG9uXG52YXIgbGliID0gbmV3IFJ1bnRpbWUoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW1wbE9iamVjdCkge1xuICAgIGltcCA9IGltcGxPYmplY3Q7XG4gICAgaW1wLmFwaSA9IGxpYjtcblxuICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIGZpZWxkLiBUaGUgaW1wbGVtZW50YXRpb24gb2JqZWN0IHNob3VsZCAqbmV2ZXIqIG5lZWRcbiAgICAvLyB0byBiZSBhY2Nlc3NlZCBkaXJlY3RseS4gSXQncyBoZXJlIGZvciBkZXZlbG9wbWVudCB0byBhbGxvdyBpbnNwZWN0aW9uXG4gICAgLy8gb2YgdGhlIHZhbHVlcyBkdXJpbmcgZGVidWdnaW5nLlxuICAgIGxpYi5fX2ltcCA9IGltcDtcbiAgICBcbiAgICByZXR1cm4gbGliO1xufTtcbiIsInZhciBrTG9jYWxTdG9yZUtleSA9IFwiY2xvY2tfc3RhdGVcIjtcbi8vIEhvdyBtYW55IHVwZGF0ZXMgYmVmb3JlIGEgc2FtcGxlIGlzIGNvbnNpZGVyZWQgb2xkLiBUaGlzIGhhcHBlbnMgdG9cbi8vIGJlIG9uZSBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBzYW1wbGVzIGluIG91ciBidWZmZXIgYnV0IHRoYXQnc1xuLy8gc29tZXdoYXQgYXJiaXRyYXJ5LlxudmFyIGtNYXhPZmZzZXRBZ2UgPSA3O1xuXG5mdW5jdGlvbiBDbG9ja1N0YXRlKHBsYXRmb3JtLCBzdGF0ZSkge1xuICAgIHRoaXMucGxhdGZvcm0gPSBwbGF0Zm9ybTtcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgLy8gVGhlIGxhc3QgZWlnaHQgc2FtcGxlcywgY29tcHV0ZWQgZnJvbSB0aW1pbmcgaW5mb3JtYXRpb24gaW5cbiAgICAvLyBSUENzLlxuICAgIHRoaXMuc2FtcGxlcyA9IFtdO1xuICAgIHRoaXMuY3VycmVudE9mZnNldE1pY3JvcyA9IDA7XG4gICAgLy8gSG93IG1hbnkgdXBkYXRlcyBzaW5jZSB3ZSd2ZSB1cGRhdGVkIGN1cnJlbnRPZmZzZXRNaWNyb3MuXG4gICAgdGhpcy5jdXJyZW50T2Zmc2V0QWdlID0ga01heE9mZnNldEFnZSArIDE7XG5cbiAgICAvLyBUcnkgdG8gbG9hZCBzYW1wbGVzIGZyb20gdGhlIGxvY2FsIHN0b3JlLlxuICAgIHZhciBzdG9yZWREYXRhO1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLm9wdGlvbnMoKS5zZXJ2aWNlX2hvc3QpIHtcbiAgICAgICAgICAgIHN0b3JlZERhdGEgPSBKU09OLnBhcnNlKHBsYXRmb3JtLmxvY2FsU3RvcmUoXG4gICAgICAgICAgICAgICAga0xvY2FsU3RvcmVLZXkgKyBcIi9cIiArIHN0YXRlLm9wdGlvbnMoKS5zZXJ2aWNlX2hvc3QpKTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgLy8gT25seSB1c2UgdGhlIGRhdGEgaWYgaXQncyByZWNlbnQuXG4gICAgdmFyIGtTdG9yZWRTYW1wbGVzVFRMTWljcm9zID0gNjAgKiA2MCAqIDEwMDAgKiAxMDAwOyAvLyAxIGhvdXJcbiAgICBpZiAoc3RvcmVkRGF0YSAmJlxuICAgICAgICBzdG9yZWREYXRhLnRpbWVzdGFtcF9taWNyb3MgJiZcbiAgICAgICAgc3RvcmVkRGF0YS50aW1lc3RhbXBfbWljcm9zID4gcGxhdGZvcm0ubm93TWljcm9zKCkgLSBrU3RvcmVkU2FtcGxlc1RUTE1pY3Jvcykge1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlcmUgYXJlIG5vIG1vcmUgdGhhbiAoa01heE9mZnNldEFnZSsxKSBlbGVtZW50c1xuICAgICAgICB0aGlzLnNhbXBsZXMgPSBzdG9yZWREYXRhLnNhbXBsZXMuc2xpY2UoLShrTWF4T2Zmc2V0QWdlKzEpKTtcbiAgICB9XG4gICAgLy8gVXBkYXRlIHRoZSBjdXJyZW50IG9mZnNldCBiYXNlZCBvbiB0aGVzZSBkYXRhLlxuICAgIHRoaXMudXBkYXRlKCk7XG59XG5cbi8vIEFkZCBhIG5ldyB0aW1pbmcgc2FtcGxlIGFuZCB1cGRhdGUgdGhlIG9mZnNldC5cbkNsb2NrU3RhdGUucHJvdG90eXBlLmFkZFNhbXBsZSA9IGZ1bmN0aW9uKG9yaWdpbk1pY3JvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVNaWNyb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc21pdE1pY3JvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uTWljcm9zKSB7XG4gICAgdmFyIGxhdGVzdERlbGF5TWljcm9zID0gTnVtYmVyLk1BWF9OVU1CRVI7XG4gICAgdmFyIGxhdGVzdE9mZnNldE1pY3JvcyA9IDA7XG4gICAgLy8gRW5zdXJlIHRoYXQgYWxsIG9mIHRoZSBkYXRhIGFyZSB2YWxpZCBiZWZvcmUgdXNpbmcgdGhlbS4gSWZcbiAgICAvLyBub3QsIHdlJ2xsIHB1c2ggYSB7MCwgTUFYfSByZWNvcmQgaW50byB0aGUgcXVldWUuXG4gICAgaWYgKG9yaWdpbk1pY3JvcyA+IDAgJiYgcmVjZWl2ZU1pY3JvcyA+IDAgJiZcbiAgICAgICAgdHJhbnNtaXRNaWNyb3MgPiAwICYmIGRlc3RpbmF0aW9uTWljcm9zID4gMCkge1xuICAgICAgICBsYXRlc3REZWxheU1pY3JvcyA9IChkZXN0aW5hdGlvbk1pY3JvcyAtIG9yaWdpbk1pY3JvcykgLVxuICAgICAgICAgICAgKHRyYW5zbWl0TWljcm9zIC0gcmVjZWl2ZU1pY3Jvcyk7XG4gICAgICAgIGxhdGVzdE9mZnNldE1pY3JvcyA9ICgocmVjZWl2ZU1pY3JvcyAtIG9yaWdpbk1pY3JvcykgK1xuICAgICAgICAgICAgICAgICAgICAgICAodHJhbnNtaXRNaWNyb3MgLSBkZXN0aW5hdGlvbk1pY3JvcykpIC8gMjtcbiAgICB9XG5cbiAgICAvLyBEaXNjYXJkIHRoZSBvbGRlc3Qgc2FtcGxlIGFuZCBwdXNoIHRoZSBuZXcgb25lLlxuICAgIGlmICh0aGlzLnNhbXBsZXMubGVuZ3RoID09IGtNYXhPZmZzZXRBZ2UrMSkge1xuICAgICAgICB0aGlzLnNhbXBsZXMuc2hpZnQoKTtcbiAgICB9XG4gICAgdGhpcy5zYW1wbGVzLnB1c2goe1xuICAgICAgICBkZWxheU1pY3JvcyA6IGxhdGVzdERlbGF5TWljcm9zLFxuICAgICAgICBvZmZzZXRNaWNyb3MgOiBsYXRlc3RPZmZzZXRNaWNyb3MsXG4gICAgfSk7XG4gICAgdGhpcy5jdXJyZW50T2Zmc2V0QWdlKys7XG5cbiAgICAvLyBVcGRhdGUgdGhlIGxvY2FsIHN0b3JlIHdpdGggdGhpcyBuZXcgc2FtcGxlLlxuICAgIGlmICh0aGlzLnN0YXRlLm9wdGlvbnMoKS5zZXJ2aWNlX2hvc3QpIHtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybS5sb2NhbFN0b3JlKFxuICAgICAgICAgICAga0xvY2FsU3RvcmVLZXkgKyBcIi9cIiArIHRoaXMuc3RhdGUub3B0aW9ucygpLnNlcnZpY2VfaG9zdCxcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXBfbWljcm9zIDogdGhpcy5wbGF0Zm9ybS5ub3dNaWNyb3MoKSxcbiAgICAgICAgICAgICAgICBzYW1wbGVzIDogdGhpcy5zYW1wbGVzLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGUoKTtcbn07XG5cbi8vIFVwZGF0ZSB0aGUgdGltZSBvZmZzZXQgYmFzZWQgb24gdGhlIGN1cnJlbnQgc2FtcGxlcy5cbkNsb2NrU3RhdGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIFRoaXMgaXMgc2ltcGxpZmllZCB2ZXJzaW9uIG9mIHRoZSBjbG9jayBmaWx0ZXJpbmcgaW4gU2ltcGxlXG4gICAgLy8gTlRQLiBJdCBpZ25vcmVzIHByZWNpc2lvbiBhbmQgZGlzcGVyc2lvbiAoZnJlcXVlbmN5IGVycm9yKS4gSW5cbiAgICAvLyBicmllZiwgaXQga2VlcHMgdGhlIDggKGtNYXhPZmZzZXRBZ2UrMSkgbW9zdCByZWNlbnRcbiAgICAvLyBkZWxheS1vZmZzZXQgcGFpcnMsIGFuZCBjb25zaWRlcnMgdGhlIG9mZnNldCB3aXRoIHRoZSBzbWFsbGVzdFxuICAgIC8vIGRlbGF5IHRvIGJlIHRoZSBiZXN0IG9uZS4gSG93ZXZlciwgaXQgb25seSB1c2VzIHRoaXMgbmV3IG9mZnNldFxuICAgIC8vIGlmIHRoZSBjaGFuZ2UgKHJlbGF0aXZlIHRvIHRoZSBsYXN0IG9mZnNldCkgaXMgc21hbGwgY29tcGFyZWRcbiAgICAvLyB0byB0aGUgZXN0aW1hdGVkIGVycm9yLlxuICAgIC8vXG4gICAgLy8gU2VlOlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1OTA1I2FwcGVuZGl4LUEuNS4yXG4gICAgLy8gaHR0cDovL2Jvb2tzLmdvb2dsZS5jb20vYm9va3M/aWQ9cGRUY0pCZm5icThDXG4gICAgLy8gICBlc3AuIHNlY3Rpb24gMy41XG4gICAgLy8gaHR0cDovL3d3dy5lZWNpcy51ZGVsLmVkdS9+bWlsbHMvbnRwL2h0bWwvZmlsdGVyLmh0bWxcbiAgICAvLyBodHRwOi8vd3d3LmVlY2lzLnVkZWwuZWR1L35taWxscy9kYXRhYmFzZS9icmllZi9hbGdvci9hbGdvci5wZGZcbiAgICAvLyBodHRwOi8vd3d3LmVlY2lzLnVkZWwuZWR1L35taWxscy9udHAvaHRtbC9zdGF0cy5odG1sXG5cbiAgICAvLyBUT0RPOiBDb25zaWRlciBodWZmLW4nLXB1ZmYgaWYgd2UgdGhpbmsgdGhlIGRlbGF5cyBhcmUgaGlnaGx5XG4gICAgLy8gYXN5bW1ldHJpYy5cbiAgICAvLyBodHRwOi8vd3d3LmVlY2lzLnVkZWwuZWR1L35taWxscy9udHAvaHRtbC9odWZmcHVmZi5odG1sXG5cbiAgICAvLyBGaW5kIHRoZSBzYW1wbGUgd2l0aCB0aGUgc21hbGxlc3QgZGVsYXk7IHRoZSBjb3JyZXNwb25kaW5nXG4gICAgLy8gb2Zmc2V0IGlzIHRoZSBcImJlc3RcIiBvbmUuXG4gICAgdmFyIG1pbkRlbGF5TWljcm9zID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB2YXIgYmVzdE9mZnNldE1pY3JvcyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuc2FtcGxlc1tpXS5kZWxheU1pY3JvcyA8IG1pbkRlbGF5TWljcm9zKSB7XG4gICAgICAgICAgICBtaW5EZWxheU1pY3JvcyA9IHRoaXMuc2FtcGxlc1tpXS5kZWxheU1pY3JvcztcbiAgICAgICAgICAgIGJlc3RPZmZzZXRNaWNyb3MgPSB0aGlzLnNhbXBsZXNbaV0ub2Zmc2V0TWljcm9zO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm8gdXBkYXRlLlxuICAgIGlmIChiZXN0T2Zmc2V0TWljcm9zID09IHRoaXMuY3VycmVudE9mZnNldE1pY3Jvcykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTm93IGNvbXB1dGUgdGhlIGppdHRlciwgaS5lLiB0aGUgZXJyb3IgcmVsYXRpdmUgdG8gdGhlIG5ld1xuICAgIC8vIG9mZnNldCB3ZXJlIHdlIHRvIHVzZSBpdC5cbiAgICB2YXIgaml0dGVyID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGppdHRlciArPSBNYXRoLnBvdyhiZXN0T2Zmc2V0TWljcm9zIC0gdGhpcy5zYW1wbGVzW2ldLm9mZnNldE1pY3JvcywgMik7XG4gICAgfVxuICAgIGppdHRlciA9IE1hdGguc3FydChqaXR0ZXIgLyB0aGlzLnNhbXBsZXMubGVuZ3RoKTtcblxuICAgIC8vIElnbm9yZSBzcGlrZXM6IG9ubHkgdXNlIHRoZSBuZXcgb2Zmc2V0IGlmIHRoZSBjaGFuZ2UgaXMgbm90IHRvb1xuICAgIC8vIGxhcmdlLi4uIHVubGVzcyB0aGUgY3VycmVudCBvZmZzZXQgaXMgdG9vIG9sZC4gVGhlIFwidG9vIG9sZFwiXG4gICAgLy8gY29uZGl0aW9uIGlzIGFsc28gdHJpZ2dlcmVkIHdoZW4gdXBkYXRlKCkgaXMgY2FsbGVkIGZyb20gdGhlXG4gICAgLy8gY29uc3RydWN0b3IuXG4gICAgdmFyIGtTR0FURSA9IDM7IC8vIFNlZSBSRkMgNTkwNVxuICAgIGlmICh0aGlzLmN1cnJlbnRPZmZzZXRBZ2UgPiBrTWF4T2Zmc2V0QWdlIHx8XG4gICAgICAgIE1hdGguYWJzKHRoaXMuY3VycmVudE9mZnNldE1pY3JvcyAtIGJlc3RPZmZzZXRNaWNyb3MpIDwga1NHQVRFICogaml0dGVyKSB7XG4gICAgICAgIHRoaXMuY3VycmVudE9mZnNldE1pY3JvcyA9IGJlc3RPZmZzZXRNaWNyb3M7XG4gICAgICAgIHRoaXMuY3VycmVudE9mZnNldEFnZSA9IDA7XG4gICAgfVxufTtcblxuLy8gUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBpbiBtaWNyb3NlY29uZHMgYmV0d2VlbiB0aGUgc2VydmVyJ3MgY2xvY2tcbi8vIGFuZCBvdXIgY2xvY2suIFRoaXMgc2hvdWxkIGJlIGFkZGVkIHRvIGFueSBsb2NhbCB0aW1lc3RhbXBzIGJlZm9yZVxuLy8gc2VuZGluZyB0aGVtIHRvIHRoZSBzZXJ2ZXIuIE5vdGUgdGhhdCBhIG5lZ2F0aXZlIG9mZnNldCBtZWFucyB0aGF0XG4vLyB0aGUgbG9jYWwgY2xvY2sgaXMgYWhlYWQgb2YgdGhlIHNlcnZlcidzLlxuQ2xvY2tTdGF0ZS5wcm90b3R5cGUub2Zmc2V0TWljcm9zID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudE9mZnNldE1pY3JvcyB8IDA7XG59O1xuXG4vLyBSZXR1cm5zIHRydWUgaWYgd2UndmUgcGVyZm9ybWVkIGVub3VnaCBtZWFzdXJlbWVudHMgdG8gYmUgY29uZmlkZW50XG4vLyBpbiB0aGUgY3VycmVudCBvZmZzZXQuXG5DbG9ja1N0YXRlLnByb3RvdHlwZS5pc1JlYWR5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2FtcGxlcy5sZW5ndGggPiAzO1xufTtcblxuQ2xvY2tTdGF0ZS5wcm90b3R5cGUuYWN0aXZlU2FtcGxlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNhbXBsZXMubGVuZ3RoO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbG9ja1N0YXRlO1xuIiwiLy8gVGhlIGJ1aWxkIHByb2Nlc3Mgd2lsbCBvdmVycmlkZSB0aGlzIHRvIGZhbHNlIGluIG1pbmlmaWVkIGRpc3RyaWJ1dGlvbnNcbi8vIGFuZCBzdHJpcCBhbnkgZGVhZCBjb2RlIHRoYXQgcmVzdWx0cy5cbnZhciBERUJVRyA9IHRydWU7IFxuXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXG4vLyBNZW1vcnkgTWFuYWdlbWVudFxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuXG5mdW5jdGlvbiBPYmplY3RQb29sKG9wdHMpIHtcbiAgICB2YXIgcmVzZXJ2ZUNvdW50ID0gb3B0cy5yZXNlcnZlIHx8IDMyO1xuXG4gICAgdGhpcy5fY3RvciA9IG9wdHMuY29uc3RydWN0b3I7XG4gICAgdGhpcy5fcmVzZXQgPSBvcHRzLm9iamVjdF9yZXNldDtcbiAgICB0aGlzLl9wb3BfZnJvbnQgPSBvcHRzLnBvcF9mcm9udCB8fCBmYWxzZTtcblxuICAgIHRoaXMuYWxsb2NhdGlvbkNvdW50ID0gMDtcbiAgICB0aGlzLmFjcXVpcmVDb3VudCA9IDA7XG4gICAgdGhpcy5yZWxlYXNlQ291bnQgPSAwO1xuICAgIHRoaXMuZnJlZUxpc3QgPSBuZXcgQXJyYXkocmVzZXJ2ZUNvdW50KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzZXJ2ZUNvdW50OyBpKyspIHtcbiAgICAgICAgdGhpcy5mcmVlTGlzdFtpXSA9IHRoaXMubmV3T2JqZWN0KCk7XG4gICAgfVxufVxuXG5PYmplY3RQb29sLnByb3RvdHlwZS5uZXdPYmplY3QgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmFsbG9jYXRpb25Db3VudCsrO1xuICAgIHJldHVybiBuZXcgKHRoaXMuX2N0b3IpKCk7XG59O1xuXG5PYmplY3RQb29sLnByb3RvdHlwZS5hY3F1aXJlID0gZnVuY3Rpb24oYXJncykge1xuICAgIHRoaXMuYWNxdWlyZUNvdW50ICsrO1xuICAgIHZhciBvYmo7XG4gICAgaWYgKHRoaXMuZnJlZUxpc3QubGVuZ3RoKSB7XG4gICAgICAgIG9iaiA9IHRoaXMuZnJlZUxpc3QucG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqID0gdGhpcy5uZXdPYmplY3QoKTtcbiAgICB9XG4gICAgdGhpcy5fcmVzZXQob2JqLCBhcmdzKTtcbiAgICByZXR1cm4gb2JqO1xufTtcblxuT2JqZWN0UG9vbC5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT09IHVuZGVmaW5lZCB8fCBvYmogPT09IG51bGwpIHtcbiAgICAgICAgaWYgKERFQlVHKSB7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydChmYWxzZSwgXCJBdHRlbXB0IHRvIHJlbGVhc2UgYW4gaW52YWxpZCBvYmplY3QuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoREVCVUcpIHtcbiAgICAgICAgY29uc29sZS5hc3NlcnQodGhpcy5hY3F1aXJlQ291bnQgPj0gdGhpcy5yZWxlYXNlQ291bnQsIFwiSW1iYWxhbmNlIGluIGFjcXVpcmUvcmVsZWFzZSBjb3VudHMhXCIpO1xuICAgIH1cbiAgICB0aGlzLnJlbGVhc2VDb3VudCArKztcbiAgICB0aGlzLl9yZXNldChvYmopO1xuICAgIHRoaXMuZnJlZUxpc3QucHVzaChvYmopO1xufTtcblxuLy8gRWZmZWN0aXZlbHkgcmVpbml0aWFsaXplcyB0aGUgcG9vbCBieSByZXNldGluZyBjb3VudGVycyBhbmQgcmVzZXRpbmdcbi8vIHRoZSBmcmVlIGxpc3QuICBFeGlzdGluZyBvYmplY3RzLCBvZiBjb3Vyc2UsIHN0aWxsIGV4aXN0IGFuZCB3aWxsXG4vLyBiZSBHQydlZCBub3JtYWxseS5cbk9iamVjdFBvb2wucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5hbGxvY2F0aW9uQ291bnQgPSAwO1xuICAgIHRoaXMuYWNxdWlyZUNvdW50ID0gMDtcbiAgICB0aGlzLnJlbGVhc2VDb3VudCA9IDA7XG4gICAgdGhpcy5mcmVlTGlzdCA9IFtdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3RQb29sO1xuIiwiLy8gVGhlIGJ1aWxkIHByb2Nlc3Mgd2lsbCBvdmVycmlkZSB0aGlzIHRvIGZhbHNlIGluIG1pbmlmaWVkIGRpc3RyaWJ1dGlvbnNcbi8vIGFuZCBzdHJpcCBhbnkgZGVhZCBjb2RlIHRoYXQgcmVzdWx0cy5cbnZhciBERUJVRyA9IHRydWU7XG5cbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cbi8vIE1lbW9yeSBNYW5hZ2VtZW50XG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXG5cbnZhciBrU3BhbkhhbmRsZXNQb29sSW5pdGlhbFNpemUgPSAzMjtcblxudmFyIE9iamVjdFBvb2wgPSByZXF1aXJlKFwiLi9vYmplY3RfcG9vbC5qc1wiKTtcblxudmFyIHBvb2wgPSB7XG4gICAgc3BhbkhhbmRsZXMgOiBuZXcgT2JqZWN0UG9vbCh7XG4gICAgICAgIGNvbnN0cnVjdG9yICA6IFNwYW5IYW5kbGUsXG4gICAgICAgIGluaXRpYWxfc2l6ZSA6IGtTcGFuSGFuZGxlc1Bvb2xJbml0aWFsU2l6ZSxcbiAgICAgICAgb2JqZWN0X3Jlc2V0IDogZnVuY3Rpb24ob2JqLCBhcmdzKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWNvcmQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5faWQgPSAwO1xuICAgICAgICB9LFxuICAgIH0pLFxufTtcblxudmFyIGdJZENvdW50ZXIgPSAxOyAgICAgICAgIC8vIFN0YXJ0IGF0IDEgc28gMCBtZWFucyBub3QgYSB2YWxpZCwgYWN0aXZlIGhhbmRsZVxudmFyIGdBY3RpdmVTcGFuc0J5SWQgPSB7fTtcblxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuLy8gU3BhbkhhbmRsZVxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuLy9cbi8vIEEgaGFuZGxlIGV4cG9zaW5nIGFuIGFjdGl2ZSBzcGFuIHRvIHRoZSBjbGllbnQuXG4vL1xuLy8gVGVybWlub2xvZ3k6IHRoZSBcInNwYW4gcmVjb3JkXCIgaXMgdGhlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIGEgY29tcGxldGVkXG4vLyBzcGFuIGFuZCB0aGUgXCJzcGFuIGhhbmRsZVwiIGlzIHRoZSBpbnRlcmZhY2UgZm9yIGludGVyYWN0aW5nIHdpdGggYW4gYWN0aXZlXG4vLyBzcGFuLlxuLy9cbi8vIERldiBub3RlOiB0aGlzIGludGVyZmFjZSBzaG91bGQgbWlycm9yIHRoZSBjcnVudGltZSBBUEkgKHdoZXJlIGNvbW1vbiBzZW5zZVxuLy8gYXBwbGllcykuXG4vL1xuXG4vKipcbiAgICBJbnRlcmZhY2UgZm9yIG1hbmlwdWxhdGluZyBhbiBhY3RpdmUgc3BhbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIFNwYW5IYW5kbGUoc3RhdGUsIHJlY29yZCkge1xuICAgIC8vIERvbid0IGNhbGwgcmVsZWFzZSgpIG9uIF9yZWNvcmQgYXMgdGhpcyBpcyBub24tb3duaW5nIHJlZmVyZW5jZS5cbiAgICB0aGlzLl9yZWNvcmQgPSByZWNvcmQ7XG4gICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcblxuICAgIC8vIEludGVybmFsIGlkZW50aWZpZXI7IHVzZWZ1bCBmb3IgdHJhY2tpbmcgdW5jbG9zZWQgc3BhbnNcbiAgICB0aGlzLl9pZCA9IGdJZENvdW50ZXIrKztcbn1cblxuXG4vKipcbiAgICBAZ3JvdXAgUHJvcGVydGllc1xuICAgIEBzaWduYXR1cmUgZ3VpZCgpIC0+IHN0cmluZ1xuXG4gICAgKiBgcmV0dXJuYCBzdHJpbmcgLSB0aGUgZ2xvYmFsbHkgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBzcGFuIGluc3RhbmNlLlxuICovXG5TcGFuSGFuZGxlLnByb3RvdHlwZS5ndWlkID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9yZWNvcmQpIHtcbiAgICAgICAgbG9nVXNlckVycm9yKHRoaXMuX3N0YXRlLCBcIkludmFsaWQgc3BhbiBoYW5kbGVcIiwgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlY29yZC5zcGFuX2d1aWQ7XG4gICAgfVxufTtcblxuXG4vKipcbiAgICBAZ3JvdXAgUHJvcGVydGllc1xuICAgIEBzaWduYXR1cmUgdmFsaWQoKSAtPiBib29sXG5cbiAgICBSZXR1cm5zIHRydWUgaWYgdGhlIHNwYW4gaGFuZGxlIGlzIHZhbGlkOyBmYWxzZSBpZiBgZW5kKClgIGhhcyBhbHJlYWR5IGJlZW5cbiAgICBjYWxsZWQuXG5cbiAgICAqIGByZXR1cm5gIGJvb2wgLSBmYWxzZSBpZiB0aGUgc3BhbiBoYXMgYWxyZWFkeSBiZWVuIGVuZGVkXG4gKi9cblNwYW5IYW5kbGUucHJvdG90eXBlLnZhbGlkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fcmVjb3JkO1xufTtcblxuLyoqXG4gICAgQGdyb3VwIENvbmZpZ3VyYXRpb24gJiBDb250cm9sXG4gICAgQHNpZ25hdHVyZSBlbmQoKVxuXG4gICAgRW5kcyB0aGUgc3Bhbi4gIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBleGFjdGx5IG9uY2UgZm9yIGV2ZXJ5IGNyZWF0ZWQgc3BhblxuICAgIG9iamVjdC5cbiAqL1xuU3BhbkhhbmRsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9yZWNvcmQpIHtcbiAgICAgICAgbG9nVXNlckVycm9yKHRoaXMuX3N0YXRlLCBcIkludmFsaWQgc3BhbiBoYW5kbGVcIiwgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoREVCVUcpIHtcbiAgICAgICAgY29uc29sZS5hc3NlcnQodGhpcy5fcmVjb3JkLnNwYW5fZ3VpZCAhPT0gbnVsbCwgXCJTcGFuIHJlcXVpcmVzIGEgR1VJRFwiKTtcbiAgICAgICAgY29uc29sZS5hc3NlcnQodGhpcy5fcmVjb3JkLnlvdW5nZXN0X21pY3JvcyA9PT0gbnVsbCwgXCJzcGFuIGVuZCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9yZWNvcmQueW91bmdlc3RfbWljcm9zID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3JlY29yZC55b3VuZ2VzdF9taWNyb3MgPSB0aGlzLl9zdGF0ZS5ub3dNaWNyb3MoKTtcbiAgICAgICAgdGhpcy5fc3RhdGUucHVzaFNwYW5SZWNvcmQodGhpcy5fcmVjb3JkKTtcbiAgICAgICAgdGhpcy5fcmVjb3JkID0gbnVsbDtcbiAgICAgICAgZGVsZXRlIGdBY3RpdmVTcGFuc0J5SWRbdGhpcy5faWRdO1xuICAgICAgICBwb29sLnNwYW5IYW5kbGVzLnJlbGVhc2UodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbG9nVXNlckVycm9yKHRoaXMuX3N0YXRlLCBcIlNwYW4gY2xvc2VkIHR3aWNlXCIpO1xuICAgIH1cbn07XG5cblxuXG5TcGFuSGFuZGxlLnByb3RvdHlwZS5uYW1lID0gZnVuY3Rpb24obmV3TmFtZSkge1xuICAgIGlmICghdGhpcy5fcmVjb3JkKSB7XG4gICAgICAgIGxvZ1VzZXJFcnJvcih0aGlzLl9zdGF0ZSwgXCJJbnZhbGlkIHNwYW4gaGFuZGxlXCIsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobmV3TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBhY2Nlc3NvclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlY29yZC5zcGFuX25hbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBtdXRhdG9yXG4gICAgICAgICAgICB0aGlzLl9yZWNvcmQuc3Bhbl9uYW1lID0gbmV3TmFtZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICAgIEBncm91cCBDb25maWd1cmF0aW9uICYgQ29udHJvbFxuICAgIEBzaWduYXR1cmUgb3BlcmF0aW9uKCkgLT4gc3RyaW5nXG4gICAgQHNpZ25hdHVyZSBvcGVyYXRpb24obmFtZSlcblxuICAgIEFjY2Vzc29yIGFuZCBtdXRhdG9yIGZvciB0aGUgbmFtZSBvZiB0aGUgc3BhbiBvcGVyYXRpb24uXG5cbiAgICAqIGBuYW1lYCBzdHJpbmcgLSBuYW1lIG9mIHRoZSBvcGVyYXRpb25cbiAgICAqIGByZXR1cm5gIHN0cmluZyAtIGN1cnJlbnQgbmFtZSBvZiB0aGUgb3BlcmF0aW9uXG4gKi9cblNwYW5IYW5kbGUucHJvdG90eXBlLm9wZXJhdGlvbiA9IFNwYW5IYW5kbGUucHJvdG90eXBlLm5hbWU7XG5cblxuLyoqXG4gICAgQGdyb3VwIENvbmZpZ3VyYXRpb24gJiBDb250cm9sXG4gICAgQHNpZ25hdHVyZSBhdHRyaWJ1dGVzKCkgLT4gb2JqZWN0XG4gICAgQHNpZ25hdHVyZSBhdHRyaWJ1dGVzKGtleSwgdmFsdWUpIC0+IFNwYW5IYW5kbGVcbiAgICBAc2lnbmF0dXJlIGF0dHJpYnV0ZXMoYXR0cnMpIC0+IFNwYW5IYW5kbGVcblxuICAgIENhbGxlZCB3aXRoIG5vIGFyZ3VtZW50cywgcmV0dXJucyB0aGUgY3VycmVudCBzZXQgb2Ygc3BhbiBhdHRyaWJ1dGVzXG4gICAgYXMgYSBrZXktdmFsdWUgcGFpciBtYXAuXG5cbiAgICBDYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzLCBzZXRzIHRoZSBnaXZlbiBrZXkgdmFsdWUgcGFpci4gQW55IGV4aXN0aW5nXG4gICAga2V5LXZhbHVlIHdpdGggdGhhdCBrZXkgd2lsbCBiZSByZXBsYWNlZC5cblxuICAgIENhbGxlZCB3aXRoIGFuIG9iamVjdCwgdGhlIG9iamVjdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBzZXQgb2ZcbiAgICBrZXktdmFsdWUgcGFpcnMgdG8gbWVyZ2UgaW50byB0aGUgc3BhbiBhdHRyaWJ1dGVzLlxuXG4gICAgQWxsIHZhbHVlcyB3aWxsIGJlIGNvbnZlcnRlZCB0byBzdHJpbmdzIHdoZW4gc3RvcmVkIGFzIGFuIGF0dHJpYnV0ZS5cbiAqL1xuU3BhbkhhbmRsZS5wcm90b3R5cGUuYXR0cmlidXRlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhdHRycztcblxuICAgIC8vIEFjY2Vzc29yXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yZWNvcmQpIHtcbiAgICAgICAgICAgIGxvZ1VzZXJFcnJvcih0aGlzLl9zdGF0ZSwgXCJJbnZhbGlkIHNwYW4gaGFuZGxlXCIsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgYXR0cnMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9yZWNvcmQuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhaXIgPSB0aGlzLl9yZWNvcmQuYXR0cmlidXRlc1tpXTtcbiAgICAgICAgICAgIGF0dHJzW3BhaXIuS2V5XSA9IHBhaXIuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF0dHJzO1xuICAgIH1cblxuICAgIC8vIE11dGF0b3JcbiAgICBpZiAoIXRoaXMuX3JlY29yZCkge1xuICAgICAgICBsb2dVc2VyRXJyb3IodGhpcy5fc3RhdGUsIFwiSW52YWxpZCBzcGFuIGhhbmRsZVwiLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGF0dHJzID0gYXJndW1lbnRzWzBdO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICB2YXIga2V5VHlwZSA9IHR5cGVvZiBhcmd1bWVudHNbMF07XG4gICAgICAgIGlmIChrZXlUeXBlICE9PSBcIm51bWJlclwiICYmIGtleVR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGxvZ1VzZXJFcnJvcih0aGlzLl9zdGF0ZSwgXCJJbnZhbGlkIGFyZ3VtZW50c1wiLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgYXR0cnMgPSB7fTtcbiAgICAgICAgYXR0cnNbYXJndW1lbnRzWzBdXSA9IGFyZ3VtZW50c1sxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsb2dVc2VyRXJyb3IodGhpcy5fc3RhdGUsIFwiSW52YWxpZCBhcmd1bWVudHNcIiwgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYXR0cnMgIT09IFwib2JqZWN0XCIgfHwgIWF0dHJzKSB7XG4gICAgICAgIGxvZ1VzZXJFcnJvcih0aGlzLl9zdGF0ZSwgXCJJbnZhbGlkIGFyZ3VtZW50c1wiLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5fc3RhdGUubWVyZ2VBdHRyaWJ1dGVzSW50b1NwYW5SZWNvcmQodGhpcy5fcmVjb3JkLCBhdHRycyk7XG59O1xuXG4vLyBXcmFwIGEgZnVuY3Rpb24gYW5kIGVuZCB0aGUgc3BhbiBhcyBzb29uIGFzIHRoYXQgZnVuY3Rpb24gaXMgaW52b2tlZC5cbi8vIFVzZWZ1bCBmb3IgYXN5bmNocm9ub3VzIGRvbmUvY29tcGxldGUvbmV4dCBjYWxsYmFja3MuXG4vL1xuLy8gRXhhbXBsZTpcbi8vXG4vLyB2YXIgc3BhbiA9IGNyLnNwYW4oXCJyZWFkX215X2ZpbGVcIilcbi8vIGZzLnJlYWRGaWxlKFwibXlfZmlsZS50eHRcIiwgc3Bhbi5lbmRXcmFwKGZ1bmN0aW9uIChlcnIsIGJ1Zikge1xuLy8gICAgIC4uLlxuLy8gfSkpO1xuLy9cblNwYW5IYW5kbGUucHJvdG90eXBlLmVuZFdyYXAgPSBmdW5jdGlvbihmKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5lbmQoKTtcbiAgICAgICAgdmFyIHI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByID0gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBzZWxmLmV4Y2VwdGlvbihlKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbn07XG5cbi8qKlxuICAgIEBncm91cCBDb25maWd1cmF0aW9uICYgQ29udHJvbFxuICAgIEBzaWduYXR1cmUgam9pbklkcyAoKSAtPiBvYmplY3RcbiAgICBAc2lnbmF0dXJlIGpvaW5JZHMgKGpvaW5JZHMpXG5cbiAgICBBY2Nlc3NvciBhbmQgbXV0YXRvciBmb3IgdGhlIGpvaW4gSURzIHNldCBvbiB0aGUgc3BhbiBpbnN0YW5jZS5cbiAgICBXaGVuIG1vZGlmeWluZyB0aGUgZXhpc3Rpbmcgam9pbiBJRHMsIHRoZSBtZXRob2Qgd2lsbCAqbWVyZ2UqXG4gICAgYWRkaXRpb25hbCBqb2luIElEcyBpbnRvIHRoZSBleGlzdGluZyBzZXQgb2Ygam9pbiBJRHMuXG5cbiAgICBJZiBjYWxsZWQgd2l0aCBubyBhcmd1bWVudHMsIGl0IHJldHVybnMgdGhlIGN1cnJlbnQgc2V0IG9mIGpvaW4gSURzIGFzXG4gICAgYW4gb2JqZWN0LlxuXG4gICAgKiBgam9pbklkc2Agb2JqZWN0IC0gdGhlIHNldCBvZiBrZXktdmFsdWUgcGFpcnMgdG8gbWVyZ2UgaW50byB0aGUgZXhpc3RpbmdcbiAgICAgICAgam9pbiBJRHNcbiAgICAqIGByZXR1cm5gIG9iamVjdCAtIHRoZSBleGlzdGluZyBzZXQgb2Yga2V5LXZhbHVlIHBhaXJzIGZvciB0aGUgam9pbiBJRHNcbiAqL1xuU3BhbkhhbmRsZS5wcm90b3R5cGUuam9pbklkcyA9IGZ1bmN0aW9uIChqb2luSWRzKSB7XG4gICAgaWYgKCF0aGlzLl9yZWNvcmQpIHtcbiAgICAgICAgbG9nVXNlckVycm9yKHRoaXMuX3N0YXRlLCBcIkludmFsaWQgc3BhbiBoYW5kbGVcIiwgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIC8vIEFjY2Vzc29yXG4gICAgaWYgKGpvaW5JZHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgbWFwID0ge307XG4gICAgICAgIGpvaW5JZHMgPSB0aGlzLl9yZWNvcmQuam9pbl9pZHM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgam9pbklkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhaXIgPSBqb2luSWRzW2ldO1xuICAgICAgICAgICAgbWFwW3BhaXIuVHJhY2VLZXldID0gcGFpci5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH1cblxuICAgIC8vIE11dGF0b3JcbiAgICB0aGlzLl9zdGF0ZS5tZXJnZUpvaW5JZE1hcEludG9TcGFuUmVjb3JkKHRoaXMuX3JlY29yZCwgam9pbklkcyk7XG59O1xuXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXG4vLyBTcGFuc1xuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuXG4vKipcbiAgICBAZ3JvdXAgU3ViLXNwYW5zXG4gICAgQHNpZ25hdHVyZSBzcGFuKG9wZXJhdGlvbiwgam9pbklkcywgY2FsbHRocm91Z2gpIC0+IGFueVxuICAgIEBzaWduYXR1cmUgc3BhbihvcGVyYXRpb24sIGNhbGx0aHJvdWdoKSAtPiBhbnlcbiAgICBAc2lnbmF0dXJlIHNwYW4ob3BlcmF0aW9uLCBqb2luSWRzKSAtPiBTcGFuSGFuZGxlXG4gICAgQHNpZ25hdHVyZSBzcGFuKG9wZXJhdGlvbikgLT4gU3BhbkhhbmRsZVxuXG4gICAgQ3JlYXRlIGEgc3ViLXNwYW4uICBUaGUgbmV3bHkgY3JlYXRlZCBzcGFuIGluaGVyaXRzIHRoZSBqb2luIElEcyBvZiB0aGVcbiAgICBvdXRlciBzcGFuIG9iamVjdC5cblxuICAgIE5vdGU6IHRoZSBzcGFuIGRvZXMgKm5vdCogaW5oZXJpdCB0aGUgXCJhY3RpdmVcIiBqb2luIElEcyBhbmQgaW5zdGVhZCB0cnVzdHNcbiAgICB0aGF0IHRoZSBvdXRlciBzcGFuIG9iamVjdCBjcmVhdGluZyB0aGUgbmV3IHNwYW4gaGFzIHRoZSBpbnRlbmRlZCBqb2luIElEcy5cblxuICAgICogYG9wZXJhdGlvbmAgc3RyaW5nIC0gbmFtZSB0byBhc3NpZ24gdG8gdGhlIHNwYW4gb3BlcmF0aW9uXG4gICAgKiBgam9pbklkYCBvYmplY3QgLSBrZXktdmFsdWUgcGFpcnMgdG8gdXNlIG9uIHRoZSBzdWItc3BhblxuICAgICogYGNhbGx0aHJvdWdoYCBmdW5jdGlvbihzcGFuSGFuZGxlKSA6IGFueSAtIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlXG4gICAgY2FsbGVkIHdpdGggdGhlIG5ld2x5IGNyZWF0ZWQgc3BhbkhhbmRsZS4gIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhpc1xuICAgIGNhbGx0aHJvdWdoIHdpbGwgYmVjb21lIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIG91dGVyIGBzcGFuKClgIGNhbGwuXG4gICAgKiBgcmV0dXJuYCBbYW55fFNwYW5IYW5kbGVdIC0gaWYgYSBjYWxsdGhyb3VnaCBpcyBwcm92aWRlZCwgdGhlIHJldHVyblxuICAgIHZhbHVlIG9mIHNwYW4oKSB3aWxsIGJlIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGNhbGx0aHJvdWdoLiBPdGhlcndpc2UsIHRoZVxuICAgIHJldHVybiB2YWx1ZSBpcyB0aGUgaGFuZGxlIHRvIHRoZSBuZXdseSBjcmVhdGVkIHNwYW4uXG5cbiAgICA6OjptYXJrXG4gICAgVGhlIGBjYWxsdGhyb3VnaGAgY29uY2VwdCBpcyBjb25mdXNpbmcgYW5kIHRoZSB2YWx1ZSBpcyB1bmNsZWFyLiBJdCBkb2VzXG4gICAgaGF2ZSB2YWx1ZSAoaXQgc2V0cyB0aGUgc3BhbiBvYmplY3QgYXMgYWN0aXZlIGluIHRoZSBpbnRlcm5hbCBhY3RpdmVcbiAgICBzcGFuIHNldCwgd2hpY2ggYWxsb3dzIG90aGVyIGluc3RydW1lbnRlZCBjb2RlIHRvIFwiZmluZFwiIHRoZSBjdXJyZW50IHNwYW5cbiAgICB3aXRob3V0IGV4cGxpY2l0IGtub3dsZWRnZSBvZiB0aGUgY2FsbGVyKSBidXQgdGhpcyBpcyBkaWZmaWN1bHQgdG8gZXhwbGFpblxuICAgIHdpdGhvdXQgaW50cm9kdWNpbmcgbmV3LCBub24tdHJpdmlhbCBjb25jZXB0cy5cbiAgICA6OjpcbiovXG5TcGFuSGFuZGxlLnByb3RvdHlwZS5zcGFuID0gZnVuY3Rpb24gKG5hbWUsIGpvaW5JZEtleVZhbHVlcywgY2FsbHRocm91Z2gpIHtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHR5cGVvZiBqb2luSWRLZXlWYWx1ZXMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsdGhyb3VnaCA9IGpvaW5JZEtleVZhbHVlcztcbiAgICAgICAgam9pbklkS2V5VmFsdWVzID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgaW5uZXI7XG4gICAgdmFyIGhhbmRsZTtcbiAgICBpZiAoIXRoaXMuX3JlY29yZCkge1xuICAgICAgICAvLyBJZiB0aGlzIGlzIGFuIGludmFsaWQgaGFuZGxlLCBzdGlsbCBjcmVhdGUgYSBuZXcgaGFuZGxlIGV2ZW4gaWYgaXRcbiAgICAgICAgLy8gaXNuJ3QgYXNzb2NpYXRlZCB3aXRoIHRoZSBpbnZhbGlkIHBhcmVudC5cbiAgICAgICAgbG9nVXNlckVycm9yKHRoaXMuX3N0YXRlLCBcIkludmFsaWQgc3BhbiBoYW5kbGVcIiwgYXJndW1lbnRzKTtcbiAgICAgICAgaW5uZXIgPSB0aGlzLl9zdGF0ZS5yYXdTcGFuQmVnaW4obmFtZSwgam9pbklkS2V5VmFsdWVzKTtcbiAgICAgICAgaGFuZGxlID0gdGhpcy5fc3RhdGUuY3JlYXRlU3BhbkhhbmRsZShpbm5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGpvaW5JZHMgPSBtZXJnZVRyYWNlSWRzKHRoaXMuX3JlY29yZC5qb2luX2lkcywgam9pbklkS2V5VmFsdWVzKTtcbiAgICAgICAgaW5uZXIgPSB0aGlzLl9zdGF0ZS5yYXdTcGFuQmVnaW4obmFtZSwgam9pbklkcyk7XG4gICAgICAgIGhhbmRsZSA9IHRoaXMuX3N0YXRlLmNyZWF0ZVNwYW5IYW5kbGUoaW5uZXIpO1xuICAgICAgICBoYW5kbGUuYXR0cmlidXRlcyhcInBhcmVudF9zcGFuX2d1aWRcIiwgdGhpcy5fcmVjb3JkLnNwYW5fZ3VpZCk7XG4gICAgfVxuXG4gICAgaWYgKGNhbGx0aHJvdWdoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZS5zZXRBY3RpdmVTcGFuKGhhbmRsZSwgbnVsbCwgWyBoYW5kbGUgXSwgY2FsbHRocm91Z2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgfVxufTtcblxuU3BhbkhhbmRsZS5wcm90b3R5cGUuc3BhblNlY3Rpb24gPSBmdW5jdGlvbiAobmFtZSwgam9pbklkS2V5VmFsdWVzLCBmKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgZiA9IGpvaW5JZEtleVZhbHVlcztcbiAgICAgICAgam9pbklkS2V5VmFsdWVzID0ge307XG4gICAgfVxuICAgIHZhciBqb2luSWRzID0gbWVyZ2VUcmFjZUlkcyh0aGlzLl9yZWNvcmQuam9pbl9pZHMsIGpvaW5JZEtleVZhbHVlcyk7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlLnNwYW5TZWN0aW9uKG5hbWUsIGpvaW5JZHMsIGYpO1xufTtcblxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuLy8gY29uc29sZS1zdHlsZSBsb2dnaW5nXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXG5cbi8qKlxuICAgIEBncm91cCBMb2dnaW5nXG5cbiAgICBBZGRzIGEgbG9nIHN0YXRlbWVudCB0aGF0IGlzIGV4cGxpY2l0bHkgYXNzb2NpYXRlZCB3aXRoIHRoZVxuICAgIHNwYW4gaW5zdGFuY2UuXG4gKi9cblNwYW5IYW5kbGUucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5fcmVjb3JkKSB7XG4gICAgICAgIGxvZ1VzZXJFcnJvcih0aGlzLl9zdGF0ZSwgXCJJbnZhbGlkIHNwYW4gaGFuZGxlXCIsIGFyZ3VtZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc3RhdGUubG9nQXJndW1lbnRzSW5mbyhhcmd1bWVudHMsIHRoaXMuX3JlY29yZC5zcGFuX2d1aWQpO1xuICAgIH1cbn07XG5cbi8qKlxuICAgIEBncm91cCBMb2dnaW5nXG5cbiAgICBBZGRzIGEgbG9nIHN0YXRlbWVudCB0aGF0IGlzIGV4cGxpY2l0bHkgYXNzb2NpYXRlZCB3aXRoIHRoZVxuICAgIHNwYW4gaW5zdGFuY2UuXG4gKi9cblNwYW5IYW5kbGUucHJvdG90eXBlLmluZm8gPSBTcGFuSGFuZGxlLnByb3RvdHlwZS5sb2c7XG5cbi8qKlxuICAgIEBncm91cCBMb2dnaW5nXG5cbiAgICBBZGRzIGEgd2FybmluZyBsb2cgc3RhdGVtZW50IHRoYXQgaXMgZXhwbGljaXRseSBhc3NvY2lhdGVkIHdpdGggdGhlXG4gICAgc3BhbiBpbnN0YW5jZS5cbiAqL1xuU3BhbkhhbmRsZS5wcm90b3R5cGUud2FybiA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5fcmVjb3JkKSB7XG4gICAgICAgIGxvZ1VzZXJFcnJvcih0aGlzLl9zdGF0ZSwgXCJJbnZhbGlkIHNwYW4gaGFuZGxlXCIsIGFyZ3VtZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc3RhdGUubG9nQXJndW1lbnRzV2Fybihhcmd1bWVudHMsIHRoaXMuX3JlY29yZC5zcGFuX2d1aWQpO1xuICAgIH1cbn07XG5cbi8qKlxuICAgIEBncm91cCBMb2dnaW5nXG5cbiAgICBBZGRzIGEgZXJyb3IgbG9nIHN0YXRlbWVudCB0aGF0IGlzIGV4cGxpY2l0bHkgYXNzb2NpYXRlZCB3aXRoIHRoZVxuICAgIHNwYW4gaW5zdGFuY2UuXG4gKi9cblNwYW5IYW5kbGUucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9yZWNvcmQpIHtcbiAgICAgICAgbG9nVXNlckVycm9yKHRoaXMuX3N0YXRlLCBcIkludmFsaWQgc3BhbiBoYW5kbGVcIiwgYXJndW1lbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBEZW5vdGUgdGhlIHNwYW4gY29udGFpbnMgYW4gZXJyb3IuXG4gICAgICAgIHRoaXMuX3JlY29yZC5lcnJvcl9mbGFnID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc3RhdGUubG9nQXJndW1lbnRzRXJyb3IoYXJndW1lbnRzLCB0aGlzLl9yZWNvcmQuc3Bhbl9ndWlkKTtcbiAgICB9XG59O1xuXG4vKipcbiAgICBAZ3JvdXAgTG9nZ2luZ1xuXG4gICAgQWRkcyBhIGZhdGFsIGxvZyBzdGF0ZW1lbnQgdGhhdCBpcyBleHBsaWNpdGx5IGFzc29jaWF0ZWQgd2l0aCB0aGVcbiAgICBzcGFuIGluc3RhbmNlLlxuXG4gICAgTm90ZTogYGZhdGFsYCB3aWxsIGNhdXNlIHRoZSBwcm9jZXNzIHRvIGV4aXQgb24gYSBOb2RlLmpzLWxpa2UgcGxhdGZvcm0uXG4gICAgT24gdGhlIGJyb3dzZXIsIGl0IGlzIGVxdWl2YWxlbnQgYW4gZXJyb3IgYW5kIHByb2Nlc3NpbmcgaXMgbm90IGV4cGxpY2l0bHlcbiAgICBzdG9wcGVkLlxuICovXG5TcGFuSGFuZGxlLnByb3RvdHlwZS5mYXRhbCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiBmYXRhbCBpbnRlbnRpb25hbGx5IGRpZmZlcnMgZnJvbSBpbmZvL3dhcm4vZXJyb3JcbiAgICAvLyBvbiBhIGJhZCByZWNvcmQ6IHRha2UgdGhlIGZhdGFsIHNlcmlvdXNseSBhbmQgcGFzcyBpdCBvbiB0byB0aGUgc3RhdGVcbiAgICAvLyBvYmplY3QuXG4gICAgdmFyIGd1aWQ7XG4gICAgaWYgKHRoaXMuX3JlY29yZCkge1xuICAgICAgICB0aGlzLl9yZWNvcmQuZXJyb3JfZmxhZyA9IHRydWU7XG4gICAgICAgIGd1aWQgPSB0aGlzLl9yZWNvcmQuc3Bhbl9ndWlkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ1VzZXJFcnJvcih0aGlzLl9zdGF0ZSwgXCJJbnZhbGlkIHNwYW4gaGFuZGxlXCIsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHRoaXMuX3N0YXRlLmxvZ0FyZ3VtZW50c0ZhdGFsKGFyZ3VtZW50cywgZ3VpZCk7XG59O1xuXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXG4vLyBnbG9nLXN0eWxlIGxvZ2dpbmdcbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cblxuU3BhbkhhbmRsZS5wcm90b3R5cGUubG9nZiA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5fcmVjb3JkKSB7XG4gICAgICAgIGxvZ1VzZXJFcnJvcih0aGlzLl9zdGF0ZSwgXCJJbnZhbGlkIHNwYW4gaGFuZGxlXCIsIGFyZ3VtZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc3RhdGUubG9nRm9ybWF0dGVkSW5mbyhhcmd1bWVudHMsIHRoaXMuX3JlY29yZC5zcGFuX2d1aWQpO1xuICAgIH1cbn07XG5cblNwYW5IYW5kbGUucHJvdG90eXBlLmluZm9mID0gU3BhbkhhbmRsZS5wcm90b3R5cGUubG9nZjtcblxuU3BhbkhhbmRsZS5wcm90b3R5cGUud2FybmYgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX3JlY29yZCkge1xuICAgICAgICBsb2dVc2VyRXJyb3IodGhpcy5fc3RhdGUsIFwiSW52YWxpZCBzcGFuIGhhbmRsZVwiLCBhcmd1bWVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3N0YXRlLmxvZ0Zvcm1hdHRlZFdhcm4oYXJndW1lbnRzLCB0aGlzLl9yZWNvcmQuc3Bhbl9ndWlkKTtcbiAgICB9XG59O1xuXG5TcGFuSGFuZGxlLnByb3RvdHlwZS5lcnJvcmYgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX3JlY29yZCkge1xuICAgICAgICBsb2dVc2VyRXJyb3IodGhpcy5fc3RhdGUsIFwiSW52YWxpZCBzcGFuIGhhbmRsZVwiLCBhcmd1bWVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3JlY29yZC5lcnJvcl9mbGFnID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc3RhdGUubG9nRm9ybWF0dGVkRXJyb3IoYXJndW1lbnRzLCB0aGlzLl9yZWNvcmQuc3Bhbl9ndWlkKTtcbiAgICB9XG59O1xuXG5TcGFuSGFuZGxlLnByb3RvdHlwZS5mYXRhbGYgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBUaGUgaW1wbGVtZW50YXRpb24gb2YgZmF0YWwgaW50ZW50aW9uYWxseSBkaWZmZXJzIGZyb20gaW5mby93YXJuL2Vycm9yXG4gICAgLy8gb24gYSBiYWQgcmVjb3JkOiB0YWtlIHRoZSBmYXRhbCBzZXJpb3VzbHkgYW5kIHBhc3MgaXQgb24gdG8gdGhlIHN0YXRlXG4gICAgLy8gb2JqZWN0LlxuICAgIHZhciBndWlkO1xuICAgIGlmICh0aGlzLl9yZWNvcmQpIHtcbiAgICAgICAgZ3VpZCA9IHRoaXMuX3JlY29yZC5zcGFuX2d1aWQ7XG4gICAgICAgIHRoaXMuX3JlY29yZC5lcnJvcl9mbGFnID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsb2dVc2VyRXJyb3IodGhpcy5fc3RhdGUsIFwiSW52YWxpZCBzcGFuIGhhbmRsZVwiLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICB0aGlzLl9zdGF0ZS5sb2dGb3JtYXR0ZWRGYXRhbChhcmd1bWVudHMsIGd1aWQpO1xufTtcblxuU3BhbkhhbmRsZS5wcm90b3R5cGUuZXhjZXB0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgIHZhciBndWlkO1xuICAgIGlmICh0aGlzLl9yZWNvcmQpIHtcbiAgICAgICAgZ3VpZCA9IHRoaXMuX3JlY29yZC5zcGFuX2d1aWQ7XG4gICAgICAgIHRoaXMuZXJyb3JfZmxhZyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbG9nVXNlckVycm9yKHRoaXMuX3N0YXRlLCBcIkludmFsaWQgc3BhbiBoYW5kbGVcIiwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgdGhpcy5fc3RhdGUubG9nRXhjZXB0aW9uKGFyZ3VtZW50cywgZ3VpZCk7XG59O1xuXG5TcGFuSGFuZGxlLnByb3RvdHlwZS5sb2dSZWNvcmQgPSBmdW5jdGlvbihmaWVsZHMpIHtcbiAgICBpZiAodGhpcy5fcmVjb3JkKSB7XG4gICAgICAgIGZpZWxkcy5zcGFuX2d1aWQgPSB0aGlzLl9yZWNvcmQuc3Bhbl9ndWlkO1xuICAgICAgICBpZiAoZmllbGRzLmVycm9yX2ZsYWcgfHwgZmllbGRzLmxldmVsID09IFwiRVwiIHx8IGZpZWxkcy5sZXZlbCA9PSBcIkZcIikge1xuICAgICAgICAgICAgdGhpcy5fcmVjb3JkLmVycm9yX2ZsYWcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbG9nVXNlckVycm9yKHRoaXMuX3N0YXRlLCBcIkludmFsaWQgc3BhbiBoYW5kbGVcIiwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgdGhpcy5fc3RhdGUubG9nUmVjb3JkKGZpZWxkcyk7XG59O1xuXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXG4vLyBFdmVudHNcbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cblxuLy8gVmFsaWQgY2FsbCBzaWduYXR1cmVzOlxuLy9cbi8vIGV2ZW50KG5hbWUpXG4vLyBldmVudChuYW1lLCBtZXNzYWdlKVxuLy8gZXZlbnQobmFtZSwgcGF5bG9hZClcbi8vIGV2ZW50KG5hbWUsIG1lc3NhZ2UsIHBheWxvYWQpXG4vL1xuU3BhbkhhbmRsZS5wcm90b3R5cGUuZXZlbnQgPSBmdW5jdGlvbihuYW1lLCBtZXNzYWdlLCBwYXlsb2FkKSB7XG4gICAgaWYgKCF0aGlzLl9yZWNvcmQpIHtcbiAgICAgICAgbG9nVXNlckVycm9yKHRoaXMuX3N0YXRlLCBcIkludmFsaWQgc3BhbiBoYW5kbGVcIiwgYXJndW1lbnRzKTtcbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIFRoZSB0d28tYXJndW1lbnQgY2FsbCBzaWduYXR1cmUgaXMgdGhlIG9ubHkgY2FzZSB0aGF0IHJlcXVpcmVzXG4gICAgICAgIC8vIHBhcmFtZXRlciBzaHVmZmxpbmdcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIG1lc3NhZ2UgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHBheWxvYWQgPSBtZXNzYWdlO1xuICAgICAgICAgICAgbWVzc2FnZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGF0ZS5sb2dFdmVudFdpdGhHVUlEKG5hbWUsIG1lc3NhZ2UsIHBheWxvYWQsIHRoaXMuX3JlY29yZC5zcGFuX2d1aWQpO1xuICAgIH1cbn07XG5cbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cbi8vIEhlbHBlcnNcbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cblxuLy8gRm9yIHVzZXItY2F1c2VkIGludGVybmFsIGVycm9ycy5cbmZ1bmN0aW9uIGxvZ1VzZXJFcnJvciAoc3RhdGUsIHRleHQsIGFyZ3MpIHtcbiAgICBzdGF0ZS5yYXdMb2dSZWNvcmQoe1xuICAgICAgICBsZXZlbCAgICAgICA6IFwiRVwiLFxuICAgICAgICBlcnJvcl9mbGFnICA6IHRydWUsXG4gICAgICAgIGZpbGVuYW1lICAgIDogXCI8c3Bhbl9oYW5kbGU+XCIsXG4gICAgICAgIG1lc3NhZ2UgICAgIDogdGV4dCxcbiAgICAgICAgc3RhY2tfZnJhbWVzOiBzdGF0ZS5zdGFja1RyYWNlKCksXG4gICAgICAgIHBheWxvYWQgICAgIDoge1xuICAgICAgICAgICAgYXJndW1lbnRzIDogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyksXG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5cbi8vIE1lcmdlcyB0aGUgcGFyZW50IGFycmF5IHJlcHJlc2VudGF0aW9uIHdpdGggYSBtYXAgYW5kIHJldHVybnMgYSBtYXAuXG4vLyBwYXJlbnRBcnJheSBzaG91bGQgYW4gYXJyYXk7IHRvTWVyZ2Ugc2hvdWxkIGJlIGEgbWFwIG9yIG1heSBiZSB1bmRlZmluZWQuXG4vL1xuLy8gVE9ETzogZml4IHRoaXMgZGF0YSBzdHJ1Y3R1cmUgcGluZy1wb25nIVxuIGZ1bmN0aW9uIG1lcmdlVHJhY2VJZHMgKHBhcmVudEFycmF5LCB0b01lcmdlKSB7XG4gICAgdmFyIG1hcCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50QXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhaXIgPSBwYXJlbnRBcnJheVtpXTtcbiAgICAgICAgbWFwW3BhaXIuVHJhY2VLZXldID0gcGFpci5WYWx1ZTtcbiAgICB9XG4gICAgaWYgKHRvTWVyZ2UpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRvTWVyZ2UpIHtcbiAgICAgICAgICAgIG1hcFtrZXldID0gdG9NZXJnZVtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXA7XG59XG5cblxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuLy8gTm9PcEhhbmRsZVxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuLy8gUmV0dXJuZWQgd2hlbiB0aGUgY3J1bnRpbWUgaXMgZGlzYWJsZWRcblxuZnVuY3Rpb24gTm9PcEhhbmRsZSgpIHtcbiAgICAvLyBNVVNUIGhhdmUgbm8gc3RhdGUgYXMgdGhlIG9iamVjdCBpcyBlZmZlY3RpdmVseSB1c2VkIGFzIGFcbiAgICAvLyBzaW5nbGV0b24uXG59XG5cbi8vIENyZWF0ZSB0cnVlIG5vLW9wIGZ1bmN0aW9ucyBhcyBhIGRlZmF1bHQsIHRoZW4gb3ZlcnJpZGUgdGhlIG1ldGhvZHNcbi8vIHRoYXQgbmVlZCB0byBkbyBzb21ldGhpbmcgYmV5b25kIHRyYWNlIGZ1bmN0aW9uYWxpdHkuXG5mb3IgKHZhciBrZXkgaW4gU3BhbkhhbmRsZS5wcm90b3R5cGUpIHtcbiAgICBOb09wSGFuZGxlLnByb3RvdHlwZVtrZXldID0gZnVuY3Rpb24oKSB7fTtcbn1cblxuTm9PcEhhbmRsZS5wcm90b3R5cGUuZW5kV3JhcCA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gZjtcbn07XG5cbk5vT3BIYW5kbGUucHJvdG90eXBlLnNwYW4gPSBmdW5jdGlvbiAobmFtZSwgam9pbklkS2V5VmFsdWVzLCBmKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIGpvaW5JZEtleVZhbHVlcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGYgPSBqb2luSWRLZXlWYWx1ZXM7XG4gICAgICAgIGpvaW5JZEtleVZhbHVlcyA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGYpIHtcbiAgICAgICAgcmV0dXJuIGYodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuTm9PcEhhbmRsZS5wcm90b3R5cGUuc3BhblNlY3Rpb24gPSBmdW5jdGlvbiAobmFtZSwgam9pbklkS2V5VmFsdWVzLCBmKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgZiA9IGpvaW5JZEtleVZhbHVlcztcbiAgICB9XG4gICAgcmV0dXJuIGYoKTtcbn07XG5cbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cbi8vIEV4cG9ydHNcbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cblxudmFyIGxpYiA9IHt9O1xuXG5saWIuYWNxdWlyZSA9IGZ1bmN0aW9uKHN0YXRlLCByZWNvcmQpIHtcbiAgICB2YXIgb2JqID0gcG9vbC5zcGFuSGFuZGxlcy5hY3F1aXJlKCk7XG4gICAgU3BhbkhhbmRsZS5jYWxsKG9iaiwgc3RhdGUsIHJlY29yZCk7XG4gICAgZ0FjdGl2ZVNwYW5zQnlJZFtvYmouX2lkXSA9IG9iajtcbiAgICByZXR1cm4gb2JqO1xufTtcblxubGliLmFjdGl2ZVNwYW5IYW5kbGVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFjdGl2ZSA9IFtdO1xuICAgIGZvciAodmFyIGlkIGluIGdBY3RpdmVTcGFuc0J5SWQpIHtcbiAgICAgICAgYWN0aXZlLnB1c2goZ0FjdGl2ZVNwYW5zQnlJZFtpZF0pO1xuICAgIH1cbiAgICByZXR1cm4gYWN0aXZlO1xufTtcblxubGliLmlzU3BhbkhhbmRsZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiAob2JqIGluc3RhbmNlb2YgU3BhbkhhbmRsZSk7XG59O1xuXG52YXIgZ05vT3BIYW5kbGUgPSBuZXcgTm9PcEhhbmRsZSgpO1xubGliLmdldE5vT3BIYW5kbGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZ05vT3BIYW5kbGU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxpYjtcbiIsIi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cbi8vIERlcGVuZGVuY2llcyAmIENvbnN0c1xuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuXG52YXIgT2JqZWN0UG9vbCAgICAgICA9IHJlcXVpcmUoXCIuL29iamVjdF9wb29sLmpzXCIpLFxuICAgIHNwYW5faGFuZGxlICAgICAgPSByZXF1aXJlKFwiLi9zcGFuX2hhbmRsZS5qc1wiKSxcbiAgICBDbG9ja1N0YXRlICAgICAgID0gcmVxdWlyZShcIi4vY2xvY2tfc3RhdGUuanNcIiksXG4gICAgVGltZXN0YW1wU2FtcGxlcyA9IHJlcXVpcmUoXCIuL3RpbWVzdGFtcF9zYW1wbGVzLmpzXCIpLFxuICAgIG1ha2VJbnNwZWN0YWJsZSAgPSByZXF1aXJlKFwibm9kZS9wYWNrYWdlcy9ybC1pbnNwZWN0YWJsZS1vYmplY3RcIiksXG4gICAgc2NydWJiZXIgICAgICAgICA9IHJlcXVpcmUoXCJub2RlL3BhY2thZ2VzL3JsLXNjcnViYmVyXCIpLFxuICAgIEV2ZW50RW1pdHRlck1pbiAgPSByZXF1aXJlKFwibm9kZS9wYWNrYWdlcy9ybC1ldmVudGVtaXR0ZXJcIik7XG5cbi8vIFRoZSBidWlsZCBwcm9jZXNzIHdpbGwgb3ZlcnJpZGUgdGhpcyB0byBmYWxzZSBpbiBtaW5pZmllZCBkaXN0cmlidXRpb25zXG4vLyBhbmQgc3RyaXAgYW55IGRlYWQgY29kZSB0aGF0IHJlc3VsdHMuXG52YXIgREVCVUcgPSB0cnVlO1xuXG52YXIga0xvZ1JlY29yZHNQb29sSW5pdGlhbFNpemUgID0gMTI4O1xudmFyIGtTcGFuUmVjb3Jkc1Bvb2xJbml0aWFsU2l6ZSA9IDMyO1xudmFyIGtUcmFjZUpvaW5JZFBvb2xJbml0aWFsU2l6ZSA9IDY0O1xudmFyIGtLZXlWYWx1ZVBvb2xJbml0aWFsU2l6ZSAgICA9IDY0O1xuXG52YXIga01heExvZ1JlY29yZHNEZWZhdWx0ICAgICAgICAgID0gMTAyNDtcbnZhciBrTWF4U3BhblJlY29yZHNEZWZhdWx0ICAgICAgICAgPSAxMDI0O1xudmFyIGtSZWZyZXNoSW50ZXJ2YWxNc0RlZmF1bHQgICAgICA9IDI1MDA7XG52YXIga0Nsb2NrU2FtcGxpbmdJbnRlcnZhbE1zICAgICAgID0gMzUwO1xuXG4vLyBUaGlzIHNob3VsZCBiZSAqcmFyZSogb3IgbmV2ZXIgb2NjdXIsIHNvIGEgbGFyZ2UgbnVtYmVyIGhlcmUgbWFrZXNcbi8vIHNvbWUgc2Vuc2UuIFdoaWxlIHRoaXMgY29tbWVudCB3aWxsIHN1cmVseSBmYWxsIG91dCBvZiBkYXRlLFxuLy8gY3VycmVudGx5IDMyIGltcGxpZXMgZGlzY2FyZCBvbmNlIGV2ZXJ5IDEuNSBob3VycyBnaXZlbiB0aGUgYmFja29mZlxuLy8gYW5kIGRlZmF1bHQgcmVmcmVzaCBpbnRlcnZhbC5cbnZhciBrRGlzY2FyZERhdGFFdmVyeU50aEZsdXNoRXJyb3IgPSAzMjtcblxuLy8gQW5vdGhlciBwcmVjYXV0aW9uIGFnYWluc3QgYSBub3Qgd2VsbC1kZWZpbmVkIGNhc2U6IHJlY3JlYXRlIHRoZSB0aHJpZnRcbi8vIGNsaWVudCBvYmplY3RzIGFmdGVyIE4gZXJyb3JzLCBhc3N1bWluZyBzb21laG93IGl0cyBpbnRlcm5hbCBzdGF0ZSBpc1xuLy8gYmxvY2tpbmcgc3VjY2Vzc2Z1bCBmbHVzaGVzLiAgVGhlIHVucmVsaWFibGUsIHVucHJlZGljdGFibGUgZXJyb3IgaGFuZGxpbmdcbi8vIG9mIFRocmlmdCBoYXMgZ2l2ZW4gcmlzZSB0byB0aGlzIHByZWNhdXRpb24uICBOb3RlOiByZWNyZWF0aW5nIHRoZSBjbGllbnRcbi8vIGFwcGVhcnMgdG8gXCJzYWZlXCIgYnV0IHdhc3RlZnVsIG9wZXJhdGlvbiBpbiB0aGUgMC45LjIgVGhyaWZ0IEpTIGxpYnJhcnkuXG52YXIga1Jlc2V0Q29ubmVjdGlvbkV2ZXJ5TnRoRmx1c2hFcnJvciA9IDEwO1xuXG4vLyBSdWxlcyB0aGF0IGFyZSBhbHdheXMgYWN0aXZlIGluIHRoZSBzY3J1YmJlciAtLSBpbnRlbmRlZCBmb3IgcmVtb3Zpbmdcbi8vIHRyYWNlZ3VpZGUgaW50ZXJuYWwgaW5mb3JtYXRpb24uXG52YXIga0Jhc2VsaW5lU2NydWJiZXJSdWxlcyA9IFtcbiAgICB7XG4gICAgICAgIG1hdGNoICAgICAgICA6IFsgXCJrZXlzXCIsIFwidXJsX3F1ZXJ5X3N0cmluZ1wiIF0sXG4gICAgICAgIG9wICAgICAgICAgICA6IFwicmVtb3ZlXCIsXG4gICAgICAgIGtleV9wcmVmaXhlcyA6IFsgXCJ0cmFjZWd1aWRlX1wiIF0sXG4gICAgfVxuXTtcblxuLy8gSW50ZW5kZWQgYXMgYSByZWFzb25hYmxlIHNldCBvZiBkZWZhdWx0cyBmb3Igc2NydWJiaW5nIGN1c3RvbWVyIGRhdGEuXG52YXIga0RlZmF1bHRTY3J1YmJlcnNSdWxlcyA9IFtcbiAgICB7XG4gICAgICAgIG1hdGNoICAgICAgIDogXCJrZXlzXCIsXG4gICAgICAgIG9wICAgICAgICAgIDogXCJyZW1vdmVcIixcbiAgICAgICAga2V5cyAgICAgICAgOiBbIFwicGFzc3dvcmRcIiwgXCJhcGlfa2V5XCIgXSxcbiAgICB9LFxuXTtcblxuLy8gUmV0dXJuZWQgaW4gY2FzZXMgd2hlbiB0aGUgY2xvY2sgc3RhdGUgaXMgbm90IHJlYWR5IChhbmQgdGhlXG4vLyByZXF1ZXN0IHNob3VsZCBiZSByZXRyaWVkKS5cbnZhciBrQ2xvY2tTdGF0ZU5vdFJlYWR5RXJyb3IgPSBuZXcgRXJyb3IoXCJjbG9jayBzdGF0ZSBub3QgcmVhZHlcIik7XG5cbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cbi8vIEdsb2JhbHNcbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cbi8vIFVzZSBnbG9iYWxzIG1vc3RseSBmb3IgY29kaW5nIGNvbnZlbmllbmNlLiAgTm8gcnVudGltZSBpcyAoY3VycmVudGx5KVxuLy8gZXhwZWN0ZWQgdG8gaGF2ZSBtdWx0aXBsZSBTdGF0ZSBvYmplY3RzOyB0aGlzIG1heSBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cblxuLy8gU3RhdGUgb2JqZWN0XG52YXIgc2luZ2xldG9uICAgICAgID0gbnVsbDtcblxuLy8gVGhyaWZ0XG52YXIgY3JvdXRvbl90aHJpZnQgID0gbnVsbDtcbnZhciBUaHJpZnQgICAgICAgICAgPSBudWxsO1xuXG4vLyBNZW1vcnkgbWFuYWdlbWVudFxudmFyIHBvb2wgPSB7XG4gICAgbG9nUmVjb3JkcyAgICAgIDogbnVsbCxcbiAgICBzcGFuUmVjb3JkcyAgICAgOiBudWxsLFxuICAgIHRyYWNlSm9pbklkcyAgICA6IG51bGwsXG59O1xuXG4vLyBQbGF0Zm9ybSBhYnN0cmFjdGlvbiBsYXllclxudmFyIHBsYXRmb3JtICAgICAgICA9IG51bGw7XG5cbi8vIFNhdmVkIGdsb2JhbCBzdGF0ZSBpbiBjYXNlIHdlJ3JlIGFza2VkIHRvIG92ZXJyaWRlIGl0XG52YXIgb3JpZ2luYWxDb25zb2xlID0gY29uc29sZTtcbnZhciBvcmlnaW5hbENvbnNvbGVfbG9nID0gb3JpZ2luYWxDb25zb2xlLmxvZztcbnZhciBvcmlnaW5hbENvbnNvbGVfd2FybiA9IG9yaWdpbmFsQ29uc29sZS53YXJuO1xudmFyIG9yaWdpbmFsQ29uc29sZV9lcnJvciA9IG9yaWdpbmFsQ29uc29sZS5lcnJvcjtcblxuLy8gRW5zdXJlIGEgY29uZGl0aW9uYWwgb2NjdXJzIG5vdCBtb3JlIHRoYW4gb25jZVxuX29uY2VNYXAgPSB7fTtcbmZ1bmN0aW9uIF9vbmNlKGtleSkge1xuICAgIHZhciBhbHJlYWR5U2V0ID0gISFfb25jZU1hcFtrZXldO1xuICAgIF9vbmNlTWFwW2tleV0gPSB0cnVlO1xuICAgIHJldHVybiAhYWxyZWFkeVNldDtcbn1cblxuZnVuY3Rpb24gX2xvZygpICAgeyByZXR1cm4gb3JpZ2luYWxDb25zb2xlX2xvZy5hcHBseShvcmlnaW5hbENvbnNvbGUsIGFyZ3VtZW50cyk7IH1cbmZ1bmN0aW9uIF93YXJuKCkgIHsgcmV0dXJuIG9yaWdpbmFsQ29uc29sZV93YXJuLmFwcGx5KG9yaWdpbmFsQ29uc29sZSwgYXJndW1lbnRzKTsgfVxuZnVuY3Rpb24gX2Vycm9yKCkgeyByZXR1cm4gb3JpZ2luYWxDb25zb2xlX2Vycm9yLmFwcGx5KG9yaWdpbmFsQ29uc29sZSwgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBpbml0aWFsaXplR2xvYmFscyhzdGF0ZSwgY3JvdXRvbl90aHJpZnRfLCBUaHJpZnRfLCBwbGF0Zm9ybV8pIHtcbiAgICAvL1xuICAgIC8vIFNpbmdsZXRvbi4uLlxuICAgIC8vXG4gICAgLy8gVGhpcyBpcyBtb3N0bHkgZm9yIGNvZGluZyBjb252ZW5pZW5jZS4gSW4gdGhlb3J5LCB3ZSBtYXkgd2FudCB0b1xuICAgIC8vIHRvIGhhdmUgbGVzcyBnbG9iYWwgc3RhdGUgd2hlbiBwcm94eWluZyBkaWZmZXJlbnQgc2VydmljZXMgc28gdGhhdFxuICAgIC8vIHRoZSBydW50aW1lIGF0dHJpYnV0ZXMsIGJ1ZmZlcmluZyBzdHJhdGVnaWVzLCBldGMuIGNhbiB2YXJ5IGJldHdlZW5cbiAgICAvLyB0aG9zZSBkYXRhIHNvdXJjZXMuXG4gICAgLy9cbiAgICBpZiAoc2luZ2xldG9uICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YXRlIGlzIGludGVuZGVkIHRvIGJlIGEgc2luZ2xldG9uLlwiKTtcbiAgICB9XG4gICAgc2luZ2xldG9uID0gc3RhdGU7XG5cbiAgICAvL1xuICAgIC8vIFBsYXRmb3JtLi4uXG4gICAgLy9cbiAgICBwbGF0Zm9ybSA9IHBsYXRmb3JtXztcblxuICAgIC8vXG4gICAgLy8gVGhyaWZ0Li4uXG4gICAgLy9cbiAgICBjcm91dG9uX3RocmlmdCA9IGNyb3V0b25fdGhyaWZ0XztcbiAgICBUaHJpZnQgICAgICAgICA9IFRocmlmdF87XG5cbiAgICAvL1xuICAgIC8vIE1lbW9yeSBQb29scy4uLlxuICAgIC8vXG4gICAgLy8gVGhlc2UgcmVseSBvbiB0aGUgdGhyaWZ0IGltcGxlbWVudGF0aW9uIHRvIGNsZWFyIG91dCBhbGwgdGhlIGZpZWxkcy5cbiAgICAvLyBTZWVtcyBhIGJpdCBmcmFnaWxlLCBidXQgbWFudWFsbHkgbGlzdGluZyBvdXQgdGhlIGZpZWxkcyBhbmQgY2xlYXJpbmdcbiAgICAvLyB0aGVtIGlzIGFsc28gZnJhZ2lsZSBpZiBuZXcgZmllbGRzIGFyZSBhZGRlZC5cbiAgICBwb29sLmxvZ1JlY29yZHMgPSBuZXcgT2JqZWN0UG9vbCh7XG4gICAgICAgIGNvbnN0cnVjdG9yICA6IGNyb3V0b25fdGhyaWZ0LkxvZ1JlY29yZCxcbiAgICAgICAgaW5pdGlhbF9zaXplIDoga0xvZ1JlY29yZHNQb29sSW5pdGlhbFNpemUsXG4gICAgICAgIG9iamVjdF9yZXNldCA6IGZ1bmN0aW9uKG9iaiwgYXJncykgeyBjcm91dG9uX3RocmlmdC5Mb2dSZWNvcmQuY2FsbChvYmosIGFyZ3MpOyB9LFxuICAgIH0pO1xuICAgIHBvb2wuc3BhblJlY29yZHMgPSBuZXcgT2JqZWN0UG9vbCh7XG4gICAgICAgIGNvbnN0cnVjdG9yICA6IGNyb3V0b25fdGhyaWZ0LlNwYW5SZWNvcmQsXG4gICAgICAgIGluaXRpYWxfc2l6ZSA6IGtTcGFuUmVjb3Jkc1Bvb2xJbml0aWFsU2l6ZSxcbiAgICAgICAgb2JqZWN0X3Jlc2V0IDogZnVuY3Rpb24ob2JqLCBhcmdzKSB7IGNyb3V0b25fdGhyaWZ0LlNwYW5SZWNvcmQuY2FsbChvYmosIGFyZ3MpOyB9LFxuICAgIH0pO1xuICAgIHBvb2wudHJhY2VKb2luSWRzID0gbmV3IE9iamVjdFBvb2woe1xuICAgICAgICBjb25zdHJ1Y3RvciAgOiBjcm91dG9uX3RocmlmdC5UcmFjZUpvaW5JZCxcbiAgICAgICAgaW5pdGlhbF9zaXplIDoga1RyYWNlSm9pbklkUG9vbEluaXRpYWxTaXplLFxuICAgICAgICBvYmplY3RfcmVzZXQgOiBmdW5jdGlvbihvYmosIGFyZ3MpIHsgY3JvdXRvbl90aHJpZnQuVHJhY2VKb2luSWQuY2FsbChvYmosIGFyZ3MpOyB9LFxuICAgIH0pO1xuICAgIHBvb2wua2V5VmFsdWUgPSBuZXcgT2JqZWN0UG9vbCh7XG4gICAgICAgIGNvbnN0cnVjdG9yICA6IGNyb3V0b25fdGhyaWZ0LktleVZhbHVlLFxuICAgICAgICBpbml0aWFsX3NpemUgOiBrS2V5VmFsdWVQb29sSW5pdGlhbFNpemUsXG4gICAgICAgIG9iamVjdF9yZXNldCA6IGZ1bmN0aW9uKG9iaiwgYXJncykgeyBjcm91dG9uX3RocmlmdC5LZXlWYWx1ZS5jYWxsKG9iaiwgYXJncyk7IH0sXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2VTcGFuUmVjb3JkIChzcGFuKSB7XG4gICAgaWYgKERFQlVHKSB7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHNwYW4uc3Bhbl9ndWlkICE9PSBudWxsLCBcIkludmFsaWQgc3BhbiBiZWluZyByZWxlYXNlZC5cIik7XG4gICAgfVxuICAgIGlmIChzcGFuLmpvaW5faWRzKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3Bhbi5qb2luX2lkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgcG9vbC50cmFjZUpvaW5JZHMucmVsZWFzZShzcGFuLmpvaW5faWRzW2pdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3Bhbi5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgc3Bhbi5hdHRyaWJ1dGVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBwb29sLmtleVZhbHVlLnJlbGVhc2Uoc3Bhbi5hdHRyaWJ1dGVzW2tdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwb29sLnNwYW5SZWNvcmRzLnJlbGVhc2Uoc3Bhbik7XG59XG5cbi8vIEJhbGFuY2UgdGhlIGFjcXVpcmUoKSdlZCBvYmplY3RzIHdpdGggcmVsZWFzZSgpIGNhbGxzLlxuZnVuY3Rpb24gcmVsZWFzZUFycmF5cyAobG9ncywgc3BhbnMpIHtcbiAgICAvLyBSZWxlYXNlIGxvZyByZWNvcmQgb2JqZWN0c1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwb29sLmxvZ1JlY29yZHMucmVsZWFzZShsb2dzW2ldKTtcbiAgICB9XG4gICAgLy8gUmVsZWFzZSBzcGFuIHJlY29yZCBvYmplY3QgYW5kIGFueSBjb250YWluZWQgam9pbiBpZHNcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVsZWFzZVNwYW5SZWNvcmQoc3BhbnNbaV0pO1xuICAgIH1cbn1cblxuLy8gVE9ETzogdGhpcyBpcyBpbnRlbmRlZCB0byBiZSBhIHJlYXNvbmFibGUgc2hvcnQtdGVybSBzb2x1dGlvbiwgbm90aGluZyBtb3JlLlxuZnVuY3Rpb24gZGVmYXVsdFNlcnZpY2VIb3N0KCkge1xuICAgIHJldHVybiBcImFwaS50cmFjZWd1aWRlLmlvXCI7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXJ2aWNlUG9ydCgpIHtcbiAgICAvLyBUT0RPOiBtdXN0IGJlIGV4cGxpY2l0IGFib3V0IGh0dHAvaHR0cHMuXG4gICAgcmV0dXJuIDk5OTc7XG59XG5cbi8vIFJldHVybnMgdHJ1ZSBpZiBhbGwgZWxlbWVudHMgaW4gYXJyYXkgXCJhXCIgYXJlIG9mIHR5cGUgc3RyaW5nLlxuLy8gUmV0dXJucyB0cnVlIGZvciBlbXB0eSBhcnJheXMuXG5mdW5jdGlvbiBhbGxFbGVtZW50c0FyZVN0cmluZ3MoYSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodHlwZW9mIGFbaV0gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuLy8gU3RhdGVcbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cblxuZnVuY3Rpb24gU3RhdGUodGhyaWZ0VHlwZXMsIHRocmlmdExpYnJhcnksIHBsYXRmb3JtLCBldmVudEhhbmRsZXJzKSB7XG4gICAgRXZlbnRFbWl0dGVyTWluLmNhbGwodGhpcyk7XG5cbiAgICBpbml0aWFsaXplR2xvYmFscyh0aGlzLCB0aHJpZnRUeXBlcywgdGhyaWZ0TGlicmFyeSwgcGxhdGZvcm0pO1xuXG4gICAgdmFyIG5vdyA9IHBsYXRmb3JtLm5vd01pY3JvcygpO1xuXG4gICAgLy8gU2V0IHVwIGV2ZW50IGhhbmRsZXJzIGltbWVkaWF0ZWx5LCBhcyBzb21lIGFyZSBpbnZva2VkIGR1cmluZyBjcmVhdGlvblxuICAgIGZvciAodmFyIGtleSBpbiBldmVudEhhbmRsZXJzKSB7XG4gICAgICAgIHRoaXMub24oa2V5LCBldmVudEhhbmRsZXJzW2tleV0pO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSB0byB0aGUgY2xpZW50LWFwaS4gIFNldCBleHRlcm5hbGx5IGJ5IHRoZSBBUEkgY3JlYXRpb24gY29kZS5cbiAgICB0aGlzLmFwaSA9IG51bGw7XG5cbiAgICAvLyBDb25maWd1cmF0aW9uXG4gICAgdGhpcy5zZXJ2aWNlSG9zdCA9IGRlZmF1bHRTZXJ2aWNlSG9zdCgpO1xuICAgIHRoaXMuc2VydmljZVBvcnQgPSBkZWZhdWx0U2VydmljZVBvcnQoKTtcbiAgICB0aGlzLmNlcnRpZmljYXRlVmVyaWZpY2F0aW9uID0gdHJ1ZTtcbiAgICB0aGlzLmJ1ZmZlck1heFNwYW5SZWNvcmRzICAgID0ga01heFNwYW5SZWNvcmRzRGVmYXVsdDtcbiAgICB0aGlzLmJ1ZmZlck1heExvZ1JlY29yZHMgICAgID0ga01heExvZ1JlY29yZHNEZWZhdWx0O1xuICAgIHRoaXMucmVmcmVzaEludGVydmFsTXMgICAgICAgPSBrUmVmcmVzaEludGVydmFsTXNEZWZhdWx0O1xuICAgIHRoaXMubG9nVG9TdGRpbyAgICAgICAgICAgICAgPSBmYWxzZTtcbiAgICB0aGlzLmRlYnVnICAgICAgICAgICAgICAgICAgID0gZmFsc2U7ICAvLyBcImRlYnVnXCIgcmVsYXRlcyB0byB0aGUgSFRNTCBkZWJ1ZyBvdmVybGF5XG4gICAgdGhpcy52ZXJib3NlICAgICAgICAgICAgICAgICA9IGZhbHNlOyAgLy8gXCJ2ZXJib3NlXCIgc2V0cyB2YXN0bHkgaW5jcmVhc2VkIGludGVybmFsIGxvZ2dpbmdcbiAgICB0aGlzLmhhbmRsZV91bmNhdWdodF9leGNlcHRvbj0gZmFsc2U7ICAvLyBTZWUgb3B0aW9ucygpIGhhbmRsZV91bmNhdWdodF9leGNlcHRpb25cbiAgICB0aGlzLmF1dG9pbnN0cnVtZW50ICAgICAgICAgID0gZmFsc2U7ICAvLyBJbmplY3QgaW5zdHJ1bWVudGF0aW9uIGludG8gY29tbW9uIGxpYnJhcmllcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGxpa2VseSBzaG91bGQgYmUgYSBsaWJyYXJ5LWJ5LWxpYnJhcnkgb3B0LWluLlxuICAgIHRoaXMuYXV0b21vbml0b3IgICAgICAgICAgICAgPSBmYWxzZTsgIC8vIFBlcmlvZGljYWxseSBwb2xsICYgbG9nIHN5c3RlbSBzdGF0c1xuICAgIHRoaXMuZGlzYWJsZUNsb2NrQ29ycmVjdGlvbiAgPSBmYWxzZTsgIC8vIERvbid0IHRyeSB0byBhZGp1c3QgZm9yIGNsaWVudC1zZXJ2aWNlIGNsb2NrIG9mZnNldC5cblxuICAgIC8vIFRocmlmdCBydW50aW1lIG9iamVjdCBhbmQgY2xpZW50IG9iamVjdFxuICAgIHRoaXMucnVudGltZSA9IG5ldyBjcm91dG9uX3RocmlmdC5SdW50aW1lKCk7XG4gICAgdGhpcy5ydW50aW1lLmd1aWQgPSBcIlwiO1xuICAgIHRoaXMucnVudGltZS5ncm91cF9uYW1lID0gXCJcIjtcbiAgICB0aGlzLnJ1bnRpbWUuc3RhcnRfbWljcm9zID0gbm93O1xuXG4gICAgLy8gVGhyaWZ0IGNsaWVudCBvYmplY3QgLSBpbml0aWFsaXplZCBhdCB0aGUgc3RhcnQgb2YgdGhlIHJlZnJlc2ggbG9vcFxuICAgIHRoaXMuY2xpZW50ICAgICA9IG51bGw7XG4gICAgdGhpcy5hdXRoICAgICAgID0gbmV3IGNyb3V0b25fdGhyaWZ0LkF1dGgoKTtcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSBudWxsOyAgLy8gPC0tIE9ubHkgc2V0IGZvciBub2RlLmpzICh0aGUgYXN5bW1ldHJ5IGlzIG5vdCBpZGVhbCwgYnV0IG5lZWRlZClcblxuICAgIC8vIE1vZGVsIG9mIGNsb2NrIHNrZXcgYmV0d2VlbiBjbGllbnQgYW5kIHNlcnZlclxuICAgIHRoaXMuY2xvY2tTdGF0ZSA9IG51bGw7XG5cbiAgICAvLyBQYXlsb2FkIHNjcnViYmVyXG4gICAgdGhpcy5zY3J1YiAgICAgID0gbnVsbDsgICAgICAgICAvLyBJbml0aWFsaXplZCBpbiBvcHRpb25zKClcblxuICAgIC8vIFN0YXR1c1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnNodXR0aW5nRG93biA9IGZhbHNlO1xuICAgIHRoaXMuY29ubmVjdGlvbk9rID0gZmFsc2U7ICAgICAgICAgIC8vIEZhbHNlIGlmIGEgcmVjb25uZWN0IGlzIG5lZWRlZCBmb3IgYW55IHJlYXNvblxuICAgIHRoaXMucmVmcmVzaExvb3BBY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLmZsdXNoQWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5mbHVzaEVycm9yQ291bnQgPSAwOyAgICAgICAgICAgLy8gQ29uc2VjdXRpdmUgZXJyb3JzIGZyb20gcmVwb3J0IGNhbGxzIChmb3IgYmFjay1vZmYgcHVycG9zZXMpXG4gICAgdGhpcy5mbHVzaE5vbkNvbm5lY3RFcnJvckNvdW50ID0gMDsgLy8gQ29uc2VjdXRpdmUgZXJyb3JzICprbm93biogbm90IHRvIGJlIGNvbm5lY3Rpb24gZXJyb3JzXG4gICAgdGhpcy5mbHVzaFRpbWVyID0gbnVsbDtcblxuICAgIC8vIE1vcmUgZ2VuZXJhbCBjb3VudGVyIGluZGljYXRpbmcgdGhhdCBjcnVudGltZSBpcyBjdXJyZW50bHkgaW4gdGhlIGNhbGwgc3RhY2tcbiAgICAvLyBkb2luZyB3b3JrLCBzdWNoIGFzIHNjcnViYmluZyBhIGxvZzsgdXNlZCBhcyBhIHNpZ25hbCB0byBhdm9pZCB1bmludGVuZGVkXG4gICAgLy8gcmVjdXJzaW9uIHN1Y2ggYXMgbG9nZ2luZyBhIGNvbnNvbGUubG9nKCkgY2FsbCB0aGF0IHdhcyAoc29tZWhvdykgdHJpZ2dlcmVkXG4gICAgLy8gd2hpbGUgY3JlYXRpbmcgYSBkaWZmZXJlbnQgbG9nIHJlY29yZC5cbiAgICB0aGlzLmNydW50aW1lQWN0aXZlID0gMDtcblxuICAgIC8vIFRoZSBjcnVudGltZSBhbGxvd3MgdGhlIGFjdGl2ZSBzcGFuIGhhbmRsZSBPUiBhY3RpdmUgam9pbiBJRHMgdG8gYmVcbiAgICAvLyB0cmFja2VkLiBCb3RoIHR5cGUgb2Ygb2JqZWN0cyBtYXkgYmUgb24gdGhpcyBzdGFjay4gVGhlIGNvZGUgZG9lcyBub3RcbiAgICAvLyBzaW1wbHkgc3RvcmUgdGhlIGpvaW4gSURzIG9mIGEgc3BhbiBiZWluZyBwdXNoZWQgaGVyZSBhcywgaWYgdGhlIHNwYW5cbiAgICAvLyBoYW5kbGUgaXMgc3RvcmVkIGl0J3MgcG9zc2libGUgY2hlY2sgdGhhdCBpZiB0aGUgc3BhbiBoYXMgYmVlbiBlbmQoKSdlZCxcbiAgICAvLyB3aGljaCBhdm9pZHMgc29tZSBzZXQgb2YgZmFsc2UgcG9zaXRpdmUgdHJhY2Ugam9pbnMuXG4gICAgdGhpcy5hY3RpdmVTcGFuT3JKb2luSURzU3RhY2sgPSBbXTtcblxuICAgIC8vIFJ1bnRpbWUgaW5mb1xuICAgIHRoaXMuZW5hYmxlZCAgICA9IHRydWU7IC8vIElmIGZhbHNlLCB0dXJuIHRoZSBydW50aW1lIGludG8gYXMgY2xvc2UgdG8gYSBub29wIGFzIHBvc3NpYmxlXG4gICAgdGhpcy5qb2luSWRzICAgID0ge307ICAgLy8gR2xvYmFsIGpvaW4gaWRzIHRoYXQgd2lsbCBiZSBpbmhlcml0ZWQgYnkgYWxsIHNwYW5zXG5cbiAgICAvLyBCdWZmZXJzXG4gICAgdGhpcy5yZXBvcnRPbGRlc3RNaWNyb3MgICA9IG5vdztcbiAgICB0aGlzLnJlcG9ydFlvdW5nZXN0TWljcm9zID0gbm93O1xuICAgIHRoaXMuc3BhbnMgICAgICAgICAgICAgICAgPSBbXTtcbiAgICB0aGlzLmxvZ3MgICAgICAgICAgICAgICAgID0gW107XG4gICAgdGhpcy5kaXNjYXJkZWRMb2dTYW1wbGVzICA9IG5ldyBUaW1lc3RhbXBTYW1wbGVzKDEwMCwgMyk7XG5cbiAgICAvLyBSZXVzYWJsZSBvYmplY3RzIC8gb2JqZWN0IHBvb2xzIHRvIHJlZHVjZSBnYyB0aHJhc2hpbmdcbiAgICB0aGlzLnJldXNhYmxlID0ge1xuICAgICAgICByZXBvcnRSZXF1ZXN0ICAgICAgIDogbmV3IGNyb3V0b25fdGhyaWZ0LlJlcG9ydFJlcXVlc3QoKSxcbiAgICAgICAgc3RhdHVzICAgICAgICAgICAgICA6IHt9LFxuICAgIH07XG5cbiAgICAvLyBSZXBvcnQgY291bnRlcnMgLSByZXNldCBvbiBldmVyeSBzdWNjZXNzZnVsIHJlcG9ydC5cbiAgICAvL1xuICAgIC8vIFRoZSBmaWVsZCBuYW1lcyBoYXZlIGEgY29ycmVzcG9uZGVuY2UgdG8gdGhlIEdvIGluc3RydW1lbnQvY2xpZW50XG4gICAgLy8gY291bnRlciBuYW1lIGNvbnN0YW50cyAoaS5lLiBrbm93biBjb3VudGVyIG5hbWVzIHdpbGwgYmUgZXhwb3NlZFxuICAgIC8vIGluIHRoZSBVSSkuIFNlbmRpbmcgXCJ1bmtub3duXCIgY291bnRlcnMgaXMgZmluZSBhcyB3ZWxsIGFzIHRoZVxuICAgIC8vIHNlcnZlciBtYXkgZXZlbnR1YWxseSBleHBvc2UgdGhlc2UgYW5kIHRoZSBjbGllbnQgZG9lcyBub3QgcmVxdWlyZVxuICAgIC8vIGFuIHVwZGF0ZS5cbiAgICB0aGlzLmNvdW50ZXJzID0ge1xuICAgICAgICBkcm9wcGVkX2xvZ3MgICAgICAgICA6IDAsXG4gICAgICAgIGRyb3BwZWRfc3BhbnMgICAgICAgIDogMCxcblxuICAgICAgICAvLyBUaGVzZSBvYnZpb3VzbHkgcmVseSBvbiBhIHJlcG9ydCBldmVudHVhbGx5IGdldHRpbmcgdGhyb3VnaCFcbiAgICAgICAgZmx1c2hfd2l0aF9ub19kYXRhICAgOiAwLFxuICAgICAgICBmbHVzaF9lcnJvcnMgICAgICAgICA6IDAsXG4gICAgICAgIGZsdXNoX2V4Y2VwdGlvbnMgICAgIDogMCxcbiAgICB9O1xuXG4gICAgLy8gQWRhcHRlcnMgb24gdGhlIGNsaWVudCBSUENzIChkdWUgdG8gYXN5bW1ldHJ5IGluIHRoZSBub2RlIC8gYnJvd3NlclxuICAgIC8vIHRocmlmdCBjYWxsaW5nIGNvbnZlbnRpb25zKS5cbiAgICB0aGlzLmludm9rZVJlcG9ydCA9IG51bGw7XG4gICAgdGhpcy50aHJpZnRIdHRwRXJyb3JDYWxsYmFjayA9IG51bGw7ICAgIC8vIDwtLSB3b3JrYXJvdW5kIGZvciB0aHJpZnQgY29kZVxuXG4gICAgLy8gTWFrZSB0aGUgU3RhdGUgb2JqZWN0IGludG8gYSBGYWNhZGUgdGhhdCBoaWRlcyB0aGUgcGxhdGZvcm0gZGlmZmVyZW5jZXNcbiAgICAvL1xuICAgIC8vIFRPRE86IGV2ZW50dWFsbHkgaGlkZSB0aGUgbmVlZCBmb3IgYW4gZXhwbGljaXQgaXNOb2RlIGJvb2whXG4gICAgLy9cbiAgICB0aGlzLnBsYXRmb3JtICAgICAgICAgICA9IHBsYXRmb3JtO1xuICAgIHRoaXMubG9nZ2VyICAgICAgICAgICAgID0gbnVsbDtcbiAgICB0aGlzLnByb2Nlc3NBYm9ydCAgICAgICA9IG51bGw7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBkZWZhdWx0IG9wdGlvbnNcbiAgICB0aGlzLm9wdGlvbnMoe1xuICAgICAgICBzY3J1YmJlciAgICAgICAgICAgIDogbnVsbCwgICAgIC8vIDwtLSBmb3JjZXMgdGhlIGRlZmF1bHQgc2NydWJiZXJcbiAgICAgICAgb3ZlcnJpZGVfY29uc29sZSAgICA6IHRydWUsXG4gICAgICAgIG92ZXJyaWRlX2xvZ2dlciAgICAgOiBudWxsLFxuICAgICAgICBvdmVycmlkZV9hYm9ydCAgICAgIDogbnVsbCxcbiAgICB9KTtcbn1cblxuLy8gSW5oZXJpdCBmcm9tIEV2ZW50RW1pdHRlclxuU3RhdGUucHJvdG90eXBlID0gbmV3IEV2ZW50RW1pdHRlck1pbigpO1xuXG4vLyBTZWUgdGhlIEFQSSBpbml0aWFsaXplKCkgZG9jdW1lbnRhdGlvbiBmb3IgZGV0YWlscy5cblN0YXRlLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAvLyBUaGUgbXVsdGlwbGUgaW5pdGlhbGl6YXRpb24gcnVsZSBhYm92ZSBpcyBpbnRlbnRpb25hbCBiYXNlZCBvbiB0aGUgYXNzdW1wdGlvblxuICAgIC8vIHRoYXQgd2VsbC1kZWZpbmVkIGluaXRpYWxpemF0aW9uIG9yZGVyIHRvICpub3QqIHNvbWV0aGluZyB0aGUgY3J1bnRpbWUgc2hvdWxkXG4gICAgLy8gcmVxdWlyZSBmcm9tIGFsbCBjbGllbnRzIGFzIHRoYXQgbWFrZXMgdGhlIGNydW50aW1lIGhhcmRlciB0byBpbnRlZ3JhdGUuICBUaGVcbiAgICAvLyBhYm92ZSBydWxlIGxldHMgY3VzdG9tZXJzIGJlIGEgbGl0dGxlIG1vcmUgY2FyZWxlc3MgYW5kIHN0aWxsIGhhdmUgaXQgXCJqdXN0IHdvcmtcIi5cbiAgICAvLyBObyBwb2ludHMgZm9yIGVsZWdhbmNlOyBwb2ludHMgZm9yIGNvbnZlbmllbmNlLlxuICAgIGlmICh0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgIC8vIFRyZWF0IHJlZHVuZGFudCBpbml0aWFsaXplIGNhbGxzIGFzIG9wdGlvbnMoKSBjYWxscyB0byBtZXJnZSBhbnlcbiAgICAgICAgLy8gYW5kIGFsbCBvcHRpb25zLlxuICAgICAgICB0aGlzLm9wdGlvbnMob3B0cyk7XG4gICAgICAgIHRoaXMuc3RhcnRGbHVzaEJ1ZmZlckxvb3BJZlBvc3NpYmxlKG9wdHMpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBGaXJzdCBpbml0aWFsaXphdGlvblxuICAgIC8vXG4gICAgdGhpcy5lbWl0KFwicHJlaW5pdGlhbGl6ZVwiLCB0aGlzLmFwaSk7XG5cbiAgICB0aGlzLm9wdGlvbnMob3B0cyk7XG4gICAgdGhpcy5zdGFydEZsdXNoQnVmZmVyTG9vcElmUG9zc2libGUob3B0cyk7XG5cbiAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoXCJwb3N0aW5pdGlhbGl6ZVwiLCB0aGlzLmFwaSk7XG59O1xuXG5TdGF0ZS5wcm90b3R5cGUuc3RhcnRGbHVzaEJ1ZmZlckxvb3BJZlBvc3NpYmxlID0gZnVuY3Rpb24ob3B0cykge1xuICAgIC8vIE9ubHkgc3RhcnQgdGhlIHJlcG9ydGluZyBsb29wIGlmIHRoZXJlJ3MgYW4gYWNjZXNzIHRva2VuIHNldCBhbmRcbiAgICAvLyBpZiBub3QgZXhwbGljaXRseSBwYXVzZWQuXG4gICAgdmFyIHBhdXNlZCA9IG9wdHMgPyBvcHRzLnBhdXNlZCA6IGZhbHNlO1xuICAgIGlmICh0aGlzLmF1dGguYWNjZXNzX3Rva2VuICYmICFwYXVzZWQpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVGbHVzaEJ1ZmZlckxvb3BTdGFydGVkKCk7XG4gICAgfVxufTtcblxuLy8gVE9ETzogdGhlIGNvZGUgZG9lcyBub3Qgc3VwcG9ydCByZS1pbml0aWFsaXppbmcgYWZ0ZXIgc2h1dGRvd24uIFdoaWxlIG5vdCBhXG4vLyBuZWNlc3NhcnkgZmVhdHVyZSwgaWYgdGhlIGNvZGUgd2FzIHNldCB1cCBtb3JlIGVsZWdhbnRseSwgdGhhdCB3b3VsZCB3b3JrXG4vLyBpbXBsaWNpdGx5LlxuU3RhdGUucHJvdG90eXBlLnNodXRkb3duID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc2h1dHRpbmdEb3duID0gdHJ1ZTtcblxuICAgIC8vIEVtaXQgdGhlIG1lc3NhZ2UgYmVmb3JlIHRoZSBmaW5hbCBmbHVzaCBpbiBjYXNlIHRoZSBjbGllbnQgY29kZSB3YW50cyB0b1xuICAgIC8vIHJlY29yZCBhbnkgZmluYWwgZGF0YVxuICAgIHRoaXMuZW1pdChcInNodXRkb3duXCIpO1xuXG4gICAgLy8gXCJGb3JjaWJseVwiIGNsb3NlIGFsbCB1bmNsb3NlZCBzcGFucyB3aXRoIGFuIGVycm9yXG4gICAgdmFyIHNwYW5zID0gc3Bhbl9oYW5kbGUuYWN0aXZlU3BhbkhhbmRsZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzcGFuID0gc3BhbnNbaV07XG4gICAgICAgIHNwYW4uZXJyb3IoXCJBY3RpdmUgc3BhbiBub3QgY2xvc2VkOlwiLCBzcGFuLm5hbWUoKSk7XG4gICAgICAgIHNwYW4uZW5kKCk7XG4gICAgfVxuXG4gICAgdGhpcy5mbHVzaEJ1ZmZlcih0cnVlKTtcbn07XG5cbi8vIFNldHMgb3B0aW9ucyBvbiB0aGUgcnVudGltZS4gIFJldHVybnMgdGhlIHN1YnNldCBvZiBcInVzZXItdmlzaWJsZVwiIG9wdGlvbnNcbi8vIGlmIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50cy5cblN0YXRlLnByb3RvdHlwZS5vcHRpb25zID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGtleTtcblxuICAgIC8vIEFjdCBhcyBhbiBhY2Nlc3NvciBpZiB0aGVyZSBhcmUgbm8gYXJndW1lbnRzLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbmFibGUgICAgICAgICAgICAgICAgICAgOiB0aGlzLmVuYWJsZWQsXG4gICAgICAgICAgICBhY2Nlc3NfdG9rZW4gICAgICAgICAgICAgOiB0aGlzLmF1dGguYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgc2VydmljZV9ob3N0ICAgICAgICAgICAgIDogdGhpcy5zZXJ2aWNlSG9zdCxcbiAgICAgICAgICAgIHNlcnZpY2VfcG9ydCAgICAgICAgICAgICA6IHRoaXMuc2VydmljZVBvcnQsXG4gICAgICAgICAgICBncm91cF9uYW1lICAgICAgICAgICAgICAgOiB0aGlzLnJ1bnRpbWUuZ3JvdXBfbmFtZSxcbiAgICAgICAgICAgIGpvaW5faWRzICAgICAgICAgICAgICAgICA6IHRoaXMuam9pbklkcyxcbiAgICAgICAgICAgIG1heF9sb2dfcmVjb3JkcyAgICAgICAgICA6IHRoaXMuYnVmZmVyTWF4TG9nUmVjb3JkcyxcbiAgICAgICAgICAgIG1heF9zcGFuX3JlY29yZHMgICAgICAgICA6IHRoaXMuYnVmZmVyTWF4U3BhblJlY29yZHMsXG4gICAgICAgICAgICBkZWJ1ZyAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmRlYnVnLFxuICAgICAgICAgICAgLy8gWFhYIG5vdGhpbmcgcmVhc29uYWJsZSAoPykgZm9yIG92ZXJyaWRlX2NvbnNvbGVcbiAgICAgICAgICAgIHJlZnJlc2hfaW50ZXJ2YWxfbWlsbGlzICA6IHRoaXMucmVmcmVzaEludGVydmFsTXMsXG5cbiAgICAgICAgICAgIGhhbmRsZV91bmNhdWdodF9leGNlcHRvbiA6IHRoaXMuaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdG9uLFxuICAgICAgICAgICAgYXV0b2luc3RydW1lbnQgICAgICAgICAgIDogdGhpcy5hdXRvaW5zdHJ1bWVudCxcbiAgICAgICAgICAgIGF1dG9tb25pdG9yICAgICAgICAgICAgICA6IHRoaXMuYXV0b21vbml0b3IsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRoaXMubG9nQXJndW1lbnRzRXJyb3IoW1wib3B0aW9ucyBjYWxsZWQgd2l0aCBhIG5vbi1vYmplY3QgYXJndW1lbnRcIl0pO1xuICAgIH1cblxuICAgIC8vXG4gICAgLy8gZW5hYmxlIHtib29sZWFufVxuICAgIC8vXG4gICAgaWYgKHR5cGVvZiBvcHRzLmVuYWJsZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aGlzLnNldEVuYWJsZWQob3B0cy5lbmFibGUpO1xuXG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgZGlzYWJsZTogZW5zdXJlIHRoZVxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZCkge1xuICAgICAgICAgICAgb3B0cy5vdmVycmlkZV9jb25zb2xlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIGFjY2Vzc190b2tlbiB7c3RyaW5nfVxuICAgIC8vXG4gICAgaWYgKHR5cGVvZiBvcHRzLmFjY2Vzc190b2tlbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aGlzLmF1dGguYWNjZXNzX3Rva2VuID0gb3B0cy5hY2Nlc3NfdG9rZW47XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBzZXJ2aWNlX2hvc3Qge3N0cmluZ31cbiAgICAvL1xuICAgIC8vIFNldHMgdGhlIGhvc3QgdXNlIGZvciByZXBvcnRpbmcuXG4gICAgLy9cbiAgICBpZiAodHlwZW9mIG9wdHMuc2VydmljZV9ob3N0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRoaXMuc2VydmljZUhvc3QgPSBvcHRzLnNlcnZpY2VfaG9zdDtcbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIHNlcnZpY2VfcG9ydCB7aW50fHN0cmluZ31cbiAgICAvL1xuICAgIC8vIFNldHMgdGhlIHBvcnQgdXNlIGZvciByZXBvcnRpbmcuXG4gICAgLy9cbiAgICBpZiAob3B0cy5zZXJ2aWNlX3BvcnQpIHtcbiAgICAgICAgdmFyIHBvcnQgPSBwYXJzZUludChvcHRzLnNlcnZpY2VfcG9ydCk7XG4gICAgICAgIHRoaXMuc2VydmljZVBvcnQgPSBwb3J0O1xuICAgIH1cblxuICAgIC8vXG4gICAgLy8gZ3JvdXBfbmFtZSB7c3RyaW5nfVxuICAgIC8vXG4gICAgLy8gU2V0cyB0aGUgcnVudGltZSdzIGdyb3VwX25hbWUuXG4gICAgLy9cbiAgICBpZiAodHlwZW9mIG9wdHMuZ3JvdXBfbmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aGlzLnJ1bnRpbWUuZ3JvdXBfbmFtZSA9IG9wdHMuZ3JvdXBfbmFtZTtcbiAgICAgICAgLy8gQWxzbywgc2V0IHRoZSBndWlkLlxuICAgICAgICB0aGlzLnJ1bnRpbWUuZ3VpZCA9IFN0cmluZyh0aGlzLnBsYXRmb3JtLnJ1bnRpbWVHVUlEKG9wdHMuZ3JvdXBfbmFtZSkpO1xuXG4gICAgICAgIC8vIEVtaXQgYW4gZXZlbnQgc28gYWRkLW9ucyBsaWtlIHRoZSBzZXNzaW9uIGpvaW4gaWQuXG4gICAgICAgIHRoaXMuZW1pdChcIm9wdGlvbnMuc2V0X2dyb3VwX25hbWVcIiwgdGhpcy5hcGksIHRoaXMucnVudGltZS5ncm91cF9uYW1lKTtcbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIGpvaW5faWRzIHtvYmplY3R9XG4gICAgLy9cbiAgICAvLyBBIHNldCBvZiBzdHJpbmctdG8tc3RyaW5nIGtleS12YWx1ZSBwYWlycyB0byBiZSBzZXQgZ2xvYmFsbHkgZm9yIHRoZVxuICAgIC8vIHJ1bnRpbWUuICBBbGwgY3JlYXRlZCBzcGFucyB3aWxsIGluaGVyaXQgdGhlc2Ugam9pbiBpZHMuXG4gICAgLy9cbiAgICBpZiAob3B0cy5qb2luX2lkcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZvciAoa2V5IGluIG9wdHMuam9pbl9pZHMpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG9wdHMuam9pbl9pZHNba2V5XTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5qb2luSWRzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuam9pbklkc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBtYXhfbG9nX3JlY29yZHMge2ludH1cbiAgICAvL1xuICAgIC8vIE1heGltdW0gbnVtYmVyIG9mIGxvZyByZWNvcmRzIHRvIGJ1ZmZlci4gSWYgdGhlIGN1cnJlbnQgYnVmZmVyIGFscmVhZHlcbiAgICAvLyBleGNlZWRzIHRoaXMgc2l6ZSwgdGhlIGJ1ZmZlciBzaXplIHdpbGwgbm90IHJlc2V0IHVudGlsIHRoZSBuZXh0XG4gICAgLy8gcmVwb3J0LlxuICAgIC8vXG4gICAgLy8gU2V0dGluZyB0byBudWxsIHdpbGwgcmVzZXQgdG8gdGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgLy9cbiAgICBpZiAodHlwZW9mIG9wdHMubWF4X2xvZ19yZWNvcmRzID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIC8vIEFsd2F5cyBidWZmZXIgYXQgbGVhc3QgMTsgdGhpcyBzaW1wbGlmaWVzIHRoZSBydW50aW1lIGxvZ2ljIGFuZCB0aGVcbiAgICAgICAgLy8gY2xpZW50IGNhbiBhbHdheXMgc2V0IFwiZW5hYmxlXCIgdG8gZmFsc2UuXG4gICAgICAgIHRoaXMuYnVmZmVyTWF4TG9nUmVjb3JkcyA9IE1hdGgubWF4KG9wdHMubWF4X2xvZ19yZWNvcmRzLCAxKTtcbiAgICB9IGVsc2UgaWYgKG9wdHMubWF4X2xvZ19yZWNvcmRzID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyTWF4TG9nUmVjb3JkcyA9IGtNYXhMb2dSZWNvcmRzRGVmYXVsdDtcbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIG1heF9zcGFuX3JlY29yZHMge2ludH1cbiAgICAvL1xuICAgIC8vIE1heGltdW0gbnVtYmVyIG9mIGxvZyByZWNvcmRzIHRvIGJ1ZmZlci4gSWYgdGhlIGN1cnJlbnQgYnVmZmVyIGFscmVhZHlcbiAgICAvLyBleGNlZWRzIHRoaXMgc2l6ZSwgdGhlIGJ1ZmZlciBzaXplIHdpbGwgbm90IHJlc2V0IHVudGlsIHRoZSBuZXh0XG4gICAgLy8gcmVwb3J0LlxuICAgIC8vXG4gICAgLy8gU2V0dGluZyB0byBudWxsIHdpbGwgcmVzZXQgdG8gdGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgLy9cbiAgICBpZiAodHlwZW9mIG9wdHMubWF4X3NwYW5fcmVjb3JkcyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAvLyBBbHdheXMgYnVmZmVyIGF0IGxlYXN0IDE7IHRoaXMgc2ltcGxpZmllcyB0aGUgcnVudGltZSBsb2dpYyBhbmQgdGhlXG4gICAgICAgIC8vIGNsaWVudCBjYW4gYWx3YXlzIHNldCBcImVuYWJsZVwiIHRvIGZhbHNlLlxuICAgICAgICB0aGlzLmJ1ZmZlck1heFNwYW5SZWNvcmRzID0gTWF0aC5tYXgob3B0cy5tYXhfc3Bhbl9yZWNvcmRzLCAxKTtcbiAgICB9IGVsc2UgaWYgKG9wdHMubWF4X3NwYW5fcmVjb3JkcyA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmJ1ZmZlck1heFNwYW5SZWNvcmRzID0ga01heFNwYW5SZWNvcmRzRGVmYXVsdDtcbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIGRlYnVnIHtib29sfVxuICAgIC8vXG4gICAgLy8gU2hvdWxkIHRoZSBpbnN0cnVtZW50YXRpb24gb2ZmZXIgYSB3YXkgdG8gZGVidWcgdGhlIGN1cnJlbnQgaW50ZXJhY3Rpb24uXG4gICAgLy8gVE9ETyBicm93c2VyIG9ubHk/XG4gICAgLy9cbiAgICBpZiAodHlwZW9mIG9wdHMuZGVidWcgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHRoaXMuZGVidWcgPSBvcHRzLmRlYnVnO1xuXG4gICAgICAgIC8vIEVtaXQgYW4gZXZlbnQgc28gYWRkLW9ucyBsaWtlIHRoZSBkZWJ1ZyBvdmVybGF5IHdpbmRvdyBjYW4ga25vdyB0byBkaXNwbGF5XG4gICAgICAgIC8vIHRoZW1zZWx2ZXMgb3Igbm90LlxuICAgICAgICB0aGlzLmVtaXQoXCJvcHRpb25zLnNldF9kZWJ1Z1wiLCB0aGlzLmFwaSwgdGhpcy5kZWJ1Zyk7XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyB2ZXJib3NlIHtib29sfVxuICAgIC8vXG4gICAgLy8gSWYgdHJ1ZSwgZ3JlYXRseSBpbmNyZWFzZXMgdGhlIGFtb3VudCBvZiBpbnRlcm5hbCBhbmQgaW5zdHJ1bWVudGVkIGxvZ2dpbmcuXG4gICAgLy9cbiAgICBpZiAodHlwZW9mIG9wdHMudmVyYm9zZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgdGhpcy52ZXJib3NlID0gb3B0cy52ZXJib3NlO1xuICAgIH1cblxuICAgIC8vXG4gICAgLy8gbG9nX3RvX3N0ZGlvIHtib29sfSwgZGVmYXVsdCA9IGZhbHNlXG4gICAgLy9cbiAgICAvLyBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgY3IubG9nL3dhcm4vZXJyb3IgY2FsbHMgc2hvdWxkIGJlIGVjaG9lZCB0byBzdGFuZGFyZFxuICAgIC8vIG91dHB1dC5cbiAgICBpZiAodHlwZW9mIG9wdHMubG9nX3RvX3N0ZGlvID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICB0aGlzLmxvZ1RvU3RkaW8gPSBvcHRzLmxvZ190b19zdGRpbztcbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIG92ZXJyaWRlX2NvbnNvbGUge2Jvb2x9XG4gICAgLy9cbiAgICAvLyBPdmVycmlkZSB0aGUgZ2xvYmFsIHdpbmRvdy5jb25zb2xlIC8gZ2xvYmFsLmNvbnNvbGUgb2JqZWN0IGFuZCBwaXBlIHRoZVxuICAgIC8vIGlucHV0IHRocm91Z2ggY3J1bnRpbWUuICBBIHZhbHVlIG9mIGBmYWxzZWAgd2lsbCByZXNldCB0aGUgY29uc29sZSBvYmplY3QuXG4gICAgaWYgKG9wdHMub3ZlcnJpZGVfY29uc29sZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChvcHRzLm92ZXJyaWRlX2NvbnNvbGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nICAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5lbmFibGVkICYmICFzZWxmLmZsdXNoQWN0aXZlICYmICFzZWxmLmNydW50aW1lQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubG9nQXJndW1lbnRzSW5mby5jYWxsKHNlbGYsIGFyZ3VtZW50cywgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbENvbnNvbGVfbG9nLmFwcGx5KG9yaWdpbmFsQ29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc29sZS53YXJuICA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmVuYWJsZWQgJiYgIXNlbGYuZmx1c2hBY3RpdmUgJiYgIXNlbGYuY3J1bnRpbWVBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2dBcmd1bWVudHNXYXJuLmNhbGwoc2VsZiwgYXJndW1lbnRzLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsQ29uc29sZV93YXJuLmFwcGx5KG9yaWdpbmFsQ29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc29sZS5lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmVuYWJsZWQgJiYgIXNlbGYuZmx1c2hBY3RpdmUgJiYgIXNlbGYuY3J1bnRpbWVBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2dBcmd1bWVudHNFcnJvci5jYWxsKHNlbGYsIGFyZ3VtZW50cywgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbENvbnNvbGVfZXJyb3IuYXBwbHkob3JpZ2luYWxDb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyAgID0gb3JpZ2luYWxDb25zb2xlX2xvZztcbiAgICAgICAgICAgIGNvbnNvbGUud2FybiAgPSBvcmlnaW5hbENvbnNvbGVfd2FybjtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IgPSBvcmlnaW5hbENvbnNvbGVfZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIHJlZnJlc2hfaW50ZXJ2YWxfbWlsbGlzIHtudW1iZXJ9XG4gICAgLy9cbiAgICAvLyBTZXQgaG93IGZyZXF1ZW50bHkgdGhlIGNydW50aW1lIHJlcG9ydHMgdG8gdGhlIHNlcnZpY2UsIGluIG1pbGxpc2Vjb25kcy5cbiAgICAvLyBJZiBzZXQgdG8gbnVsbCwgdGhlIGNydW50aW1lIHdpbGwgcmVzZXQgdGhlIHJlcG9ydCBpbnRlcnZhbCB0byBpdHNcbiAgICAvLyBpbnRlcm5hbCBkZWZhdWx0LlxuICAgIC8vXG4gICAgaWYgKHR5cGVvZiBvcHRzLnJlZnJlc2hfaW50ZXJ2YWxfbWlsbGlzID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHRoaXMucmVmcmVzaEludGVydmFsTXMgPSBNYXRoLm1heCgwLCBvcHRzLnJlZnJlc2hfaW50ZXJ2YWxfbWlsbGlzKTtcbiAgICB9IGVsc2UgaWYgKG9wdHMucmVmcmVzaF9pbnRlcnZhbF9taWxsaXMgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5yZWZyZXNoSW50ZXJ2YWxNcyA9IGtSZWZyZXNoSW50ZXJ2YWxNc0RlZmF1bHQ7XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBzY3J1YmJlciB7b2JqZWN0fVxuICAgIC8vXG4gICAgLy8gU2V0cyB0aGUgb3B0aW9ucyBvbiB0aGUgcGF5bG9hZCBkYXRhIHNjcnViYmVyLiBTZWUgcmwtc2NydWJiZXIgZm9yIGRvY3VtZW50YXRpb25cbiAgICAvLyBvbiB0aGUgc2NydWJiZXIgb3B0aW9ucy4gSWYgc2V0IHRvIG51bGwsIHRoZSBzY3J1YmJlciB3aWxsIGJlIHJlc2V0IHRvIHRoZVxuICAgIC8vIGRlZmF1bHQgY29uZmlndXJhdGlvbi5cbiAgICAvL1xuICAgIGlmIChvcHRzLnNjcnViYmVyID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuc2NydWIgPSBzY3J1YmJlci5tYWtlKHtcbiAgICAgICAgICAgIHJ1bGVzIDogW10uY29uY2F0KGtCYXNlbGluZVNjcnViYmVyUnVsZXMsIGtEZWZhdWx0U2NydWJiZXJzUnVsZXMpLFxuICAgICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRzLnNjcnViYmVyID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgYmFzZWxpbmUgcnVsZXMgYXJlIGFsd2F5cyBpbmNsdWRlZCBzbyB0aGF0IHRyYWNlZ3VpZGUgaW50ZXJuYWxcbiAgICAgICAgLy8gaW5mb3JtYXRpb24gaXMgc3RyaXBwZWQgZnJvbSB0aGUgcGF5bG9hZHNcbiAgICAgICAgdmFyIHNjcnViYmVyQ29uZmlnID0ge307XG4gICAgICAgIGZvciAoa2V5IGluIG9wdHMuc2NydWJiZXIpIHtcbiAgICAgICAgICAgIHNjcnViYmVyQ29uZmlnW2tleV0gPSBvcHRzLnNjcnViYmVyW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgc2NydWJiZXJDb25maWcucnVsZXMgPSBrQmFzZWxpbmVTY3J1YmJlclJ1bGVzLmNvbmNhdChzY3J1YmJlckNvbmZpZy5ydWxlcyB8fCBbXSk7XG4gICAgICAgIHRoaXMuc2NydWIgPSBzY3J1YmJlci5tYWtlKHNjcnViYmVyQ29uZmlnKTtcbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIGNlcnRpZmljYXRlX3ZlcmlmaWNhdGlvbiB7Ym9vbGVhbn1cbiAgICAvL1xuICAgIC8vIElmIGZhbHNlLCBpbmZvcm1zIHRoZSBub2RlIGh0dHBzIGxpYnJhcmllcyBub3QgdG8gZG8gY2VydGlmaWNhdGlvbiB2ZXJpZmljYXRpb24uXG4gICAgLy8gVXNlZnVsIGZvciBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgLy9cbiAgICBpZiAob3B0cy5jZXJ0aWZpY2F0ZV92ZXJpZmljYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmNlcnRpZmljYXRlVmVyaWZpY2F0aW9uID0gISFvcHRzLmNlcnRpZmljYXRlX3ZlcmlmaWNhdGlvbjtcbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIGNlcnRpZmljYXRlX3ZlcmlmaWNhdGlvbiB7Ym9vbGVhbn1cbiAgICAvL1xuICAgIC8vIElmIHRydWUsIGluIE5vZGUuanMgYSBoYW5kbGVyIGZvciB0aGUgcHJvY2Vzcy5vbigndW5jYXVnaHRFeGNlcHRpb24nKSBldmVudFxuICAgIC8vIHdpbGwgYmUgYWRkZWQgdG8gbG9nIGFuZCByZXRocm93IHRoZSBleGNlcHRpb24uXG4gICAgLy9cbiAgICAvLyBEaXNhYmxlZCBieSBkZWZhdWx0IGR1ZSB0byBhIGN1c3RvbWVyIHJlcG9ydCBvZiB0aGlzIGhhdmluZyBzaWRlLWVmZmVjdHMuXG4gICAgLy9cbiAgICBpZiAob3B0cy5oYW5kbGVfdW5jYXVnaHRfZXhjZXB0b24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmhhbmRsZV91bmNhdWdodF9leGNlcHRvbiA9ICEhb3B0cy5oYW5kbGVfdW5jYXVnaHRfZXhjZXB0b247XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBhdXRvaW5zdHJ1bWVudCB7Ym9vbGVhbn1cbiAgICAvL1xuICAgIGlmIChvcHRzLmF1dG9pbnN0cnVtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5hdXRvaW5zdHJ1bWVudCA9ICEhb3B0cy5hdXRvaW5zdHJ1bWVudDtcbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIGF1dG9tb25pdG9yIHtib29sZWFufVxuICAgIC8vXG4gICAgaWYgKG9wdHMuYXV0b21vbml0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmF1dG9tb25pdG9yID0gISFvcHRzLmF1dG9tb25pdG9yO1xuICAgIH1cblxuXG4gICAgLy9cbiAgICAvLyAtLSBpbnRlcm5hbCB1c2Ugb25seSAtLVxuICAgIC8vXG4gICAgLy8gY3J1bnRpbWVfcGxhdGZvcm0ge3N0cmluZ31cbiAgICAvL1xuICAgIC8vIFBsYXRmb3JtIG9mIHRoZSBjcnVudGltZSBpdHNlbGYgKGkuZS4gbm9kZSBvciBicm93c2VyIGFuZCBhIHgueC54IHNlbWFudGljXG4gICAgLy8gdmVyc2lvbiBzdHJpbmcpLlxuICAgIGlmICh0eXBlb2Ygb3B0cy5jcnVudGltZV9wbGF0Zm9ybSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aGlzLnJlcGxhY2VPckFkZFJ1bnRpbWVLZXlWYWx1ZShcImNydW50aW1lX3BsYXRmb3JtXCIsIG9wdHMuY3J1bnRpbWVfcGxhdGZvcm0pO1xuICAgIH1cblxuICAgIC8vXG4gICAgLy8gLS0gaW50ZXJuYWwgdXNlIG9ubHkgLS1cbiAgICAvL1xuICAgIC8vIGNydW50aW1lX3BsYXRmb3JtIHtzdHJpbmd9XG4gICAgLy9cbiAgICAvLyBTZW1hbnRpYyB2ZXJzaW9uIG9mIHRoZSBjcnVudGltZSBpdHNlbGYgKGkuZS4geC54Lnggc3R5bGUgdmVyc2lvbiBzdHJpbmcsXG4gICAgLy8gaHR0cDovL3NlbXZlci5vcmcvKS5cbiAgICAvL1xuICAgIGlmICh0eXBlb2Ygb3B0cy5jcnVudGltZV92ZXJzaW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRoaXMucmVwbGFjZU9yQWRkUnVudGltZUtleVZhbHVlKFwiY3J1bnRpbWVfdmVyc2lvblwiLCBvcHRzLmNydW50aW1lX3ZlcnNpb24pO1xuICAgIH1cblxuXG4gICAgLy9cbiAgICAvLyAtLSBpbnRlcm5hbCB1c2Ugb25seSAtLVxuICAgIC8vXG4gICAgLy8gcmVzZXRfb2JqZWN0X3Bvb2xzIHtib29sfVxuICAgIC8vXG4gICAgLy8gUmVzZXQgdGhlIG9iamVjdCBwb29scywgZm9yIHRlc3RpbmcgdGVzdCB0aGUgbWVtb3J5IHVzYWdlXG4gICAgLy9cbiAgICBpZiAob3B0cy5yZXNldF9vYmplY3RfcG9vbHMpIHtcbiAgICAgICAgdGhpcy5yZXNldE9iamVjdFBvb2xzKCk7XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyAtLSBpbnRlcm5hbCB1c2Ugb25seSAtLVxuICAgIC8vXG4gICAgLy8gb3ZlcnJpZGVfYWJvcnQge2Z1bmN0aW9uKCl9XG4gICAgLy9cbiAgICAvLyBBbGxvdyB0aGUgcGxhdGZvcm0gYWJvcnQoKSBmdW5jdGlvbiB0byBiZSBvdmVycmlkZGVuIGZvciB0ZXN0aW5nLlxuICAgIC8vIFNldHRpbmcgYSB2YWx1ZSBvZiBgbnVsbGAgd2lsbCByZXZlcnQgYmFjayB0byB0aGUgcGxhdGZvcm0gYWJvcnQoKVxuICAgIC8vIGltcGxlbWVudGF0aW9uLlxuICAgIC8vXG4gICAgaWYgKG9wdHMub3ZlcnJpZGVfYWJvcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIG9wdHMub3ZlcnJpZGVfYWJvcnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzQWJvcnQgPSBvcHRzLm92ZXJyaWRlX2Fib3J0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzQWJvcnQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMucGxhdGZvcm0uYWJvcnQoKTsgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gLS0gaW50ZXJuYWwgdXNlIG9ubHkgLS1cbiAgICAvL1xuICAgIC8vIG92ZXJyaWRlX2xvZ2dlciB7b2JqZWN0fVxuICAgIC8vXG4gICAgLy8gQWxsb3cgdGhlIHBsYXRmb3JtIGNvbnNvbGUgdG8gYmUgb3ZlcnJpZGRlbiBmb3IgdGVzdGluZyBwdXJwb3Nlcy5cbiAgICAvLyBUaGUgb3ZlcnJpZGUgaXMgKm5vdCogYSAxOjEgbWFwcGluZyB0byB0aGUgbm9ybWFsIGxvZ2dlci4gSW5zdGVhZCBpdFxuICAgIC8vIHNpbXBsaWZpZXMgdGhpbmdzIGRvd24gdG8gYSBzaW5nbGUgZnVuY3Rpb24gYXMgdGhpcyBpcyBmb3IgYmFzaWNcbiAgICAvLyB0ZXN0aW5nLlxuICAgIGlmIChvcHRzLm92ZXJyaWRlX2xvZ2dlciAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgdmFyIGYgPSBvcHRzLm92ZXJyaWRlX2xvZ2dlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBmID09IFwiZnVuY3Rpb25cIikge1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgYSB2ZXJ5IHNpbXBsZSBsb2dnZXIgcHJveHkuXG4gICAgICAgICAgICB2YXIgZyA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZihhcmdzLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmxvZ2dlciA9IHtcbiAgICAgICAgICAgICAgICBpbmZvICA6IGcsXG4gICAgICAgICAgICAgICAgd2FybiAgOiBnLFxuICAgICAgICAgICAgICAgIGVycm9yIDogZyxcbiAgICAgICAgICAgICAgICBmYXRhbCA6IGcsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlciA9IHRoaXMucGxhdGZvcm0ubG9nZ2VyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyAtLSBpbnRlcm5hbCB1c2Ugb25seSAtLVxuICAgIC8vXG4gICAgLy8gb3ZlcnJpZGVfcmVwb3J0X3JwYyB7ZnVuY3Rpb24oc3luY2hvcm5vdXMsIHJlcXVlc3QsIGNhbGxiYWNrKGVyciwgcmVzcG9uc2UpKX1cbiAgICAvL1xuICAgIC8vIEFsbG93IHRoZSByZXBvcnRpbmcgZnVuY3Rpb24gdG8gYmUgb3ZlcnJpZGRlbiBmb3IgdGVzdGluZy5cbiAgICBpZiAob3B0cy5vdmVycmlkZV9yZXBvcnRfcnBjICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLm92ZXJyaWRlX3JlcG9ydF9ycGMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5pbnZva2VSZXBvcnQgPSBvcHRzLm92ZXJyaWRlX3JlcG9ydF9ycGM7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jbGllbnQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYSB0aHJpZnQgY2xpZW50LCBjb25uZWN0IGJhY2sgdG8gdGhlIFJQQ1xuICAgICAgICAgICAgdGhpcy5pbnZva2VSZXBvcnQgPSB0aGlzLmNyZWF0ZUFzeW5jUlBDQWRhcHRlcih0aGlzLmNsaWVudC5SZXBvcnQsIGNyb3V0b25fdGhyaWZ0LlJlcG9ydFJlc3BvbnNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgbGVhdmUgaW4gdGhlIHVuY29ubmVjdGVkIHN0YXRlXG4gICAgICAgICAgICB0aGlzLmludm9rZVJlcG9ydCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIC0tIGludGVybmFsIHVzZSBvbmx5IC0tXG4gICAgLy9cbiAgICAvLyBkaXNhYmxlX2Nsb2NrX2NvcnJlY3Rpb24ge2Jvb2xlYW59XG4gICAgLy9cbiAgICAvLyBUdXJuIG9mZiBhdXRvbWF0aWMgY2xvY2sgY29ycmVjdGlvbi5cbiAgICBpZiAob3B0cy5kaXNhYmxlX2Nsb2NrX2NvcnJlY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmRpc2FibGVDbG9ja0NvcnJlY3Rpb24gPSAhIW9wdHMuZGlzYWJsZV9jbG9ja19jb3JyZWN0aW9uO1xuICAgIH1cbn07XG5cblN0YXRlLnByb3RvdHlwZS5ub3dNaWNyb3MgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBDb2VyY2UgdGhlIHZhbHVlIHRvIGFuIGludGVnZXIgYnkgT1InaW5nIHdpdGggemVybyBhcyBhXG4gICAgLy8gcHJlY2F1dGlvbiBnaXZlbiB2YXJpb3VzIHBsYXRmb3JtIHRpbWVyIGltcGxlbWVudGF0aW9uIGRpZmZlcmVuY2VzLlxuICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMucGxhdGZvcm0ubm93TWljcm9zKCkpO1xufTtcblxuU3RhdGUucHJvdG90eXBlLmdlbmVyYXRlR1VJRCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBsYXRmb3JtLmdlbmVyYXRlR1VJRCgpO1xufTtcblxuU3RhdGUucHJvdG90eXBlLnN0YWNrVHJhY2UgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF0Zm9ybS5zdGFja1RyYWNlKCk7XG59O1xuXG5TdGF0ZS5wcm90b3R5cGUuZGVmYXVsdExvZ0ZpbGVuYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGxhdGZvcm0uZGVmYXVsdExvZ0ZpbGVuYW1lKCk7XG59O1xuXG5TdGF0ZS5wcm90b3R5cGUucmVwbGFjZU9yQWRkUnVudGltZUtleVZhbHVlID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHZhciBrZXlWYWx1ZSA9IG5ldyBjcm91dG9uX3RocmlmdC5LZXlWYWx1ZSgpO1xuICAgIGtleVZhbHVlLktleSA9IFwiXCIgKyBrZXk7ICAgIC8vIENvZXJjZSB0byBhIHN0cmluZ1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBrZXlWYWx1ZS5WYWx1ZSA9IHZhbHVlO1xuXG4gICAgaWYgKCF0aGlzLnJ1bnRpbWUuYXR0cnMpIHtcbiAgICAgICAgdGhpcy5ydW50aW1lLmF0dHJzID0gW107XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ydW50aW1lLmF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhdHRyID0gdGhpcy5ydW50aW1lLmF0dHJzW2ldO1xuICAgICAgICBpZiAoYXR0ci5LZXkgPT0ga2V5KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEpTIHJlbWluZGVyOiBzZXR0aW5nIHRvIGFycmF5W2xlbmd0aF0gaXMgdGhlIHNhbWUgYXMgYXJyYXkucHVzaCgpLFxuICAgIC8vIHNvIHRoaXMgd29ya3MgZm9yIGJvdGggdGhlIHJlcGxhY2UgYW5kIGluc2VydCBjYXNlcy5cbiAgICB0aGlzLnJ1bnRpbWUuYXR0cnNbaV0gPSBrZXlWYWx1ZTtcbn07XG5cblN0YXRlLnByb3RvdHlwZS5ydW50aW1lQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChhdHRycykge1xuICAgIC8vIEdldHRlclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBtYXAgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJ1bnRpbWUuYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBhdHRyID0gdGhpcy5ydW50aW1lLmF0dHJzW2ldO1xuICAgICAgICAgICAgbWFwW2F0dHIuS2V5XSA9IGF0dHIuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG5cbiAgICAvLyBTZXR0ZXJcbiAgICBpZiAodHlwZW9mIGF0dHJzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIC8vIFRPRE86IFNvbWUgaW50ZXJuYWwgd2FybmluZy9lcnJvciBBUEkgaXMgbmVlZGVkXG4gICAgICAgIGlmIChERUJVRykge1xuICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoZmFsc2UsIFwiVW5leHBlY3RlZCBhdHRycyB2YWx1ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBhdHRycykge1xuICAgICAgICB0aGlzLnJlcGxhY2VPckFkZFJ1bnRpbWVLZXlWYWx1ZShrZXksIGF0dHJzW2tleV0pO1xuICAgIH1cbn07XG5cblN0YXRlLnByb3RvdHlwZS5ydW50aW1lR1VJRCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJ1bnRpbWUuZ3VpZDtcbn07XG5cblN0YXRlLnByb3RvdHlwZS5zZXRFbmFibGVkID0gZnVuY3Rpb24oZW5hYmxlKSB7XG4gICAgLy8gQ29lcmNlIGludG8gYSBib29sXG4gICAgZW5hYmxlID0gISghZW5hYmxlIHx8IChlbmFibGUgPT09IFwiZmFsc2VcIiA/IHRydWUgOiBmYWxzZSkpO1xuICAgIGlmICh0aGlzLmVuYWJsZWQgPT09IGVuYWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5lbmFibGVkID0gZW5hYmxlO1xuXG4gICAgaWYgKCFlbmFibGUpIHtcbiAgICAgICAgLy8gUmVzcGVjdCB0aGUgXCJ0dXJuIHRoaXMgb2ZmIVwiIGNvbW1hbmQgQVNBUC4gRG9uJ3QgdHJ5IHRvIGZsdXNoIHRoZVxuICAgICAgICAvLyBidWZmZXJzIC0tIGRpc2NhcmQgJ2VtLlxuICAgICAgICB0aGlzLmRpc2NhcmRCdWZmZXJzKCk7XG4gICAgfVxufTtcblxuU3RhdGUucHJvdG90eXBlLmdldEVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5lbmFibGVkO1xufTtcblxuU3RhdGUucHJvdG90eXBlLmdldFZlcmJvc2UgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy52ZXJib3NlO1xufTtcblxuXG5TdGF0ZS5wcm90b3R5cGUuZ2V0U3RhdHVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YXR1cyA9IHRoaXMucmV1c2FibGUuc3RhdHVzO1xuICAgIHN0YXR1cy5lbmFibGVkID0gdGhpcy5lbmFibGVkO1xuICAgIHN0YXR1cy5mbHVzaEFjdGl2ZSA9IHRoaXMuZmx1c2hBY3RpdmU7XG4gICAgcmV0dXJuIHN0YXR1cztcbn07XG5cbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cbi8vIEJ1ZmZlciAvIHJlZnJlc2ggbG9vcFxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuXG4vLyBUT0RPOiBsb2NhbFN0b3JhZ2UgLS0gY3VycmVudGx5IHRyeWluZyB0byBmb3JjZSB0aGUgUlBDIHRocm91Z2ggb24gdGhlXG4vLyBiZWZvcmV1bmxvYWQgZXZlbnQgZG9lc24ndCBzZWVtIHRvIGJlIHdvcmtpbmcgY29uc2lzdGVudGx5LiAgQW5vdGhlciBvcHRpb25cbi8vIG1pZ2h0IGJlIHRvIHN0YXNoIHRoZSBwZW5kaW5nIGJ1ZmZlciBpbnRvIGxvY2FsU3RvcmFnZSwgYW5kIGZvciB0aGUgY2FzZVxuLy8gd2hlcmUgdGhleSBhcmUgbmF2aWdhdGluZyB0byBhbm90aGVyIHBhZ2Ugb24gdGhlIHNhbWUgc2l0ZSwgdGhleSBuZXcgcGFnZVxuLy8gY291bGQgdGhlbiBwaWNrIHVwIHRoYXQgYnVmZmVyIG9uIGxvYWQgYW5kIHNlbmQgaXQgYWxvbmcuXG4vL1xuU3RhdGUucHJvdG90eXBlLmZsdXNoQnVmZmVyID0gZnVuY3Rpb24oc3luY2hyb25vdXMsIGRvbmUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgZG9uZSA9IGRvbmUgfHwgZnVuY3Rpb24oZXJyKSB7fTtcblxuICAgIC8vIEVhcmx5IG91dCBpZiB0aGVyZSdzIG5vdGhpbmcgdG8gZG8gb3Igd2FpdGluZyBvbiBhbiBleGlzdGluZyBmbHVzaFxuICAgIGlmICghdGhpcy5lbmFibGVkKSB7XG4gICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZmx1c2hBY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnJ1bnRpbWUuZ3JvdXBfbmFtZSkge1xuICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucnVudGltZS5ndWlkKSB7XG4gICAgICAgIGlmIChERUJVRykge1xuICAgICAgICAgICAgX2Vycm9yKFwicnVudGltZS5ncm91cF9uYW1lIGlzIHNldCBidXQgcnVudGltZS5ndWlkIGlzIGludmFsaWQhXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgfVxuXG4gICAgdGhpcy5lbnN1cmVDbG9ja1N0YXRlSW5pdGlhbGl6ZWQoKTtcblxuICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgb2Zmc2V0IGluIGNhc2Ugd2UgbmVlZCB0byB1bmRvIHRoaXMgY29ycmVjdGlvblxuICAgIC8vIChpLmUuIGlmIHdlIHdlcmUgdG8gcHV0IHRoZW0gYmFjayBpbiB0aGUgcXVldWUpLlxuICAgIHZhciB0aW1lT2Zmc2V0TWljcm9zID0gMDtcbiAgICB2YXIgY2xvY2tSZWFkeSA9IHRoaXMuZGlzYWJsZUNsb2NrQ29ycmVjdGlvbiB8fCB0aGlzLmNsb2NrU3RhdGUuaXNSZWFkeSgpO1xuICAgIGlmICghdGhpcy5kaXNhYmxlQ2xvY2tDb3JyZWN0aW9uKSB7XG4gICAgICAgIHRpbWVPZmZzZXRNaWNyb3MgPSB0aGlzLmNsb2NrU3RhdGUub2Zmc2V0TWljcm9zKCk7XG4gICAgICAgIHRoaXMubG9nRXZlbnQoXCJjci90aW1lX2NvcnJlY3Rpb25fc3RhdGVcIiwge1xuICAgICAgICAgICAgXCJvZmZzZXRfbWljcm9zXCIgOiB0aW1lT2Zmc2V0TWljcm9zLFxuICAgICAgICAgICAgXCJhY3RpdmVfc2FtcGxlc1wiIDogdGhpcy5jbG9ja1N0YXRlLmFjdGl2ZVNhbXBsZXMoKSxcbiAgICAgICAgICAgIFwicmVhZHlcIiA6IGNsb2NrUmVhZHksXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChjbG9ja1JlYWR5ICYmIHRoaXMubG9ncy5sZW5ndGggPT09IDAgJiYgdGhpcy5zcGFucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5jb3VudGVycy5mbHVzaF93aXRoX25vX2RhdGErKztcbiAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICB9XG5cbiAgICB0aGlzLmVuc3VyZUNsaWVudENvbm5lY3Rpb25TdGFydGVkKCk7XG4gICAgdmFyIHJlcSA9IHRoaXMucmV1c2FibGUucmVwb3J0UmVxdWVzdDtcblxuICAgIC8vIEFsbG93IGEgc3luY2hyb25vdXMgcmVxdWVzdCBhcyBhbiBvcHRpb24gZm9yIHRoZSB1bmxvYWQgY2FzZSB3aGVyZVxuICAgIC8vIHdlIHJlYWxseSB3YW50IHRvIGNyYW0gdGhhdCBkYXRhIGFjcm9zcyB0aGUgd2lyZSBiZWZvcmUgdGhlIHVzZXJcbiAgICAvLyBsZWF2ZXMgdGhlIHBhZ2UhXG4gICAgc3luY2hyb25vdXMgPSBzeW5jaHJvbm91cyB8fCBmYWxzZTtcblxuICAgIC8vIE9ubHkgc2VuZCB0aGUgZGF0YSBpZiB0aGUgY2xvY2sgaXMgY29ycmVjdGVkIG9yIGlmIHRoaXMgaXMgXCJzeW5jaHJvbm91cy5cIlxuICAgIHZhciBzZW5kTG9nc0FuZFNwYW5zID0gY2xvY2tSZWFkeSB8fCBzeW5jaHJvbm91cztcbiAgICBpZiAoc2VuZExvZ3NBbmRTcGFucykge1xuICAgICAgICByZXEuc3Bhbl9yZWNvcmRzID0gdGhpcy5zcGFucztcbiAgICAgICAgcmVxLmxvZ19yZWNvcmRzID0gdGhpcy5sb2dzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcS5zcGFuX3JlY29yZHMgPSBbXTtcbiAgICAgICAgcmVxLmxvZ19yZWNvcmRzID0gW107XG4gICAgfVxuXG4gICAgLy8gU2V0IHRoZSBydW50aW1lX2d1aWQgaGVyZSBhcyBsb2cgcmVjb3JkcyBtYXkgY29tZSBpbiBkdXJpbmcgdGhlXG4gICAgLy8gY3J1bnRpbWUgaW5pdGlhbGl6YXRpb24sIHdoZXJlYXMgdGhlIEdVSUQgaXMgZGVmaW5pdGVseSBzZXQgYnkgdGhlXG4gICAgLy8gZmlyc3QgZmx1c2ggb3BlcmF0aW9uXG4gICAgdmFyIGd1aWQgPSB0aGlzLnJ1bnRpbWUuZ3VpZDtcbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcmVxLmxvZ19yZWNvcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlcS5sb2dfcmVjb3Jkc1tpXS5ydW50aW1lX2d1aWQgPSBndWlkO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgcmVxLnNwYW5fcmVjb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXEuc3Bhbl9yZWNvcmRzW2ldLnJ1bnRpbWVfZ3VpZCA9IGd1aWQ7XG4gICAgfVxuXG4gICAgdGhpcy5yZXBvcnRZb3VuZ2VzdE1pY3JvcyA9IHRoaXMubm93TWljcm9zKCk7XG5cbiAgICByZXEucnVudGltZSA9IHRoaXMucnVudGltZTtcbiAgICByZXEudGltZXN0YW1wX29mZnNldF9taWNyb3MgPSB0aW1lT2Zmc2V0TWljcm9zO1xuICAgIHJlcS5vbGRlc3RfbWljcm9zID0gdGhpcy5yZXBvcnRPbGRlc3RNaWNyb3M7XG4gICAgcmVxLnlvdW5nZXN0X21pY3JvcyA9IHRoaXMucmVwb3J0WW91bmdlc3RNaWNyb3M7XG5cbiAgICAvLyBDb252ZXJ0IHRoZSBkaXNjYXJkZWQgbG9nIHJlY29yZCBzYW1wbGUgY291bnRzIHRvIHRocmlmdFxuICAgIC8vXG4gICAgLy8gVE9ETzogY29udmVydCB0aGlzIGNvZGUgdG8gdXNlIFJlcG9ydFJlcXVlc3QuY291bnRlcnNcbiAgICAvL1xuICAgIHZhciBrZXk7XG4gICAgdmFyIGJ1Y2tldE1hZyA9IHRoaXMuZGlzY2FyZGVkTG9nU2FtcGxlcy5tYWduaXR1ZGU7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5kaXNjYXJkZWRMb2dTYW1wbGVzLmJ1Y2tldHMpIHtcbiAgICAgICAgdmFyIHRocmlmdF9idWNrZXQgPSBuZXcgY3JvdXRvbl90aHJpZnQuU2FtcGxlQ291bnQoKTtcbiAgICAgICAgdGhyaWZ0X2J1Y2tldC5vbGRlc3RfbWljcm9zID0ga2V5ICogYnVja2V0TWFnO1xuICAgICAgICB0aHJpZnRfYnVja2V0LnlvdW5nZXN0X21pY3JvcyA9IHRocmlmdF9idWNrZXQub2xkZXN0X21pY3JvcyArIGJ1Y2tldE1hZztcbiAgICAgICAgdGhyaWZ0X2J1Y2tldC5jb3VudCA9IHRoaXMuZGlzY2FyZGVkTG9nU2FtcGxlcy5idWNrZXRzW2tleV07XG4gICAgfVxuXG4gICAgaWYgKERFQlVHKSB7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHJlcS5ydW50aW1lLmd1aWQsIFwiUnVudGltZXMgcmVxdWlyZSBhIEdVSURcIik7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHJlcS5ydW50aW1lLmdyb3VwX25hbWUsIFwiUnVudGltZXMgcmVxdWlyZSBhIGdyb3VwX25hbWVcIik7XG4gICAgfVxuXG4gICAgLy8gQ29udmVydCB0aGUgY291bnRlcnNcbiAgICAvL1xuICAgIC8vIFRPRE86IHdvdWxkIGJlIG5pY2UgdG8gcmV1c2Ugb2JqZWN0cyB0byBhdm9pZCB0aGUgZHluYW1pYyBhbGxvY2F0aW9uc1xuICAgIC8vIG1ha2UgaGVyZS4gU2F2aW5nIHRoYXQgb3B0aW1pemF0aW9uIGZvciBhIGxhdGVyIGRheS5cbiAgICB2YXIgdGhyaWZ0Q291bnRlcnMgPSBbXTtcbiAgICBmb3IgKGtleSBpbiB0aGlzLmNvdW50ZXJzKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuY291bnRlcnNba2V5XTtcbiAgICAgICAgaWYgKHZhbHVlID4gMCkge1xuICAgICAgICAgICAgdGhyaWZ0Q291bnRlcnMucHVzaChuZXcgY3JvdXRvbl90aHJpZnQuTmFtZWRDb3VudGVyKHtcbiAgICAgICAgICAgICAgICBOYW1lICA6IGtleSxcbiAgICAgICAgICAgICAgICBWYWx1ZSA6IHZhbHVlLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0aHJpZnRDb3VudGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlcS5jb3VudGVycyA9IHRocmlmdENvdW50ZXJzO1xuICAgIH1cblxuXG4gICAgLy8gVEw7RFI6IHdyaXRpbmcgYSBjdXN0b20gdGhyaWZ0LmpzIHdvdWxkbid0IGJlIHN1Y2ggYSBiYWQgaWRlYS5cbiAgICAvL1xuICAgIC8vIENBUkVGVUwgIzE6IHRoZSBvYmplY3QgcGFzc2VkIHRvIHRoZSBjYWxsYmFjayBhcyBhcmcgMSBpcyBlaXRoZXIgdGhlXG4gICAgLy8gcmVzcG9uc2Ugb2JqZWN0IGluIHRoZSBjYXNlIG9mIHN1Y2Nlc3MsIG9yIHRoZSBlcnJvciB3aGljaCBnbGFuY2luZyBhdFxuICAgIC8vIHRoZSBKUyBsaWJyYXJ5IGlzIGVpdGhlciBhIHN0cmluZyBvciBhIFRocmlmdC5UQXBwbGljYXRpb25FeGNlcHRpb24gKG9yXG4gICAgLy8gY29uY2VpdmFibHkgYW55IGtpbmQgb2YgcmFuZG9tIGV4Y2VwdGlvbiB0aGF0IGNvdWxkIGJlIHRocm93biBkdXJpbmdcbiAgICAvLyBwcm9jZXNzaW5nKS4gIEluIG90aGVyIHdvcmRzLCBpdCdzIHByb2JhYmx5IGJlc3QgdG8gY2hlY2sgdGhhdCByZXNcbiAgICAvLyBhZ2FpbnN0IHRoZSBleHBlY3RlZCBpbnN0YW5jZW9mIHR5cGUgcmF0aGVyIHRoYW4gY2hlY2tpbmcgZm9yIGFuXG4gICAgLy8gZXJyb3IgdHlwZS4gIFNpZ2gsIHdoeSBkaWRuJ3QgdGhleSBqdXN0IHVzZSB0aGUgbW9yZSBzdGFuZGFyZFxuICAgIC8vIGZ1bmN0aW9uKGVyciwgcmVzKSBjb252ZW50aW9uPz9cbiAgICAvL1xuICAgIC8vIENBUkVGVUwgIzI6IGV2ZW4gaWYgdGhlIGNhbGxiYWNrIGlzIGV2ZW50dWFsbHkgYSBuby1vcCwgaXQgc3RpbGwgbmVlZHNcbiAgICAvLyB0byBiZSBwYXNzZWQgaW50byB0aGUgY2FsbCBhcyB0aGUgcHJlc2VuY2Ugb2YgdGhlIGNhbGxiYWNrIGlzIGhvd1xuICAgIC8vIHRocmlmdCBkZXRlcm1pbmVzIGlmIGl0IHNob3VsZCBiZSBhIHN5bmNocm9ub3VzIG9yIGFzeWNocm9ub3VzIGNhbGwuXG4gICAgLy9cbiAgICAvLyBCb3RoIHRoZSBhYm92ZSBwcm9ibGVtcyBjb3VsZCBiZSBzb2x2ZWQgd2l0aCBtaW5vciBtb2RpZmljYXRpb25zIHRvXG4gICAgLy8gdGhyaWZ0LmpzIGJ1dCB0aGVuIG1lYW5zIGNvbW1pdGluZyB0byBhIGZvcmtlZCB2ZXJzaW9uLlxuICAgIC8vXG5cbiAgICAvLyBSZWxlYXNlIHRoZSBpbi1tZW1vcnkgb2JqZWN0cyBvbmNlIHRoZSByZXF1ZXN0IGdvZXMgdGhyb3VnaC5cbiAgICBpZiAoREVCVUcpIHtcbiAgICAgICAgY29uc29sZS5hc3NlcnQoIXRoaXMuZmx1c2hBY3RpdmUsIFwiRmx1c2ggYWxyZWFkeSBhY3RpdmUhXCIpO1xuICAgIH1cbiAgICB0aGlzLmZsdXNoQWN0aXZlID0gdHJ1ZTtcblxuICAgIHRyeSB7XG4gICAgICAgIHZhciBvcmlnaW5NaWNyb3MgPSBzZWxmLm5vd01pY3JvcygpO1xuXG4gICAgICAgIHRoaXMuaW52b2tlUmVwb3J0KHN5bmNocm9ub3VzLCByZXEsIGZ1bmN0aW9uIChlcnIsIHJlcykge1xuXG4gICAgICAgICAgICBpZiAoZXJyICYmIGVyci5jb2RlID09IFwiREVQVEhfWkVST19TRUxGX1NJR05FRF9DRVJUXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoX29uY2UoZXJyLmNvZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIF9lcnJvcihcIkVycm9yIHNlbmRpbmcgcnVudGltZSBpbnN0cnVtZW50YXRpb24gcmVwb3J0OlwiLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICBfZXJyb3IoXCJDb25zaWRlciBzZXR0aW5nIHRoZSBydW50aW1lIG9wdGlvbiAnY2VydGlmaWNhdGVfdmVyaWZpY2F0aW9uJyB0byBmYWxzZSBpZiB5b3Ugd2lzaCB0byBpZ25vcmUgdGhpcyBlcnJvci5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGVzdGluYXRpb25fbWljcm9zID0gc2VsZi5ub3dNaWNyb3MoKTtcbiAgICAgICAgICAgIHNlbGYuZmx1c2hBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnJlcG9ydE9sZGVzdE1pY3JvcyA9IHNlbGYubm93TWljcm9zKCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmVwb3J0WW91bmdlc3RNaWNyb3MgPSBzZWxmLnJlcG9ydE9sZGVzdE1pY3JvcztcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb3VudGVycyBhcmUgZm9yIHRoZSByZXBvcnQgaW50ZXJ2YWwgYW5kIHRodXMgYWxsIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAvLyBhcmUgcmVzZXQgYWZ0ZXIgdGhlIHN1Y2Nlc3NmdWwgcmVwb3J0LlxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc2VsZi5jb3VudGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb3VudGVyc1trZXldID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZW1pdFNwYW5zUmVjb3JkZWRFdmVudChyZXEuc3Bhbl9yZWNvcmRzLCB0aW1lT2Zmc2V0TWljcm9zLCBzeW5jaHJvbm91cyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcy5jb21tYW5kcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXMuY29tbWFuZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY21kID0gcmVzLmNvbW1hbmRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY21kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY21kLmRpc2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5vcHRpb25zKHsgZW5hYmxlIDogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcy50aW1pbmcgJiYgcmVzLnRpbWluZy5yZWNlaXZlX21pY3JvcyAmJiByZXMudGltaW5nLnRyYW5zbWl0X21pY3Jvcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jbG9ja1N0YXRlLmFkZFNhbXBsZShvcmlnaW5NaWNyb3MsIHJlcy50aW1pbmcucmVjZWl2ZV9taWNyb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy50aW1pbmcudHJhbnNtaXRfbWljcm9zLCBkZXN0aW5hdGlvbl9taWNyb3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlbGVhc2VBcnJheXMocmVxLmxvZ19yZWNvcmRzLCByZXEuc3Bhbl9yZWNvcmRzKTtcbiAgICAgICAgICAgICAgICBpZiAoIXNlbmRMb2dzQW5kU3BhbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIGEgc3BlY2lhbCBlcnJvciBzbyB0aGF0IHdlIGNhbiByZXRyeSBtb3JlXG4gICAgICAgICAgICAgICAgICAgIC8vIHF1aWNrbHkgKHNpbmNlIHdlIGRpZG4ndCBzZW5kIGFueSByZWFsIGRhdGEpLlxuICAgICAgICAgICAgICAgICAgICBkb25lKGtDbG9ja1N0YXRlTm90UmVhZHlFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYuY291bnRlcnMuZmx1c2hfZXJyb3JzKys7XG4gICAgICAgICAgICAgICAgaWYgKHNlbmRMb2dzQW5kU3BhbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSByZXN0b3JlIGlmIHdlIHRyaWVkIHRvIHNlbmQgc29tZXRoaW5nIGluIHRoZSBmaXJzdCBwbGFjZS5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZXN0b3JlUmVjb3Jkc0FmdGVyRXJyb3IocmVxLmxvZ19yZWNvcmRzLCByZXEuc3Bhbl9yZWNvcmRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRvbmUoZXJyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ2xlYXIgdGhlIGN1cnJlbnQgYnVmZmVycy4gIE5vdGU6IHRoaXMgaXMgbm90IHRoZSBzYW1lIHJlbGVhc2luZyB0aGVcbiAgICAgICAgLy8gb2JqZWN0cyB0aGVtc2VsdmVzIHdoaWNoIGlzIGhhbmRsZWQgYnkgcmVsZWFzZUFycmF5cygpLlxuICAgICAgICBpZiAoc2VuZExvZ3NBbmRTcGFucykge1xuICAgICAgICAgICAgdGhpcy5sb2dzID0gW107XG4gICAgICAgICAgICB0aGlzLnNwYW5zID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNjYXJkZWRMb2dTYW1wbGVzLmNsZWFyKCk7XG5cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHNlbGYuY291bnRlcnMuZmx1c2hfZXhjZXB0aW9ucysrO1xuXG4gICAgICAgIGlmICh0aGlzLmZsdXNoQWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZG9uZShlKTtcbiAgICB9XG59O1xuXG4vLyBFbWl0IGFuIGV2ZW50IGFib3V0IHRoZSBzcGFucyB0aGF0IHdlcmUganVzdCByZWNvcmRlZCAtLSBjdXJyZW50bHkgZm9yXG4vLyB0aGUgSFRNTCBkZWJ1Z2dpbmcgb3ZlcmxheS5cblN0YXRlLnByb3RvdHlwZS5lbWl0U3BhbnNSZWNvcmRlZEV2ZW50ID0gZnVuY3Rpb24oc3BhbnMsIHRpbWVPZmZzZXRNaWNyb3MsIHN5bmNocm9ub3VzKSB7XG4gICAgaWYgKCFzcGFucyB8fCBzcGFucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIE9ubHkgZG8gdGhpcyBpZiB0aGVyZSBpcyBhbiBhY3R1YWwgbGlzdGVuZXIsIHNpbmNlIHRoZSBjbG9uaW5nIGlzXG4gICAgLy8gcmVsYXRpdmVseSBleHBlbnNpdmUuXG4gICAgaWYgKCFFdmVudEVtaXR0ZXJNaW4ubGlzdGVuZXJDb3VudChzZWxmLCBcInNwYW5zX3JlY29yZGVkXCIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUaGUgc3BhbiBkYXRhIGlzICpjbG9uZWQqIGhlcmUgcmF0aGVyIHRoYW4gcmV1c2VkLCBhcyB0aGUgc3BhbiBvYmplY3RzXG4gICAgLy8gY29tZSBmcm9tIGEgcmV1c2FibGUgbWVtb3J5IHBvb2wuICBQYXNzaW5nIHRob3NlIG9iamVjdHMgZGlyZWN0bHkgdmlhXG4gICAgLy8gdGhlIGV2ZW50IHB1dHMgdGhlIG9iamVjdHMgb3V0c2lkZSB0aGUgbWVtb3J5IHBvb2wncyBjb250cm9sLlxuICAgIHZhciBldmVudFNwYW5zID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmVjb3JkID0gc3BhbnNbaV07XG4gICAgICAgIHZhciBqb2luX2lkcyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlY29yZC5qb2luX2lkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGpvaW5JZCA9IHJlY29yZC5qb2luX2lkc1tqXTtcbiAgICAgICAgICAgIGpvaW5faWRzW2pvaW5JZC5UcmFjZUtleV0gPSBqb2luSWQuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnRTcGFucy5wdXNoKHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgY2hlYXRpbmcgYSBsaXR0bGUgYml0LCBidXQgYmFrZSBpbiBhblxuICAgICAgICAgICAgLy8gYXNzdW1wdGlvbiBhYm91dCBob3cgdGhlIGRvd25zdHJlYW0gc2VydmljZSBpcyBnb2luZyB0b1xuICAgICAgICAgICAgLy8gYXBwbHkgdGhlIGNvcnJlY3Rpb24gYW5kIGFkZCB0aW1lT2Zmc2V0TWljcm9zIGhlcmUuXG4gICAgICAgICAgICBvbGRlc3RfbWljcm9zICAgOiByZWNvcmQub2xkZXN0X21pY3JvcyArIHRpbWVPZmZzZXRNaWNyb3MsXG4gICAgICAgICAgICB5b3VuZ2VzdF9taWNyb3MgOiByZWNvcmQueW91bmdlc3RfbWljcm9zICsgdGltZU9mZnNldE1pY3JvcyxcbiAgICAgICAgICAgIHNwYW5fbmFtZSAgICAgICA6IHJlY29yZC5zcGFuX25hbWUsXG4gICAgICAgICAgICBzcGFuX2d1aWQgICAgICAgOiByZWNvcmQuc3Bhbl9ndWlkLFxuICAgICAgICAgICAgam9pbl9pZHMgICAgICAgIDogam9pbl9pZHMsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFJlYWxseSB3ZSBzaG91bGQgd2FpdCB1bnRpbCB0aGUgc2VydmVyIGhhcyBpbmRleGVkIHRoaXNcbiAgICAvLyBzcGFuLCBpbnN0ZWFkIG9mIGp1c3QgdW50aWwgd2UgdGhpbmsgdGhlIHNlcnZlciBoYXNcbiAgICAvLyByZWNlaXZlZCBpdCwgYnV0IHRoaXMgaXMgYmV0dGVyIHRoYW4gbm90aGluZy5cbiAgICBpZiAoc3luY2hyb25vdXMpIHtcbiAgICAgICAgc2VsZi5lbWl0KFwic3BhbnNfcmVjb3JkZWRcIiwgZXZlbnRTcGFucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuZW1pdChcInNwYW5zX3JlY29yZGVkXCIsIGV2ZW50U3BhbnMpO1xuICAgICAgICB9LCAwKTtcbiAgICB9XG59O1xuXG4vLyBJbnRlbmRlZCB0byBiZSBjYWxsZWQgd2hlbiBhIHBhaXIgb2Ygc3BhbiBhbmQgbG9nIHJlY29yZCBhcnJheXMgZmFpbCB0b1xuLy8gcmVwb3J0IHByb3Blcmx5LiAgVGhpcyBhZGRzIHRoZW0gYmFjayBpbnRvIHRoZSBpbnRlcm5hbCBidWZmZXIgd2hpbGVcbi8vIHJlc3BlY3RpbmcgdGhlIGJ1ZmZlciBsaW1pdHMuXG4vL1xuLy8gVE9ETzogc29tZSBmb3JtIHNhbXBsaW5nIHJhdGhlciB0aGFuIGRpc2NhcmQgd291bGQgYmUgbmljZSBoZXJlLlxuU3RhdGUucHJvdG90eXBlLnJlc3RvcmVSZWNvcmRzQWZ0ZXJFcnJvciA9IGZ1bmN0aW9uKGxvZ3MsIHNwYW5zKSB7XG5cbiAgICBmdW5jdGlvbiBwcmVwZW5kT2Zmc2V0KGJ1ZmZlciwgcmVjb3JkcywgbWF4KSB7XG4gICAgICAgIHZhciBzcGFjZSA9IG1heCAtIGJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIGlmIChzcGFjZSA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCByZWNvcmRzLmxlbmd0aCAtIHNwYWNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZWNvcmRzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkaXNjYXJkID0gZmFsc2U7XG4gICAgdmFyIGxvZ09mZnNldCA9IHByZXBlbmRPZmZzZXQodGhpcy5sb2dzLCBsb2dzLCB0aGlzLmJ1ZmZlck1heExvZ1JlY29yZHMpO1xuICAgIHZhciBsb2dEaXNjYXJkID0gW107XG4gICAgaWYgKGxvZ09mZnNldCA8IGxvZ3MubGVuZ3RoKSB7XG4gICAgICAgIGxvZ0Rpc2NhcmQgPSBsb2dzLnNsaWNlKDAsIGxvZ09mZnNldCk7XG4gICAgICAgIHRoaXMubG9ncyA9IGxvZ3Muc2xpY2UobG9nT2Zmc2V0KS5jb25jYXQodGhpcy5sb2dzKTtcbiAgICAgICAgZGlzY2FyZCA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHNwYW5PZmZzZXQgPSBwcmVwZW5kT2Zmc2V0KHRoaXMuc3BhbnMsIHNwYW5zLCB0aGlzLmJ1ZmZlck1heFNwYW5SZWNvcmRzKTtcbiAgICB2YXIgc3BhbkRpc2NhcmQgPSBbXTtcbiAgICBpZiAoc3Bhbk9mZnNldCA8IHNwYW5zLmxlbmd0aCkge1xuICAgICAgICBzcGFuRGlzY2FyZCA9IHNwYW5zLnNsaWNlKDAsIHNwYW5PZmZzZXQpO1xuICAgICAgICB0aGlzLnNwYW5zID0gc3BhbnMuc2xpY2Uoc3Bhbk9mZnNldCkuY29uY2F0KHRoaXMuc3BhbnMpO1xuICAgICAgICBkaXNjYXJkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZGlzY2FyZCkge1xuICAgICAgICByZWxlYXNlQXJyYXlzKGxvZ0Rpc2NhcmQsIHNwYW5EaXNjYXJkKTtcbiAgICB9XG59O1xuXG4vLyBUT0RPOiB0aGUgY29ubmVjdGlvbiBpbml0aWFsaXphdGlvbiBuZWVkcyB0byBiZSBkZS1jb3VwbGVkIGZyb20gdGhlIGxvb3Bpbmdcbi8vIGxvZ2ljIGFzIGl0IGlzIGNvbmNlaXZhYmxlIHRoYXQgYSBjbGllbnQgbWlnaHQgd2FudCB0byBtYW51YWwgY29udHJvbCB0aGVcbi8vIGZsdXNoIGNhbGxzLlxuLy9cbi8vIFRPRE86IE92ZXJsYXBwaW5nIHdpdGggdGhlIHByaW9yIHRvZG8sIHRoaXMgbmVlZHMgdG8gY2hlY2sgaWYgdGhlIGxvb3AgaGFzXG4vLyBhbHJlYWR5IGJlZW4gc3RhcnRlZC5cbi8vXG5TdGF0ZS5wcm90b3R5cGUuZW5zdXJlRmx1c2hCdWZmZXJMb29wU3RhcnRlZCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgLy8gSWdub3JlIHJlZHVuZGFudCByZXF1ZXN0c1xuICAgIGlmICh0aGlzLnJlZnJlc2hMb29wQWN0aXZlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoREVCVUcpIHtcbiAgICAgICAgY29uc29sZS5hc3NlcnQodGhpcy5jbGllbnQgPT09IG51bGwsIFwiQ2xpZW50IGFscmVhZHkgaW5pdGlhbGl6ZWRcIik7XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMucmVmcmVzaExvb3BBY3RpdmUgPSB0cnVlO1xuXG4gICAgKGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgIHNlbGYuZmx1c2hCdWZmZXIoZmFsc2UsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgLy8gRXhwb25lbnRpYWxseSBiYWNrIG9mZiBvbiB0aGUgcmVmcmVzaCBsb29wIGlmIGVycm9ycyBhcmUgb2NjdXJyaW5nLlxuICAgICAgICAgICAgLy8gSWdub3JlIHRoZSBmaXJzdCBjb3VwbGUgZXJyb3JzOyB0aGVuIGV4cG9uZW50aWFsbHkgYmFjayBvZmYgdXAgdG8gYSBsaW1pdC5cbiAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyICE9IGtDbG9ja1N0YXRlTm90UmVhZHlFcnJvcikge1xuICAgICAgICAgICAgICAgIHNlbGYuZmx1c2hFcnJvckNvdW50Kys7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgY29uZGl0aW9uYWwgYmVsb3cgaXMgY29uc2VydmF0aXZlLiBUaGVyZSdzIG5vIFwic3BlY1wiIG9uIHdoYXQgZXJyXG4gICAgICAgICAgICAgICAgLy8gbWlnaHQgYmUgZm9yIGRlcGVuZGluZyBvbiB0aGUgcGxhdGZvcm0gYW5kIHdoZXJlIHRoZSBlcnJvciBvY2N1cnMgaW5cbiAgICAgICAgICAgICAgICAvLyBUaHJpZnQuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBBbHNvLCBzYWRseSBvbiB0aGUgYnJvd3NlciBzaWRlIHRoZXJlJ3Mgbm8gd2F5IHRvIGRpc3Rpbmd1aXNoIGFueSBraW5kXG4gICAgICAgICAgICAgICAgLy8gb2YgZXJyb3Igc28gd2UgaGF2ZSB0byBzd2FsbG93IGFsbCBicm93c2VyIGVycm9ycyB0byBwcmV2ZW50IHRoZSBicm93c2VyXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZSBiZWluZyBwb2xsdXRlZCBpZiB0aGUgY29ubmVjdGlvbiBjYW4ndCBiZSBtYWRlIHRvIG91ciBzZXJ2ZXIuXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuaXNOb2RlICYmIGVyci5jb2RlICE9IFwiRUNPTk5SRUZVU0VEXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5mbHVzaE5vbkNvbm5lY3RFcnJvckNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChERUJVRykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2Vycm9yKFwiZmx1c2hCdWZmZXIgZXJyb3I6XCIsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYuZmx1c2hFcnJvckNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICBzZWxmLmZsdXNoTm9uQ29ubmVjdEVycm9yQ291bnQgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXNlbGYuc2h1dHRpbmdEb3duKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyciA9PSBrQ2xvY2tTdGF0ZU5vdFJlYWR5RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGEgc2hvcnQgdGltZW91dCBmb3IgdGhpcyBjYXNlLlxuICAgICAgICAgICAgICAgICAgICBzZWxmLmZsdXNoVGltZXIgPSBzZXRUaW1lb3V0KGxvb3AsIGtDbG9ja1NhbXBsaW5nSW50ZXJ2YWxNcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhY2tPZmYgPSBNYXRoLnBvdygyLCBNYXRoLm1heCgwLCBNYXRoLm1pbig4LCBzZWxmLmZsdXNoRXJyb3JDb3VudCAtIDIpKSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZmx1c2hUaW1lciA9IHNldFRpbWVvdXQobG9vcCwgYmFja09mZiAqIHNlbGYucmVmcmVzaEludGVydmFsTXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE1ha2UgdGhlIHRpbWVyIGVmZmVjdGl2ZWx5IFwid2Vha1wiIGluIHRoZSBzZW5zZSB0aGF0IGEgcGVuZGluZyBjYWxsYmFjayB3aWxsXG4gICAgICAgICAgICAgICAgLy8gbm90IGtlZXAgdGhlIHByb2Nlc3MgYWxpdmUuXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS90aW1lcnMuaHRtbCN0aW1lcnNfdW5yZWZcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNlbGYuZmx1c2hUaW1lci51bnJlZiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZmx1c2hUaW1lci51bnJlZigpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFzIGEgcHJlY2F1dGlvbiBhZ2FpbnN0IHRoZSBUaHJpZnQgY29ubmVjdGlvbiBiZWluZyBpbiBhIHpvbWJpZSBzdGF0ZSxcbiAgICAgICAgICAgICAgICAvLyByZWNyZWF0ZSB0aGUgY2xpZW50IG9iamVjdCBhZnRlciByZXBlYXRlZCBmYWlsdXJlcy5cbiAgICAgICAgICAgICAgICB2YXIgbGltaXQgPSBrUmVzZXRDb25uZWN0aW9uRXZlcnlOdGhGbHVzaEVycm9yO1xuICAgICAgICAgICAgICAgIGlmICgoc2VsZi5mbHVzaE5vbkNvbm5lY3RFcnJvckNvdW50ICUgKGxpbWl0ICsgMSkpID09IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIF9lcnJvcihcImZsdXNoQnVmZmVyIGVycm9yIGxpbWl0IHJlYWNoZWQ6IHJlY3JlYXRpbmcgY2xpZW50IGNvbm5lY3Rpb24uXCIpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbm5lY3Rpb25PayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFzIGEgcHJlY2F1dGlvbiBhZ2FpbnN0IHRoZSBkYXRhIGl0c2VsZiBzb21laG93IHByZXZlbnRpbmcgdGhlIFJQQyBmcm9tXG4gICAgICAgICAgICAgICAgLy8gZ29pbmcgdGhyb3VnaCwgZGlzY2FyZCB0aGUgYnVmZmVycyBpZiBBIExPVCBvZiBmYWlsdXJlcyBoYXZlIG9jY3VycmVkIGluXG4gICAgICAgICAgICAgICAgLy8gYSByb3cuXG4gICAgICAgICAgICAgICAgbGltaXQgPSBrRGlzY2FyZERhdGFFdmVyeU50aEZsdXNoRXJyb3I7XG4gICAgICAgICAgICAgICAgaWYgKChzZWxmLmZsdXNoTm9uQ29ubmVjdEVycm9yQ291bnQgJSAobGltaXQgKyAxKSkgPT0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgX2Vycm9yKFwiZmx1c2hCdWZmZXIgZXJyb3IgbGltaXQgcmVhY2hlZDogZGlzY2FyZGluZyBidWZmZXJzLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kaXNjYXJkQnVmZmVycygpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoc2VsZi5mbHVzaFRpbWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSkoKTtcbn07XG5cblN0YXRlLnByb3RvdHlwZS5lbnN1cmVDbG9ja1N0YXRlSW5pdGlhbGl6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuY2xvY2tTdGF0ZSkge1xuICAgICAgICB0aGlzLmNsb2NrU3RhdGUgPSBuZXcgQ2xvY2tTdGF0ZSh0aGlzLnBsYXRmb3JtLCB0aGlzKTtcbiAgICB9XG59O1xuXG4vLyBDcmVhdGUgdGhlIFRocmlmdCBjbGllbnQgb2JqZWN0IGlmIGl0IGhhcyBub3QgeWV0IGJlZW4gY3JlYXRlZCBvciBpZiB0aGVcbi8vIGNvbm5lY3Rpb24gaGFzIGJlZW4gaW5kaWNhdGVkIGFzIGJlaW5nIG5vdCBva2F5LiAgSW4gdGhlIGNhc2UgdGhhdCB0aGUgY29ubmVjdGlvblxuLy8gaXMgb2ssIHRoaXMgaXMgYSBuby1vcC5cblN0YXRlLnByb3RvdHlwZS5lbnN1cmVDbGllbnRDb25uZWN0aW9uU3RhcnRlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICh0aGlzLmNvbm5lY3Rpb25Paykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVE9ETzogZW5jYXBzdWxhdGUgYWxsIHBsYXRmb3JtIGRpZmZlcmVuY2VzIGluIGEgc2VwYXJhdGUgcGFja2FnZVxuICAgIC8vIGFuZCBnZXQgcmlkIG9mIHRoZXNlIGlzTm9kZSBjaGVja3MuXG4gICAgaWYgKCF0aGlzLnBsYXRmb3JtLmlzTm9kZSkge1xuXG4gICAgICAgIC8vIE5vdGUgdGhpcyBpcyBpbXBsaWNpdGx5IHVzaW5nIHRoZSBKU09OIHByb3RvY29sIC0tIG5vdCB0aGUgYmluYXJ5IHByb3RvY29sLlxuICAgICAgICAvLyBUaGF0J3MgdGhlIGRlZmF1bHQgKGFuZCBvbmx5IHN1cHBvcnRlZCBKUyBwcm90b2NvbCBpbiAhaXNOb2RlKS5cbiAgICAgICAgdmFyIHNlcnZpY2VVcmwgPSBcImh0dHBzOi8vXCIgKyB0aGlzLnNlcnZpY2VIb3N0ICsgXCI6XCIgKyB0aGlzLnNlcnZpY2VQb3J0ICsgXCIvX3JwYy92MS9yZXBvcnRzL2pzb25cIjtcbiAgICAgICAgdmFyIHRyYW5zcG9ydCA9IG5ldyBUaHJpZnQuVHJhbnNwb3J0KHNlcnZpY2VVcmwpO1xuICAgICAgICB2YXIgcHJvdG9jb2wgID0gbmV3IFRocmlmdC5Qcm90b2NvbCh0cmFuc3BvcnQpO1xuICAgICAgICB0aGlzLmNsaWVudCAgID0gbmV3IGNyb3V0b25fdGhyaWZ0LlJlcG9ydGluZ1NlcnZpY2VDbGllbnQocHJvdG9jb2wpO1xuXG4gICAgICAgIC8vIFRoZSBjb25uZWN0aW9uIGlzIG9ubHkgc2V0IGZvciBOb2RlLmpzIGFzIGEgbWVhbnMgdG8gZm9yY2UgYSBzeW5jaHJvbm91cyBSUENcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gbnVsbDtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB0cmFuc3BvcnQgICA6IFRocmlmdC5UQnVmZmVyZWRUcmFuc3BvcnQsXG4gICAgICAgICAgICBwcm90b2NvbCAgICA6IFRocmlmdC5UQmluYXJ5UHJvdG9jb2wsXG4gICAgICAgICAgICBwYXRoICAgICAgICA6IFwiL19ycGMvdjEvcmVwb3J0cy9iaW5hcnlcIixcbiAgICAgICAgICAgIGh0dHBzICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG5vZGVPcHRpb25zIDoge30sXG4gICAgICAgIH07XG4gICAgICAgIGlmICghdGhpcy5jZXJ0aWZpY2F0ZVZlcmlmaWNhdGlvbikge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlcXVlc3QvcmVxdWVzdC9pc3N1ZXMvNDE4XG4gICAgICAgICAgICBvcHRpb25zLm5vZGVPcHRpb25zLnJlamVjdFVuYXV0aG9yaXplZCA9IGZhbHNlO1xuICAgICAgICAgICAgb3B0aW9ucy5ub2RlT3B0aW9ucy5zdHJpY3RTU0wgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IFRocmlmdC5jcmVhdGVIdHRwQ29ubmVjdGlvbih0aGlzLnNlcnZpY2VIb3N0LCB0aGlzLnNlcnZpY2VQb3J0LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBUaHJpZnQuY3JlYXRlSHR0cENsaWVudChjcm91dG9uX3RocmlmdC5SZXBvcnRpbmdTZXJ2aWNlQ2xpZW50LCB0aGlzLmNvbm5lY3Rpb24pO1xuXG4gICAgICAgIC8vIFBhdGNoIHRocmlmdCB3aXRoIHN1cHBvcnQgZm9yLCB3ZWxsLCB0aGUgbmFtZSBzYXlzIGl0Li4uXG4gICAgICAgIHNlbGYucGxhdGZvcm0ucGF0Y2hIdHRwQ29ubmVjdGlvbkZvclN5bmNocm9ub3VzUlBDKHRoaXMuY29ubmVjdGlvbik7XG5cbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAvLyBTZWUgY3JlYXRlQXN5bmNSUENBZGFwdGVyIGZvciBkZXRhaWxzXG4gICAgICAgICAgICBpZiAoc2VsZi50aHJpZnRIdHRwRXJyb3JDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHNlbGYudGhyaWZ0SHR0cEVycm9yQ2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX2Vycm9yKFwiVW5oYW5kbGVkIFRocmlmdCBlcnJvcjpcIiwgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gVGhlIHJlcG9ydGluZyBmdW5jdGlvbiBtaWdodCBiZSBub24tbnVsbCBhbHJlYWR5IGlmIGl0IGhhcyBiZWVuXG4gICAgLy8gbWFudWFsbHkgb3ZlcnJpZGRlbiwgZS5nLiBmb3IgdW5pdCB0ZXN0aW5nLiAgRG9uJ3QgY2xvYmJlciB0aGF0XG4gICAgLy8gdmFsdWUuXG4gICAgaWYgKCF0aGlzLmludm9rZVJlcG9ydCkge1xuICAgICAgICB0aGlzLmludm9rZVJlcG9ydCA9IHRoaXMuY3JlYXRlQXN5bmNSUENBZGFwdGVyKHRoaXMuY2xpZW50LlJlcG9ydCwgY3JvdXRvbl90aHJpZnQuUmVwb3J0UmVzcG9uc2UpO1xuICAgIH1cblxuICAgIHRoaXMuY29ubmVjdGlvbk9rID0gdHJ1ZTtcbn07XG5cbi8vIFJQQyBhZGFwdGVycyBzaW5jZSB0aHJpZnQgaGFzIGRpZmZlcmVudCBjYWxsaW5nIGNvbnZlbnRpb25zIGZvciB0aGVcbi8vIGJyb3dzZXIgYW5kIG5vZGUuanMuIChUaGlzIGlzICphbG1vc3QqIHN1ZmZpY2llbnRseSBhbm5veWluZyB0byBjb25zaWRlclxuLy8gZm9ya2luZyB0aHJpZnQgYW5kIGZpeGluZyB0aGlzIHBhcnRpY3VsYXIgcGllY2Ugb2YgcG9vciBkZXNpZ24uKVxuLy9cbi8vIFRoaXMgbm9ybWFsaXplcyBvbiBhIGZ1bmN0aW9uIChlcnIsIHJlcykgeyAuLi4gfSBzdHlsZSBjYWxsYmFjay5cbi8vXG4vLyBUT0RPOiBpdCBtaWdodCBiZSBuaWNlIHRvIGhpZGUgdGhpcyBpbiB0aGUgcGxhdGZvcm0tZGVwZW5kZW50IGNvZGUsIG5vdFxuLy8gaGVyZS4gIEJ1dCBpdCBpcyBsZXNzIGluZGlyZWN0aW9uIHRvIGp1c3QgZG8gaXQgaGVyZS5cbi8vXG5TdGF0ZS5wcm90b3R5cGUuY3JlYXRlQXN5bmNSUENBZGFwdGVyID0gZnVuY3Rpb24ocnBjLCByZXNwVHlwZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBjYWxsYmFja0FkYXB0ZXI7XG4gICAgaWYgKCF0aGlzLnBsYXRmb3JtLmlzTm9kZSkge1xuXG4gICAgICAgIC8vIEJyb3dzZXIgY2FzZS5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN5bmNocm9ub3VzLCByZXEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoREVCVUcpIHtcbiAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHNlbGYuYXV0aCAmJiBzZWxmLmF1dGguYWNjZXNzX3Rva2VuLCBcIkV4cGVjdGVkIGFjY2Vzc190b2tlblwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGhyaWZ0IGZ1biBmYWN0OiBhcyB3ZWxsIGFzIGhhdmluZyBtdWx0aXBsZSB3b3JrYXJvdW5kcyBmb3IgdGhlIHZhcmlvdXNcbiAgICAgICAgICAgIC8vIHdheXMgdGhyaWZ0IGRvZXMgYW5kIGRvZXNuJ3QgcmV0dXJuIGVycm9ycywgaXQncyBhbHNvIG5lY2Vzc2FyeSB0byBjaGVja1xuICAgICAgICAgICAgLy8gaWYgaXQgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzeW5jaHJvbm91cykge1xuICAgICAgICAgICAgICAgICAgICBycGMuY2FsbChzZWxmLmNsaWVudCwgc2VsZi5hdXRoLCByZXEsIGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHRocmlmdCBicm93c2VyLXNpZGUgY29udmVudGlvbiBoZXJlIGlzIGZydXN0cmF0aW5nLiBWYWxpZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzcG9uc2VzIGFuZCBlcnJvcnMgYXJlIG92ZXJsb2FkZWQgaW50byB0aGUgc2FtZSB2YXJpYWJsZSBhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gYmUgZGlmZmVyZW50aWF0ZWQgYnkgYSB0eXBlLWNoZWNrLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocmVzIGluc3RhbmNlb2YgcmVzcFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socmVzLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU28gXCJzeW5jaHJvbm91c1wiIGhhcyBldm9sdmVkIGludG8gYSBtaXNub21lciBhdCB0aGlzIHBvaW50Li4uLlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmVhbCBpbnRlbnQgaXMgd2hhdCBtaWdodCBiZSBjYWxsZWQgYSBcInRhaWwgZmx1c2hcIiAtLSBhXG4gICAgICAgICAgICAgICAgICAgIC8vIGZsdXNoIGJlZm9yZSB0aGUgcnVudGltZSBleGl0cyB0aGF0IHNob3VsZCBub3QgYmUgaW50ZXJydXB0ZWQuXG4gICAgICAgICAgICAgICAgICAgIC8vIE9uIHRoZSBicm93c2VyIHNpZGUsIHdoYXQgdGhpcyBtZWFucyBpcyBzZXR0aW5nIHVwIGFuIGFzeW5jLFxuICAgICAgICAgICAgICAgICAgICAvLyBkZWZlcnJlZCBVUkktZW5jb2RlZCByZXBvcnQgdGhhdCAqaXMqIGFzeW5jLCBidXQgd2lsbCBub3QgYmVcbiAgICAgICAgICAgICAgICAgICAgLy8gaW50ZXJydXB0ZWQgYXMgYSBub3JtYWwgYXN5bmMgWEhSIG1pZ2h0IGJlIHdoZW4gdGhlIHBhZ2UgaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gbmF2aWdhdGVkIGF3YXkgZnJvbS5cblxuICAgICAgICAgICAgICAgICAgICB2YXIgYXV0aEpTT04gICA9IEpTT04uc3RyaW5naWZ5KHNlbGYuYXV0aCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXBvcnRKU09OID0gSlNPTi5zdHJpbmdpZnkocmVxKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdXJsID0gXCJodHRwczovL1wiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2VydmljZUhvc3QgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCI6XCIgKyBzZWxmLnNlcnZpY2VQb3J0ICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiL19ycGMvdjEvcmVwb3J0cy91cmlfZW5jb2RlZFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiP2F1dGg9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoYXV0aEpTT04pICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiJnJlcG9ydD1cIiArIGVuY29kZVVSSUNvbXBvbmVudChyZXBvcnRKU09OKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICAgICAgICAgIGVsZW0uYXN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBlbGVtLmRlZmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5zcmMgPSB1cmw7XG4gICAgICAgICAgICAgICAgICAgIGVsZW0udHlwZSA9IFwidGV4dC9qYXZhc2NyaXB0XCI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBob3N0RWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhvc3RFbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0RWxlbS5hcHBlbmRDaGlsZChlbGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlZmVyZW5jZSBjb2RlIGZvciBtYWtpbmcgYSBzeW5jaHJvbm91cyBUaHJpZnQgY2FsbC4gIE5vdGUgdGhhdFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdvdWxkIGJsb2NrIChub3Qgc3VycHJpc2luZ2x5KSB3aGljaCB3YXMgcHJvYmxlbWF0aWMgaWYgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyYWNlZ3VpZGUgc2VydmVyIHdhcyBib2dnZWQgZG93biBhcyB0aGUgY2xpZW50IGhhZCB0byB3YWl0IGZvclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgdGltZW91dC5cbiAgICAgICAgICAgICAgICAgICAgLyp2YXIgcmVzID0gcnBjLmNhbGwoc2VsZi5jbGllbnQsIHNlbGYuYXV0aCwgcmVxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocmVzIGluc3RhbmNlb2YgcmVzcFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2socmVzLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXMpO1xuICAgICAgICAgICAgICAgICAgICB9Ki9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBOb2RlLmpzIGNhc2UuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihzeW5jaHJvbm91cywgcmVxLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKERFQlVHKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoc2VsZi5hdXRoICYmIHNlbGYuYXV0aC5hY2Nlc3NfdG9rZW4sIFwiRXhwZWN0ZWQgYWNjZXNzX3Rva2VuXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBUkdIOiB0aGUgVGhyaWZ0IE5vZGUgSHR0cENvbm5lY3Rpb24gZG9lcyBOT1QgY2FsbCB0aGUgY2FsbGJhY2sgb24gYW5cbiAgICAgICAgICAgIC8vIEhUVFAgZXJyb3IgKGUuZy4gRUNPTk5SRUZVU0VEKS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUaGUgd29ya2Fyb3VuZCBpcyBmcmFnaWxlIGFuZCBkZXBlbmRzIG9uIGhvdyB0aGUgc3Vycm91bmRpbmcgY29kZSB3b3Jrcy5cbiAgICAgICAgICAgIC8vIFdlIGRvIGhhdmUgYSBob29rIGludG8gKmFueSogaHR0cCBlcnJvciB2aWEgdGhlIFRocmlmdC5IdHRwQ29ubmVjdGlvblxuICAgICAgICAgICAgLy8gb2JqZWN0LCB3aGljaCBpbiBhIHRvdGFsbHkgc2VyaWFsIHJlcS9yZXNwIGNoYWluIGlzIHN1ZmZpY2llbnQgdG9cbiAgICAgICAgICAgIC8vIGNvcnJlY3RseSBjYWxsIHRoZSBjYWxsYmFjazsgaG93ZXZlciwgaW4gdGhlIGNhc2Ugb2YgcGFyYWxsZWwgY2FsbHMgd2hlcmVcbiAgICAgICAgICAgIC8vIHR3byByZXF1ZXN0cyBnbyBvdXQsIGhvdyBkbyB3ZSBrbm93IHdoaWNoIHJlcXVlc3QgdHJpZ2dlcmVkIHRoZSBlcnJvcj9cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUaGUgY3J1bnRpbWUgY29kZSBob3dldmVyIGlzIGN1cnJlbnRseSBzZXJpYWwgaW4gc2VuZGluZyBpdHMgcmVwb3J0c1xuICAgICAgICAgICAgLy8gKGl0IHBvc3Rwb25lcyBzdWJzZXF1ZW50IHJlcG9ydHMgdW50aWwgaXQgaGVhcnMgYmFjayBhYm91dCB0aGUgbGFzdFxuICAgICAgICAgICAgLy8gb25lKSAtLSBzbyB3ZSBjYW4gdGFrZSBhZHZhbnRhZ2Ugb2YgdGhlIGVycm9yIGNvbWluZyBpbiBzZXJpYWxseSBhc1xuICAgICAgICAgICAgLy8gd2VsbC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBGb3Igd2hhdCBpdCdzIHdvcnRoLCB0aGlzIGlzIG5vdCB0cml2aWFsIHRvIGZpeCBpbiB0aGUgdGhyaWZ0IGNvZGUgYXNcbiAgICAgICAgICAgIC8vIHRoZSBIdHRwQ29ubmVjdGlvbiBjbGFzcyBoYXMgbm8ga25vd2xlZGdlIG9mIHRoZSBpbmNvbWluZyByZXF1ZXN0IGFuZFxuICAgICAgICAgICAgLy8gd2hlcmUgaXQgd291bGQgcmVwb3J0IHRoZSBlcnJvciB0by5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyA8cmFudCB0YXJnZXQ9XCJ0aHJpZnRfZGV2XCI+QWx3YXlzIGNhbGwgdGhlIGNhbGxiYWNrIGlmIHlvdSB3cml0ZSBhIGZ1bmN0aW9uXG4gICAgICAgICAgICAvLyB0aGF0IHRha2VzIGNhbGxiYWNrLCBvdGhlcndpc2UgeW91IG1ha2UgaXQgaW1wb3NzaWJsZSBmb3IgY2FsbGVycyB0b1xuICAgICAgICAgICAgLy8gcHJvcGVybHkgbWFuYWdlIGNvbnRyb2wgZmxvdyEhITwvcmFudD5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICB2YXIgZXJyb3JIYW5kbGluZ0NhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi50aHJpZnRIdHRwRXJyb3JDYWxsYmFjayA9IG51bGw7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzZWxmLnRocmlmdEh0dHBFcnJvckNhbGxiYWNrID0gZXJyb3JIYW5kbGluZ0NhbGxiYWNrO1xuXG4gICAgICAgICAgICAvLyBQYXRjaCAjMiBmb3Igc3luY2hyb25vdXMgUlBDcy4gIFRoaXMgaXMgbm90IHZhbmlsbGEgdGhyaWZ0LlxuICAgICAgICAgICAgc2VsZi5jb25uZWN0aW9uLnN5bmNocm9ub3VzUlBDID0gc3luY2hyb25vdXM7XG5cbiAgICAgICAgICAgIHJwYy5jYWxsKHNlbGYuY2xpZW50LCBzZWxmLmF1dGgsIHJlcSwgZXJyb3JIYW5kbGluZ0NhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG4vLyBEaXNjYXJkIGFueSB1bmZsdXNoZWQgZGF0YSBjdXJyZW50bHkgaW4gdGhlIGJ1ZmZlcnNcblN0YXRlLnByb3RvdHlwZS5kaXNjYXJkQnVmZmVycyA9IGZ1bmN0aW9uKCkge1xuICAgIHJlbGVhc2VBcnJheXModGhpcy5sb2dzLCB0aGlzLnNwYW5zKTtcbiAgICB0aGlzLmxvZ3MgPSBbXTtcbiAgICB0aGlzLnNwYW5zID0gW107XG59O1xuXG4vLyBJbnRlbmRlZCBmb3IgaW50ZXJuYWwgdXNlIG9ubHkgZm9yIGRlYnVnZ2luZy5cblN0YXRlLnByb3RvdHlwZS5yZXNldE9iamVjdFBvb2xzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5sb2dzID0gW107XG4gICAgdGhpcy5zcGFucyA9IFtdO1xuICAgIHBvb2wubG9nUmVjb3Jkcy5yZXNldCgpO1xuICAgIHBvb2wuc3BhblJlY29yZHMucmVzZXQoKTtcbiAgICBwb29sLnRyYWNlSm9pbklkcy5yZXNldCgpO1xufTtcblxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuLy8gTG9nc1xuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuXG4vLyBcIlBsYWluXCIgaW4gdGhlIHNlbnNlIHRoYXQgaXQgZ29lcyBzdHJhaWdodCB0byB0aGUgb3JpZ2luYWwgY29uc29sZS5sb2csXG4vLyByZWdhcmRsZXNzIG9mIHRoZSBjcnVudGltZSBzZXR0aW5ncy5cblN0YXRlLnByb3RvdHlwZS5wbGFpbkxvZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBvcmlnaW5hbENvbnNvbGVfbG9nLmFwcGx5KG9yaWdpbmFsQ29uc29sZSwgYXJndW1lbnRzKTtcbn07XG5cbi8vIFwiUGxhaW5cIiBpbiB0aGUgc2Vuc2UgdGhhdCBpdCBnb2VzIHN0cmFpZ2h0IHRvIHRoZSBvcmlnaW5hbCBjb25zb2xlLndhcm4sXG4vLyByZWdhcmRsZXNzIG9mIHRoZSBjcnVudGltZSBzZXR0aW5ncy5cblN0YXRlLnByb3RvdHlwZS5wbGFpbldhcm4gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gb3JpZ2luYWxDb25zb2xlX3dhcm4uYXBwbHkob3JpZ2luYWxDb25zb2xlLCBhcmd1bWVudHMpO1xufTtcblxuLy8gXCJQbGFpblwiIGluIHRoZSBzZW5zZSB0aGF0IGl0IGdvZXMgc3RyYWlnaHQgdG8gdGhlIG9yaWdpbmFsIGNvbnNvbGUuZXJyb3IsXG4vLyByZWdhcmRsZXNzIG9mIHRoZSBjcnVudGltZSBzZXR0aW5ncy5cblN0YXRlLnByb3RvdHlwZS5wbGFpbkVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG9yaWdpbmFsQ29uc29sZV9lcnJvci5hcHBseShvcmlnaW5hbENvbnNvbGUsIGFyZ3VtZW50cyk7XG59O1xuXG5mdW5jdGlvbiBjb2VyY2VTdHJpbmcob2JqLCBmaWVsZE5hbWUpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmpbZmllbGROYW1lXTtcbiAgICBpZiAodHlwZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICh0eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG9ialtmaWVsZE5hbWVdID0gKFwiXCIgKyBvYmpbZmllbGROYW1lXSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc051bWJlck9yVW5kZWZpbmVkKHZhbCkge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgICByZXR1cm4gKHR5cGUgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZSA9PT0gXCJudW1iZXJcIik7XG59XG5mdW5jdGlvbiBpc0Jvb2xlYW5PclVuZGVmaW5lZCh2YWwpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gICAgcmV0dXJuICh0eXBlID09PSBcInVuZGVmaW5lZFwiIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiKTtcbn1cbmZ1bmN0aW9uIGlzU3RyaW5nT3JVbmRlZmluZWQodmFsKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICAgIHJldHVybiAodHlwZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlID09PSBcInN0cmluZ1wiKTtcbn1cblxuXG5TdGF0ZS5wcm90b3R5cGUucmF3TG9nUmVjb3JkID0gZnVuY3Rpb24gKGZpZWxkcykge1xuICAgIGlmIChERUJVRykge1xuICAgICAgICBjb25zb2xlLmFzc2VydCh0aGlzLnJ1bnRpbWUsIFwiUnVudGltZSBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgcHJvcGVybHlcIik7XG4gICAgfVxuICAgIGlmICghdGhpcy5lbmFibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNydW50aW1lQWN0aXZlKys7XG5cbiAgICAvLyBUaHJpZnQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBvbiB0eXBlIG1pc21hdGNoZXMgYW5kIGl0J3MgZGlmZmljdWx0IHRvXG4gICAgLy8gZGV0ZXJtaW5lIHdoYXQgcmVjb3JkIG9yIGZpZWxkIGNvbnRhaW5lZCB0aGUgbWlzbWF0Y2gsIHNvIGNvZXJjZSB0aGVtXG4gICAgLy8gYWxsIGhlcmUuIFRoaXMgY29kZSBoYXMgdG8gYmUga2VwdCBpbiBzeW5jIHdpdGggY2hhbmdlcyB0byBjcm91dG9uLnRocmlmdCxcbiAgICAvLyBzaWdoLi4uXG5cbiAgICAvLyBCZSBuaWNlIGFuZCBjb2VyY2UgdGhlc2UgZmllbGRzIHdoaWNoIG1heSBiZSBjb21pbmcgZnJvbSB0aGUgY3VzdG9tZXIgYW5kXG4gICAgLy8gaXQncyBlYXN5IHRvIGNvbnZlcnQgdGhlbSBjb3JyZWN0bHkgdG8gc3RyaW5nIGZvcm06XG4gICAgY29lcmNlU3RyaW5nKGZpZWxkcywgIFwicnVudGltZV9ndWlkXCIpO1xuICAgIGNvZXJjZVN0cmluZyhmaWVsZHMsICBcInNwYW5fZ3VpZFwiKTtcbiAgICBjb2VyY2VTdHJpbmcoZmllbGRzLCAgXCJzdGFibGVfbmFtZVwiKTtcbiAgICBjb2VyY2VTdHJpbmcoZmllbGRzLCAgXCJtZXNzYWdlXCIpO1xuICAgIGNvZXJjZVN0cmluZyhmaWVsZHMsICBcImZpbGVuYW1lXCIpO1xuXG4gICAgLy8gQ29lcmNlIHRoZSB0aW1lc3RhbXAgbWljcm9zIHRvIGFuIGludGVnZXIuIEZvciBleGFtcGxlLCBTYWZhcmknc1xuICAgIC8vIHBlcmZvcm1hbmNlIEFQSSBpbXBsZW1lbnRhdGlvbiBzb21ldGltZXMgcmV0dXJucyBkZWNpbWFsIHZhbHVlcy5cbiAgICAvL1xuICAgIC8vIEEgY291cGxlIG5vdGVzOlxuICAgIC8vIC0gcGFyc2VJbnQoKSBpcyBub3QgdXNlZCBoZXJlIGFzIHRpbWVzdGFtcF9taWNyb3MgaXMgc3VwcG9zZWQgdG8gYmVcbiAgICAvLyAgIHNldCBpbnRlcm5hbGx5OyB3ZSdyZSBqdXN0IGJlaW5nIGEgbGl0dGxlIHBhcmFub2lkIGFib3V0IGRlY2ltYWxzXG4gICAgLy8gICBwb3NzaWJseSBzbmVha2luZyBpbi5cbiAgICBpZiAodHlwZW9mIGZpZWxkcy50aW1lc3RhbXBfbWljcm9zID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgZmllbGRzLnRpbWVzdGFtcF9taWNyb3MgPSBNYXRoLmZsb29yKGZpZWxkcy50aW1lc3RhbXBfbWljcm9zKTtcbiAgICB9XG5cbiAgICAvLyBCZSBsZXNzIGZvcmdpdmluZyBhbmQgcmVqZWN0IHJlY29yZHMgd2l0aCBtaXNtYXRjaGVzIG9uIHRoZSBmaWVsZHMgdGhhdFxuICAgIC8vIHJlYWxseSBzaG91bGQgYmUgb2YgdGhlIHJpZ2h0IHR5cGU6XG4gICAgaWYgKCFpc1N0cmluZ09yVW5kZWZpbmVkKGZpZWxkcy5sZXZlbCkpIHtcbiAgICAgICAgX2Vycm9yKFwiSW52YWxpZCBsb2cgcmVjb3JkOiBsZXZlbFwiLCBmaWVsZHMpO1xuICAgICAgICB0aGlzLmNydW50aW1lQWN0aXZlLS07XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFpc051bWJlck9yVW5kZWZpbmVkKGZpZWxkcy50aHJlYWRfaWQpKSB7XG4gICAgICAgIF9lcnJvcihcIkludmFsaWQgbG9nIHJlY29yZDogdGhyZWFkX2lkXCIsIGZpZWxkcyk7XG4gICAgICAgIHRoaXMuY3J1bnRpbWVBY3RpdmUtLTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWlzTnVtYmVyT3JVbmRlZmluZWQoZmllbGRzLmxpbmVfbnVtYmVyKSkge1xuICAgICAgICBfZXJyb3IoXCJJbnZhbGlkIGxvZyByZWNvcmQ6IGxpbmVfbnVtYmVyXCIsIGZpZWxkcyk7XG4gICAgICAgIHRoaXMuY3J1bnRpbWVBY3RpdmUtLTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWlzU3RyaW5nT3JVbmRlZmluZWQoZmllbGRzLnBheWxvYWRfanNvbikpIHtcbiAgICAgICAgX2Vycm9yKFwiSW52YWxpZCBsb2cgcmVjb3JkOiBwYXlsb2FkX2pzb25cIiwgZmllbGRzKTtcbiAgICAgICAgdGhpcy5jcnVudGltZUFjdGl2ZS0tO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFRPRE86XG4gICAgLy8gaWYgKCFpc0xpc3RPclVuZGVmaW5lZChmaWVsZHMuc3RhY2tfZnJhbWVzKSkgeyAuLi4gfVxuICAgIC8vXG4gICAgaWYgKCFpc0Jvb2xlYW5PclVuZGVmaW5lZChmaWVsZHMuZXJyb3JfZmxhZykpIHtcbiAgICAgICAgX2Vycm9yKFwiSW52YWxpZCBsb2cgcmVjb3JkOiBlcnJvcl9mbGFnXCIsIGZpZWxkcyk7XG4gICAgICAgIHRoaXMuY3J1bnRpbWVBY3RpdmUtLTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFN1cnJvdW5kIHRoZSBwYXlsb2FkIHByb2Nlc3NpbmcgaW4gYW4gZXhjZXB0aW9uIGhhbmRsZXIgc2luY2Ugd2VcbiAgICAvLyBoYXZlIGxpdHRsZSBjb250cm9sIG92ZXIgdGhlIGNvbnRlbnRzIG9mIHRoZSBwYXlsb2FkIGFuZCBkb24ndFxuICAgIC8vIHdhbnQgZXhjZXB0aW9uIGxlYWtpbmcgaW50byBjdXN0b21lciBjb2RlLlxuICAgIC8vXG4gICAgLy8gVE9ETzogaW4gdGhlIGZ1dHVyZSwgaXQncyB1bmRvdWJ0ZWRseSBwb3NzaWJsZSB0aGF0IHRoZSBpbnNwZWN0L3NjcnViXG4gICAgLy8gcHJvY2VzcyBjb3VsZCBiZSBvcHRpbWl6ZWQgdG8gZG8gbGVzcyB3b3JrIGZvciB0aGUgY29tbW9uIGNhc2Ugb2Ygc21hbGxcbiAgICAvLyBwYXlsb2FkcyB0aGF0IHJlcXVpcmUgbm8gc2NydWJiaW5nLlxuICAgIC8vXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHBheWxvYWQgd2FzIHBhc3NlZCBpbiBhcyBhIGRpcmVjdCBKU09OIHN0cmluZy4gIFRoaXNcbiAgICAgICAgLy8gaXNuJ3QgcmVhbGx5IGFuIGV4cGVjdGVkIGNhc2UgLS0gYnV0IGhhbmRsZSBpdCBqdXN0IGluIGNhc2UgYnlcbiAgICAgICAgLy8gY29udmVydGluZyBpdCB0byBhbiBvYmplY3Qgc28gdGhlIHRydW5jYXRpb24gLyBzY3J1YmJpbmcgdGhhdCBmb2xsb3dzXG4gICAgICAgIC8vIGlzIGFwcGxpZWQuXG4gICAgICAgIGlmIChmaWVsZHMucGF5bG9hZF9qc29uKSB7XG4gICAgICAgICAgICBpZiAoREVCVUcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydCghdGhpcy5wYXlsb2FkLCBcIkJvdGggcGF5bG9hZCBhbmQgcGF5bG9hZF9qc29uIHNwZWNpZmllZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZmllbGRzLnBheWxvYWQgPSBKU09OLnBhcnNlKGZpZWxkcy5wYXlsb2FkX2pzb24pO1xuICAgICAgICAgICAgfSBjYXRjaCAoX2lnbm9yZWQpIHt9XG4gICAgICAgICAgICBkZWxldGUgZmllbGRzLnBheWxvYWRfanNvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBwYXlsb2FkIGlzIGJvdGggdHJ1bmNhdGVkICh0byBjYXAgbWF4IGRhdGEgdHJhbnNmZXIpIGFuZCBzY3J1YmJlZFxuICAgICAgICAvLyAodG8gcmVtb3ZlIHBlcnNvbmFsIGluZm9ybWF0aW9uLCBwYXNzd29yZHMsIGV0Yy4pIGJlZm9yZSBiZWluZ1xuICAgICAgICAvLyB0cmFuc21pdHRlZCBhcyBhIEpTT04gc3RyaW5nLlxuICAgICAgICBpZiAoZmllbGRzLnBheWxvYWQgIT09IG51bGwgJiYgZmllbGRzLnBheWxvYWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBtYWtlSW5zcGVjdGFibGUoZmllbGRzLnBheWxvYWQpO1xuXG4gICAgICAgICAgICAvLyBDYW4gYmUgbnVsbCBpZiBjb25zb2xlLiogaXMgb3ZlcnJpZGRlbiBhbmQgY2FsbGVkIGR1cmluZyBjcnVudGltZVxuICAgICAgICAgICAgLy8gaW5pdGlhbGl6YXRpb24uXG4gICAgICAgICAgICBpZiAodGhpcy5zY3J1Yikge1xuICAgICAgICAgICAgICAgIHBheWxvYWQgPSB0aGlzLnNjcnViLm1vZGlmeShwYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpZWxkcy5wYXlsb2FkX2pzb24gPSBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTtcbiAgICAgICAgICAgIGZpZWxkcy5wYXlsb2FkID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKHBheWxvYWRFeGNlcHRpb24pIHtcbiAgICAgICAgaWYgKERFQlVHKSB7XG4gICAgICAgICAgICBvcmlnaW5hbENvbnNvbGUuZXJyb3IoXCJybC1jcnVudGltZSBleGNlcHRpb246IFwiICsgcGF5bG9hZEV4Y2VwdGlvbik7XG4gICAgICAgICAgICBvcmlnaW5hbENvbnNvbGUuZXJyb3IocGF5bG9hZEV4Y2VwdGlvbi5zdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIGZpZWxkcy5wYXlsb2FkO1xuICAgICAgICBkZWxldGUgZmllbGRzLnBheWxvYWRfanNvbjtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gcG9vbC5sb2dSZWNvcmRzLmFjcXVpcmUoZmllbGRzKTtcbiAgICBpZiAoIXJlY29yZC50aW1lc3RhbXBfbWljcm9zKSB7XG4gICAgICAgIHJlY29yZC50aW1lc3RhbXBfbWljcm9zID0gdGhpcy5ub3dNaWNyb3MoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sb2dzLmxlbmd0aCA+PSB0aGlzLmJ1ZmZlck1heExvZ1JlY29yZHMpIHtcbiAgICAgICAgLy8gVHJlYXQgdGhpcyBsaWtlIGEgcmFuZG9tIHNhbXBsaW5nIGFuZCByZXBsYWNlIGEgcmVjb3JkIGF0IHJhbmRvbS5cbiAgICAgICAgLy8gVGhpcyBpcyBub3QgdHJ1bHkgcmFuZG9tIGluIG1hdGhlbWF0aWNhbCBzZW5zZSBmb3IgYSBudW1iZXIgb2YgcmVhc29ucyxcbiAgICAgICAgLy8gYnV0IHRoZSBhc3N1bXB0aW9uIHRoaXMgaXMgcHJvdmlkZXMgbW9yZSB1c2VmdWwgaW5mb3JtYXRpb24gdGhhblxuICAgICAgICAvLyBkcm9wcGluZyBhbGwgcmVjb3JkcyBvbmNlIHRoZSBtYXggaXMgaGl0LlxuICAgICAgICB2YXIgaW5kZXggPSBNYXRoLmZsb29yKHRoaXMubG9ncy5sZW5ndGggKiBNYXRoLnJhbmRvbSgpKTtcbiAgICAgICAgdmFyIHJlY29yZFRvRGlzY2FyZCA9IHRoaXMubG9nc1tpbmRleF07XG5cbiAgICAgICAgLy8gZGlzY2FyZGVkTG9nU2FtcGxlcyBrZWVwcyBhIGZpeGVkIHNpemUgYnVmZmVyIG9mIGhvdyBtYW55IGxvZ1xuICAgICAgICAvLyByZWNvcmRzIHdlcmUgZGlzY2FyZGVkIGZvciBhIGdpdmVuIHRpbWUtcGVyaW9kLiBJdCdzIGEgbGlnaHR3ZWlnaHQgd2F5XG4gICAgICAgIC8vIG9mIGxldHRpbmcgdGhlIHNlcnZlciBrbm93IHNvbWV0aGluZyBhYm91dCB0aGUgZGF0YSB0aGF0ICp3YXNuJ3QqXG4gICAgICAgIC8vIHJlcG9ydGVkIHdpdGhvdXQgdGFraW5nIHVwIGEgbG90IG9mIHJlcG9ydCBiYW5kd2lkdGguXG4gICAgICAgIHRoaXMuZGlzY2FyZGVkTG9nU2FtcGxlcy5hZGQocmVjb3JkVG9EaXNjYXJkLnRpbWVzdGFtcF9taWNyb3MpO1xuXG4gICAgICAgIHBvb2wubG9nUmVjb3Jkcy5yZWxlYXNlKHJlY29yZFRvRGlzY2FyZCk7XG4gICAgICAgIHRoaXMubG9nc1tpbmRleF0gPSByZWNvcmQ7XG4gICAgICAgIHRoaXMuY291bnRlcnMuZHJvcHBlZF9sb2dzKys7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb2dzLnB1c2gocmVjb3JkKTtcbiAgICB9XG5cbiAgICB0aGlzLmNydW50aW1lQWN0aXZlLS07XG59O1xuXG5TdGF0ZS5wcm90b3R5cGUubG9nQXJndW1lbnRzV2l0aFNwYW5HVUlEID0gZnVuY3Rpb24oc3BhbkdVSUQsIGxldmVsLCBlcnJvciwgYXJncykge1xuICAgIGlmICghdGhpcy5lbmFibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBOb3JtYWxpemUgdGhlIGFyZ3VtZW50cyBvYmplY3QgaW50byBhbiBBcnJheSAoaXQgbWlnaHQgYmUgYW4gQXJndW1lbnRzIG9iamVjdFxuICAgIC8vIHdoaWNoIGRvZXMgbm90IGhhdmUgdGhlIHNhbWUgaW50ZXJmYWNlKS5cbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyk7XG5cbiAgICAvLyBSZWNvcmQgdGhlIHBheWxvYWQgYXMgd2VsbCBzaW5jZSB0aGUgbWVzc2FnZSB3aWxsIGxpa2VseSBpbnNlcnQgdGhpbmdzIGxpa2VcbiAgICAvLyBcIltPYmplY3RdXCIgcmF0aGVyIHRoYW4gYW4gaW5zcGVjdGFibGUgcmVwcmVzZW50YXRpb24gKGdpdmVuIHRoZSB1c2Ugb2ZcbiAgICAvLyBqb2luKFwiXCIpIGJlbG93IGFuZCB0aGF0IG1vc3Qgb2JqZWN0cyBkbyBub3QgcHJvdmlkZSB0b1N0cmluZygpIG92ZXJyaWRlcykuXG4gICAgLy9cbiAgICAvLyBTa2lwIHRoaXMgc3RlcCBpZiB0aGUgYXJncyBhcmUgZW1wdHkgb3IgYWxsIHRoZSBhcmdzIGFyZSBzdHJpbmdzIHRob3VnaCwgYXNcbiAgICAvLyB0aGUgcGF5bG9hZCB3aWxsIGJlIGNvbnZleWluZyBubyBuZXcgaW5mb3JtYXRpb24gaW4gdGhhdCBjYXNlLlxuICAgIHZhciBwYXlsb2FkID0ge307XG4gICAgdmFyIGhhc1BheWxvYWQgPSBmYWxzZTsgICAgIC8vIERvbid0IHJlY29yZCBlbXB0eSBwYXlsb2Fkc1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDAgJiYgIWFsbEVsZW1lbnRzQXJlU3RyaW5ncyhhcmdzKSkge1xuICAgICAgICBwYXlsb2FkLmFyZ3VtZW50cyA9IGFyZ3M7XG4gICAgICAgIGhhc1BheWxvYWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGFyZ3Muam9pbihcIiBcIikgY2FuIGNvbXBsYWluIGFib3V0IFwiVHlwZUVycm9yOiBDYW5ub3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCJcbiAgICAvLyB3aGVuIHRoZSB1bnJvbGxlZCBsb29wIGJlbG93IGRvZXMgbm90LlxuICAgIHZhciBtZXNzYWdlO1xuICAgIGlmIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAvLyBQYXJhbm9pZCB0cnktY2F0Y2guIEVsZWN0cm9uIHN0aWxsIG1hbmFnZXMgdG8gZ2VuZXJhdGUgYSBUeXBlRXJyb3Igb24gd2hhdCBhcHBlYXJzXG4gICAgICAgIC8vIHRvIGJlIGEgdmFsaWQgZW1wdHkgb2JqZWN0LiBQcmVmZXIgYW4gZW1wdHkgbWVzc2FnZSB0byBsZXR0aW5nIGFuIGV4Y2VwdGlvbiBjcmVlcFxuICAgICAgICAvLyBpbnRvIHRoZSBjdXN0b21lciBjb2RlLlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IFwiXCIgKyBhcmdzWzBdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIiBcIiArIGFyZ3NbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IGFuIGludGVybmFsLW9ubHkgbG9nIG9mIHRoaXMgd291bGQgY29uZGl0aW9uIHdvdWxkIGJlIG5pY2UuIEJ1dCBob3cgZG9cbiAgICAgICAgICAgIC8vIHlvdSBsb2cgaW5mbyBhYm91dCBhbiBvYmplY3QgdGhhdCBpcyBjYXVzaW5nIGFuIGVycm9yIHdoZW4geW91J3JlIHRyeWluZyB0b1xuICAgICAgICAgICAgLy8gbG9nIGluZm8gYWJvdXQgaXQ/IVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHtcbiAgICAgICAgZXJyb3JfZmxhZyAgOiBlcnJvciA/IHRydWUgOiBmYWxzZSxcbiAgICAgICAgbGV2ZWwgICAgICAgOiBsZXZlbCxcbiAgICAgICAgZmlsZW5hbWUgICAgOiB0aGlzLmRlZmF1bHRMb2dGaWxlbmFtZSgpLFxuICAgICAgICBtZXNzYWdlICAgICA6IG1lc3NhZ2UsXG4gICAgICAgIHNwYW5fZ3VpZCAgIDogc3BhbkdVSUQsXG4gICAgfTtcbiAgICBpZiAoaGFzUGF5bG9hZCkge1xuICAgICAgICByZWNvcmQucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgfVxuICAgIHRoaXMucmF3TG9nUmVjb3JkKHJlY29yZCk7XG59O1xuXG5TdGF0ZS5wcm90b3R5cGUubG9nQXJndW1lbnRzSW5mbyA9IGZ1bmN0aW9uKGFyZ3MsIHNwYW5HVUlELCBlY2hvKSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZWNobyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVjaG8gPSB0aGlzLmxvZ1RvU3RkaW87XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIGFyZ3MgaXMgYSB0cnVlIEFycmF5LCBub3QgYW4gQXJndW1lbnRzIG9iamVjdFxuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKTtcbiAgICB0aGlzLmxvZ0FyZ3VtZW50c1dpdGhTcGFuR1VJRChzcGFuR1VJRCwgXCJJXCIsIGZhbHNlLCBhcmdzKTtcblxuICAgIGlmIChlY2hvKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oYXJncyk7XG4gICAgfVxufTtcblxuU3RhdGUucHJvdG90eXBlLmxvZ0FyZ3VtZW50c1dhcm4gPSBmdW5jdGlvbihhcmdzLCBzcGFuR1VJRCwgZWNobykge1xuICAgIGlmICghdGhpcy5lbmFibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVjaG8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlY2hvID0gdGhpcy5sb2dUb1N0ZGlvO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSBhcmdzIGlzIGEgdHJ1ZSBBcnJheSwgbm90IGFuIEFyZ3VtZW50cyBvYmplY3RcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyk7XG4gICAgdGhpcy5sb2dBcmd1bWVudHNXaXRoU3BhbkdVSUQoc3BhbkdVSUQsIFwiV1wiLCBmYWxzZSwgYXJncyk7XG5cbiAgICBpZiAoZWNobykge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGFyZ3MpO1xuICAgIH1cbn07XG5cblN0YXRlLnByb3RvdHlwZS5sb2dBcmd1bWVudHNFcnJvciA9IGZ1bmN0aW9uKGFyZ3MsIHNwYW5HVUlELCBlY2hvKSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZWNobyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVjaG8gPSB0aGlzLmxvZ1RvU3RkaW87XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIGFyZ3MgaXMgYSB0cnVlIEFycmF5LCBub3QgYW4gQXJndW1lbnRzIG9iamVjdFxuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKTtcbiAgICB0aGlzLmxvZ0FyZ3VtZW50c1dpdGhTcGFuR1VJRChzcGFuR1VJRCwgXCJFXCIsIHRydWUsIGFyZ3MpO1xuXG4gICAgaWYgKGVjaG8pIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYXJncyk7XG4gICAgfVxufTtcblxuU3RhdGUucHJvdG90eXBlLmxvZ0FyZ3VtZW50c0ZhdGFsID0gZnVuY3Rpb24gKGFyZ3MsIHNwYW5HVUlELCBlY2hvKSAge1xuICAgIGlmICghdGhpcy5lbmFibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVjaG8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlY2hvID0gdGhpcy5sb2dUb1N0ZGlvO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSBhcmdzIGlzIGEgdHJ1ZSBBcnJheSwgbm90IGFuIEFyZ3VtZW50cyBvYmplY3RcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyk7XG4gICAgdGhpcy5sb2dBcmd1bWVudHNXaXRoU3BhbkdVSUQoc3BhbkdVSUQsIFwiRlwiLCB0cnVlLCBhcmdzKTtcblxuICAgIGlmIChlY2hvKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmZhdGFsKGFyZ3MpO1xuICAgIH1cbiAgICB0aGlzLnByb2Nlc3NBYm9ydCgpO1xufTtcblxuU3RhdGUucHJvdG90eXBlLmxvZ0Zvcm1hdHRlZEluZm8gPSBmdW5jdGlvbihhcmdzLCBzcGFuR1VJRCwgZWNobykge1xuICAgIGlmICghdGhpcy5lbmFibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTk9UX1lFVF9JTVBMRU1FTlRFRFwiKTtcbn07XG5cblN0YXRlLnByb3RvdHlwZS5sb2dGb3JtYXR0ZWRXYXJuID0gZnVuY3Rpb24oYXJncywgc3BhbkdVSUQsIGVjaG8pIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIk5PVF9ZRVRfSU1QTEVNRU5URURcIik7XG59O1xuU3RhdGUucHJvdG90eXBlLmxvZ0Zvcm1hdHRlZEVycm9yID0gZnVuY3Rpb24oYXJncywgc3BhbkdVSUQsIGVjaG8pIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIk5PVF9ZRVRfSU1QTEVNRU5URURcIik7XG59O1xuU3RhdGUucHJvdG90eXBlLmxvZ0Zvcm1hdHRlZEZhdGFsID0gZnVuY3Rpb24oYXJncywgc3BhbkdVSUQpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIk5PVF9ZRVRfSU1QTEVNRU5URURcIik7XG4gICAgLy90aGlzLnByb2Nlc3NBYm9ydCgpO1xufTtcblxuLy8gSmF2YXNjcmlwdCBkb2Vzbid0IHJlYWxseSBoYXZlIGEgdmVyeSBzb2xpZCBzdGFuZGFyZCBvbiBleGNlcHRpb24gb2JqZWN0cy5cbi8vIFRoZSBjb2RlIGJlbG93IHRyaWVzIHRvIGV4dHJhY3QgYXMgbXVjaCBpbmZvcm1hdGlvbiBhcyBwb3NzaWJsZSBiYXNlZFxuLy8gb24gdGhlIGNvbW1vbiBjYXNlcyBvZiB3aGF0IGluZm9ybWF0aW9uIG1heSBiZSBhdmFpbGFibGUuXG4vL1xuU3RhdGUucHJvdG90eXBlLmxvZ0V4Y2VwdGlvbiA9IGZ1bmN0aW9uIChlLCBzcGFuR1VJRCkge1xuICAgIGlmICghdGhpcy5lbmFibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuY3J1bnRpbWVBY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNydW50aW1lQWN0aXZlKys7XG5cbiAgICB2YXIgc3RhY2tGcmFtZXMgPSBbXTtcbiAgICB2YXIgbGluZU51bWJlcjtcbiAgICB2YXIgZmlsZW5hbWU7XG5cbiAgICAvLyBBdHRlbXB0IHRvIGV4dHJhY3QgdGhlIGNhbGwgc3RhY2sgZnJvbSB0aGUgc3RyaW5nIChjb3JyZWN0IGZvclxuICAgIC8vIGF0IGxlYXN0IENocm9tZSA0MCwgTm9kZS5qcyB2MC4xMikuICBOb3RlOiBob29raW5nIGludG8gVjgnc1xuICAgIC8vIHByZXBhcmVDYWxsU3RhY2sgaXMgYSBtb3JlIGRpcmVjdCB3YXkgdG8gZ2V0IHRoaXMgaW5mb3JtYXRpb24gYnV0XG4gICAgLy8gaW52b2x2ZXMgb3ZlcnJyaWRpbmcgZGVmYXVsdCBiZWhhdmlvcnMgb2YgVjgtb25seSBBUElzIC0gbWF5IHdhbnRcbiAgICAvLyB0byBkbyB0aGF0IGV2ZW50dWFsbHksIGJ1dCBmb3Igbm93IHNpbXBsZSBzdHJpbmcgcGFyc2luZyBpcyB1c2VkLlxuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTEzODY0OTIvYWNjZXNzaW5nLWxpbmUtbnVtYmVyLWluLXY4LWphdmFzY3JpcHQtY2hyb21lLW5vZGUtanNcbiAgICAvL1xuICAgIGlmICh0eXBlb2YgZS5zdGFjayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBzdGFja0ZyYW1lcyA9IGUuc3RhY2suc3BsaXQoXCJcXG5cIik7XG5cbiAgICAgICAgLy8gQXNzdW1lIHRoZSBzdHJpbmcgaGFzIHRoZSBmb3JtIGJlbG93IGFuZCB0cnkgdG8gZXh0cmFjdCBpbmZvOlxuICAgICAgICAvLyAgICAgIEVycm9yOiBUaGlzIGlzIGFuIGVycm9yXG4gICAgICAgIC8vICAgICAgICAgIGF0IENvbnRleHQuPGFub255bW91cz4gKC8uLi4vdGVzdC9zaGFyZWRfdW5pdHRlc3RzLmpzOjIwMjozMClcbiAgICAgICAgLy8gICAgICAgICAgLi4uXG4gICAgICAgIGlmIChzdGFja0ZyYW1lcy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgdmFyIHRvcCA9IHN0YWNrRnJhbWVzWzFdO1xuICAgICAgICAgICAgdmFyIG07XG4gICAgICAgICAgICBpZiAodG9wLm1hdGNoKC9eXFxzK2F0XFxzLykgJiYgKG0gPSB0b3AubWF0Y2goL1xcKCguKyk6KFswLTldKyk6KFswLTldKylcXCkkLykpKSB7XG4gICAgICAgICAgICAgICAgZmlsZW5hbWUgPSBtWzFdO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXIgPSBwYXJzZUludChtWzJdKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvLyBCZSBhcyBzcGVjaWZpYyBhcyB3ZSBjYW4gZm9yIHRoZSBzdGFuZGFyZCBleGNlcHRpb24gdHlwZXM6XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3JcbiAgICAvL1xuICAgIC8vIFRoaXMgbWlnaHQgYmUgcmVkdW5kYW50IGFzIHRvIHdoYXQgdG9TdHJpbmcoKSB3aWxsIHByb2R1Y2UsIGJ1dFxuICAgIC8vIHRoYXQgaXMgdW5jbGVhciBhcyB3aGF0IHRvU3RyaW5nKCkgcHJvZHVjZXMgaXMgbm90IHN0YW5kYXJkaXplZC5cbiAgICB2YXIgZXhjZXB0aW9uVHlwZSA9IFwiRXhjZXB0aW9uXCI7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBFdmFsRXJyb3IpIHtcbiAgICAgICAgZXhjZXB0aW9uVHlwZSA9IFwiRXZhbEVycm9yXCI7XG4gICAgfSBlbHNlIGlmIChlIGluc3RhbmNlb2YgUmFuZ2VFcnJvcikge1xuICAgICAgICBleGNlcHRpb25UeXBlID0gXCJSYW5nZUVycm9yXCI7XG4gICAgfSBlbHNlIGlmIChlIGluc3RhbmNlb2YgUmVmZXJlbmNlRXJyb3IpIHtcbiAgICAgICAgZXhjZXB0aW9uVHlwZSA9IFwiUmVmZXJlbmNlRXJyb3JcIjtcbiAgICB9IGVsc2UgaWYgKGUgaW5zdGFuY2VvZiBTeW50YXhFcnJvcikge1xuICAgICAgICBleGNlcHRpb25UeXBlID0gXCJTeW50YXhFcnJvclwiO1xuICAgIH0gZWxzZSBpZiAoZSBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xuICAgICAgICBleGNlcHRpb25UeXBlID0gXCJUeXBlRXJyb3JcIjtcbiAgICB9IGVsc2UgaWYgKGUgaW5zdGFuY2VvZiBVUklFcnJvcikge1xuICAgICAgICBleGNlcHRpb25UeXBlID0gXCJVUklFcnJvclwiO1xuICAgIH0gZWxzZSBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGV4Y2VwdGlvblR5cGUgPSBcIkVycm9yXCI7XG4gICAgfVxuXG4gICAgdGhpcy5yYXdMb2dSZWNvcmQoe1xuICAgICAgICBzcGFuX2d1aWQgICAgICAgOiBzcGFuR1VJRCwgICAgICAgLy8gTWF5IGJlIHVuZGVmaW5lZFxuICAgICAgICBtZXNzYWdlICAgICAgICAgOiBlLnRvU3RyaW5nKCksXG4gICAgICAgIGVycm9yX2ZsYWcgICAgICA6IHRydWUsXG4gICAgICAgIGxldmVsICAgICAgICAgICA6IFwiRVwiLFxuICAgICAgICBmaWxlbmFtZSAgICAgICAgOiBmaWxlbmFtZSwgICAgICAgLy8gTWF5IGJlIHVuZGVmaW5lZFxuICAgICAgICBsaW5lX251bWJlciAgICAgOiBsaW5lTnVtYmVyLCAgICAgLy8gTWF5IGJlIHVuZGVmaW5lZFxuICAgICAgICBwYXlsb2FkICAgICAgICAgOiB7XG4gICAgICAgICAgICBleGNlcHRpb25UeXBlIDogZXhjZXB0aW9uVHlwZSxcbiAgICAgICAgfSxcbiAgICAgICAgc3RhY2tfZnJhbWVzICAgIDogc3RhY2tGcmFtZXMsXG4gICAgfSk7XG5cbiAgICB0aGlzLmNydW50aW1lQWN0aXZlLS07XG59O1xuXG4vLyBDcmVhdGUgYSBkZXRhaWxlZCBsb2cgcmVjb3JkIGRpcmVjdGx5XG5TdGF0ZS5wcm90b3R5cGUubG9nUmVjb3JkID0gZnVuY3Rpb24oZmllbGRzKSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yYXdMb2dSZWNvcmQoZmllbGRzKTtcbn07XG5cbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cbi8vIEV2ZW50c1xuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuXG4vLyBOb3RlOiBmb3VyIGFyZ3VtZW50cyBhcmUgYWx3YXlzIGV4cGVjdGVkLCBidXQgZXZlcnl0aGluZyBidXQgXCJuYW1lXCIgaXNcbi8vIGFsbG93ZWQgdG8gYmUgc2V0IHRvIHVuZGVmaW5lZC5cbi8vXG5TdGF0ZS5wcm90b3R5cGUubG9nRXZlbnRXaXRoR1VJRCA9IGZ1bmN0aW9uKG5hbWUsIG1lc3NhZ2UsIHBheWxvYWQsIHNwYW5HVUlEKSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucmF3TG9nUmVjb3JkKHtcbiAgICAgICAgc3RhYmxlX25hbWUgICAgIDogbmFtZSxcbiAgICAgICAgbWVzc2FnZSAgICAgICAgIDogbWVzc2FnZSxcbiAgICAgICAgZmlsZW5hbWUgICAgICAgIDogdGhpcy5kZWZhdWx0TG9nRmlsZW5hbWUoKSxcbiAgICAgICAgcGF5bG9hZCAgICAgICAgIDogcGF5bG9hZCxcbiAgICAgICAgc3Bhbl9ndWlkICAgICAgIDogc3BhbkdVSUQsXG4gICAgfSk7XG59O1xuXG4vLyBWYWxpZCBjYWxsIHNpZ25hdHVyZXM6XG4vL1xuLy8gZXZlbnQobmFtZSlcbi8vIGV2ZW50KG5hbWUsIG1lc3NhZ2UpXG4vLyBldmVudChuYW1lLCBwYXlsb2FkKVxuLy8gZXZlbnQobmFtZSwgbWVzc2FnZSwgcGF5bG9hZClcbi8vXG5TdGF0ZS5wcm90b3R5cGUubG9nRXZlbnQgPSBmdW5jdGlvbihuYW1lLCBtZXNzYWdlLCBwYXlsb2FkKSB7XG4gICAgLy8gVGhlIHR3by1hcmd1bWVudCBjYWxsIHNpZ25hdHVyZSBpcyB0aGUgb25seSBjYXNlIHRoYXQgcmVxdWlyZXNcbiAgICAvLyBwYXJhbWV0ZXIgc2h1ZmZsaW5nXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIG1lc3NhZ2UgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcGF5bG9hZCA9IG1lc3NhZ2U7XG4gICAgICAgIG1lc3NhZ2UgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxvZ0V2ZW50V2l0aEdVSUQobmFtZSwgbWVzc2FnZSwgcGF5bG9hZCwgdW5kZWZpbmVkKTtcbn07XG5cblN0YXRlLnByb3RvdHlwZS5ldmVudFdyYXAgPSBmdW5jdGlvbihuYW1lLCBmKSB7XG4gICAgLy8gV2UgKmRvbid0KiBjaGVjayB0aGlzLmVuYWJsZWQgb24gdGhlIG91dGVyIHdyYXBwZXIuIFRoZSBlbmFibGVkIHNldHRpbmdcbiAgICAvLyBpcyBwb3RlbnRpYWxseSB0b2dnbGFibGUgYXQgcnVudGltZS4gQ29uZGl0aW9uYWxseSBjcmVhdGluZyB0aGUgd3JhcHBlclxuICAgIC8vIHdvdWxkIGJlIHZlcnkgY29uZnVzaW5nIGFzIGxhdGVyIHJlLWVuYWJsaW5nIHRoZSBjcnVudGltZSB3b3VsZCBub3RcbiAgICAvLyByZXRyb2FjdGl2ZWx5IGNvbnZlcnQgdGhlIGlucHV0IGZ1bmN0aW9uIGludG8gYSB3cmFwcGVyIGVxdWl2YWxlbnQuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlZCkge1xuICAgICAgICAgICAgc2VsZi5yYXdMb2dSZWNvcmQoe1xuICAgICAgICAgICAgICAgIHN0YWJsZV9uYW1lIDogbmFtZSxcbiAgICAgICAgICAgICAgICBmaWxlbmFtZSAgICA6IHNlbGYuZGVmYXVsdExvZ0ZpbGVuYW1lKCksXG4gICAgICAgICAgICAgICAgcGF5bG9hZCAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50cyAgICA6IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tfZnJhbWVzIDogcGxhdGZvcm0uc3RhY2tUcmFjZSgpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG59O1xuXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXG4vLyBTcGFuc1xuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuXG5TdGF0ZS5wcm90b3R5cGUuc2V0QWN0aXZlU3Bhbk5hbWUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgc3BhbiA9IHRoaXMuZ2V0QWN0aXZlU3BhbigpO1xuICAgIGlmICghc3Bhbikge1xuICAgICAgICAvLyBJdCdzIG5vdCBhbiBlcnJvciB0byBjYWxsIHRoaXMgd2hlbiB0aGVyZSdzIG5vIGFjdGl2ZSBzcGFuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3Bhbi5uYW1lKG5hbWUpO1xufTtcblxuLy8gUHJldHR5IHNpbXBsZTogYmFuayBvbiB0aGUgdW5pcXVlbmVzcyBvZiB0aGUgXCJfX2NyX3NwYW5cIiBwcm9wZXJ0eVxuLy8gbmFtZSBhbmQgZW5zdXJlIHdlIHVzZSB0aGF0IHByb3BlcnR5IG5hbWUgY29uc2lzdGVudGx5IGluIHRoZVxuLy8gYXV0by1pbnN0cnVtZW50YXRpb24uXG5TdGF0ZS5wcm90b3R5cGUuc3BhbkZvck9iamVjdCA9IGZ1bmN0aW9uIChvYmosIHNwYW5IYW5kbGUpIHtcblxuICAgIGlmICghdGhpcy5lbmFibGVkKSB7XG4gICAgICAgIHJldHVybiBzcGFuX2hhbmRsZS5nZXROb09wSGFuZGxlKCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIHNwYW5IYW5kbGUgfHwgdGhpcy5hcGk7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHRoZSBzZXR0ZXIgY2FzZVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpIHtcblxuICAgICAgICBpZiAoc3Bhbl9oYW5kbGUuaXNTcGFuSGFuZGxlKHNwYW5IYW5kbGUpKSB7XG4gICAgICAgICAgICBvYmouX19jcl9zcGFuID0gc3BhbkhhbmRsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BhbkhhbmRsZTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gRG9lcyB0aGlzIG9iamVjdCBoYXZlIGFuIGV4cGxjaWl0IHNwYW4gaGFuZGxlP1xuICAgICAgICB2YXIgaGFuZGxlID0gb2JqLl9fY3Jfc3BhbjtcbiAgICAgICAgaWYgKHNwYW5faGFuZGxlLmlzU3BhbkhhbmRsZShoYW5kbGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSXMgdGhlcmUgYW4gYWN0aXZlIHNwYW4gaGFuZGxlP1xuICAgICAgICAvLyBOb3RlOiB0aGVyZSBhcmUgY2FzZXMgd2hlcmUgdGhlIGFjdGl2ZSBzcGFuIGhhbmRsZSBpcyBub3RcbiAgICAgICAgLy8gbmVjZXNzYXJpbHkgd2hhdCB0aGUgY3VzdG9tZXIgd291bGQgd2FudC4gSXQgaXMgYmVpbmcgYXNzdW1lZFxuICAgICAgICAvLyBpdCB3aWxsIGJlIGNvcnJlY3QgXCJvZnRlbiBlbm91Z2hcIiB0aGF0IHRoaXMgaXMgaGVscGZ1bCBiZWhhdmlvci5cbiAgICAgICAgdmFyIGxhc3RJbmRleCA9IHRoaXMuYWN0aXZlU3Bhbk9ySm9pbklEc1N0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChsYXN0SW5kZXggPj0gMCkge1xuICAgICAgICAgICAgdmFyIHNwYW5PckpvaW5JZHMgPSB0aGlzLmFjdGl2ZVNwYW5PckpvaW5JRHNTdGFja1tsYXN0SW5kZXhdO1xuICAgICAgICAgICAgaWYgKHNwYW5faGFuZGxlLmlzU3BhbkhhbmRsZShzcGFuT3JKb2luSWRzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzcGFuT3JKb2luSWRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgIHRoaXMuYXBpLndhcm4oXCJObyBzcGFuIGhhbmRsZSBmb3I6XCIsIG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwYW5faGFuZGxlLmdldE5vT3BIYW5kbGUoKTtcbiAgICB9XG59O1xuXG4vLyBTZXRzIHRoZSBnaXZlbiBzcGFuIGFzIGFjdGl2ZSBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSBjYWxsdGhyb3VnaCAodGhlblxuLy8gcG9wcyBpdCBmcm9tIHRoZSBhY3RpdmUgc3RhY2sgb24gY2FsbCB0ZXJtaW5hdGlvbikuXG4vL1xuLy8gVGhpcyBtZWFucyB0aGF0IGFueSBjYWxscyBmdXJ0aGVyIHVwIGluIHRoZSBjYWxsc3RhY2sgY2FuIGFjY2Vzc1xuLy8gdGhpcyBzcGFuIHZpYSBhIGNhbGwgdG8gZ2V0QWN0aXZlSm9pbklkcygpIGluIG9yZGVyIHRvIGluaGVyaXQgdGhlIGpvaW4gSURzLlxuLy9cbi8vIE5vdGU6IGEgc3BhbiBiZWluZyByZW1vdmVkIGZyb20gdGhlIGFjdGl2ZSBzcGFuIHN0YWNrIGlzIG5vdCB0aGUgc2FtZSBhc1xuLy8gZW5kKCktaW5nIGEgc3Bhbi4gIFRoZSBjYWxsZXIgaXMgc3RpbGwgcmVzcG9uc2libGUgZm9yIGNhbGxpbmcgZW5kKCkgb25cbi8vIHRoZSBnaXZlbiBzcGFuLlxuLy9cbi8vIE5vdGU6IGBzcGFuYCAqaXMqIGFsbG93ZWQgdG8gYmUgbnVsbCB0byBzaW1wbGlmeSB0aGluZ3MgZm9yIHRoZSBjYWxsZXIuXG4vL1xuLy8gTm90ZS9UT0RPOiB0aGlzIHJlYWxseSBvbmx5IGFjdGl2ZSBzcGFuIHN0YWNrIHJlYWxseSBvbmx5IHdvcmtzIGZvclxuLy8gc3luY2hyb25vdXMgY2FsbHMgb3IgZWxzZSB0aGUgcHVzaCgpIC8gcG9wKCkgcG90ZW50aWFsbHkgYmVjb21lcyB1bmJhbGFuY2VkLlxuLy8gQmVpbmcgYXBwbGljYWJsZSBvbmx5IHRvIHN5bmNocm9ub3VzIGZ1bmN0aW9ucyBpcyBhIHNlcmlvdXMgbGltaXRhdGlvbiBpblxuLy8gSlMuICBJdCdzIHdvcnRoIGNvbnNpZGVyaW5nIGlmIGEgc3VmZmljaWVudGx5IHBlcmZvcm1hbnQgXCJzZXRcIiBvZiBhY3RpdmVcbi8vIHNwYW5zIGNvdWxkIGJlIG1haW50YWluZWQgaW5zdGVhZCAtLSBzb21ldGhpbmcgdGhhdCBkb2Vzbid0IG5lY2Vzc2FyaWx5XG4vLyBoYXZlIHRvIGJlIHB1c2ggLyBwb3BwZWQgaW4gb3JkZXIsIGJ1dCBkb2VzIG1haW50YWluIGtub3dsZWRnZSBvZiB0aGVcbi8vIG1vc3QgcmVjZW50IHNwYW4uXG4vL1xuU3RhdGUucHJvdG90eXBlLnNldEFjdGl2ZVNwYW5PckpvaW5JZHMgPSBmdW5jdGlvbihzcGFuT3JKb2luSWRzLCBzZWxmLCBhcmdzLCBjYWxsdGhyb3VnaCkge1xuICAgIGlmICghdGhpcy5lbmFibGVkKSB7XG4gICAgICAgIHJldHVybiBjYWxsdGhyb3VnaC5hcHBseShzZWxmLCBhcmdzKTtcbiAgICB9XG5cbiAgICBpZiAoc3Bhbk9ySm9pbklkcykge1xuICAgICAgIHRoaXMuYWN0aXZlU3Bhbk9ySm9pbklEc1N0YWNrLnB1c2goc3Bhbk9ySm9pbklkcyk7XG4gICAgfVxuXG4gICAgdmFyIHJldDtcbiAgICB0cnkge1xuICAgICAgICByZXQgPSBjYWxsdGhyb3VnaC5hcHBseShzZWxmLCBhcmdzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMubG9nRXhjZXB0aW9uKGUpO1xuICAgICAgICB0aHJvdyBlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChzcGFuT3JKb2luSWRzKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVNwYW5PckpvaW5JRHNTdGFjay5wb3AoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuU3RhdGUucHJvdG90eXBlLnNldEFjdGl2ZUpvaW5JZHMgPSBmdW5jdGlvbihqb2luSWRzLCBjYWxsdGhyb3VnaCkge1xuXG4gICAgaWYgKHRoaXMudmVyYm9zZSkge1xuICAgICAgICB2YXIgZmlsdGVyZWRTdGFjayA9IHRoaXMucGxhdGZvcm0uc3RhY2tUcmFjZSgwLCBmYWxzZSk7XG4gICAgICAgIHRoaXMubG9nUmVjb3JkKHtcbiAgICAgICAgICAgIHN0YWJsZV9uYW1lIDogXCJjci9zZXRfYWN0aXZlX2pvaW5faWRzXCIsXG4gICAgICAgICAgICBtZXNzYWdlIDogSlNPTi5zdHJpbmdpZnkoam9pbklkcykgKyBcIiBcIiArIGZpbHRlcmVkU3RhY2tbMF0sXG4gICAgICAgICAgICBwYXlsb2FkIDoge1xuICAgICAgICAgICAgICAgIGpvaW5faWRzICAgICAgICA6IGpvaW5JZHMsXG4gICAgICAgICAgICAgICAgYWN0aXZlX2pvaW5faWRzIDogdGhpcy5nZXRBY3RpdmVKb2luSWRzU3RhY2soKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdGFja19mcmFtZXMgOiB0aGlzLnBsYXRmb3JtLnN0YWNrVHJhY2UoMCwgdHJ1ZSksXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNldEFjdGl2ZVNwYW5PckpvaW5JZHMoam9pbklkcywgbnVsbCwgW10sIGNhbGx0aHJvdWdoKTtcbn07XG5cblN0YXRlLnByb3RvdHlwZS5zZXRBY3RpdmVTcGFuID0gZnVuY3Rpb24oc3Bhbiwgc2VsZiwgYXJncywgY2FsbHRocm91Z2gpIHtcblxuICAgIGlmICh0aGlzLnZlcmJvc2UpIHtcbiAgICAgICAgdmFyIGZpbHRlcmVkU3RhY2sgPSB0aGlzLnBsYXRmb3JtLnN0YWNrVHJhY2UoMCwgZmFsc2UpO1xuICAgICAgICB0aGlzLmxvZ1JlY29yZCh7XG4gICAgICAgICAgICBzdGFibGVfbmFtZSA6IFwiY3Ivc2V0X2FjdGl2ZV9zcGFuXCIsXG4gICAgICAgICAgICBtZXNzYWdlIDogc3Bhbi5uYW1lKCkgKyBcIiBcIiArIEpTT04uc3RyaW5naWZ5KHNwYW4uam9pbklkcygpKSArIFwiIFwiICsgZmlsdGVyZWRTdGFja1swXSxcbiAgICAgICAgICAgIHBheWxvYWQgOiB7XG4gICAgICAgICAgICAgICAgc3Bhbl9uYW1lICAgICAgIDogc3Bhbi5uYW1lKCksXG4gICAgICAgICAgICAgICAgc3Bhbl9ndWlkICAgICAgIDogc3Bhbi5ndWlkKCksXG4gICAgICAgICAgICAgICAgam9pbl9pZHMgICAgICAgIDogc3Bhbi5qb2luSWRzKCksXG4gICAgICAgICAgICAgICAgYWN0aXZlX2pvaW5faWRzIDogdGhpcy5nZXRBY3RpdmVKb2luSWRzU3RhY2soKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdGFja19mcmFtZXMgOiB0aGlzLnBsYXRmb3JtLnN0YWNrVHJhY2UoMCwgdHJ1ZSksXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNldEFjdGl2ZVNwYW5PckpvaW5JZHMoc3Bhbiwgc2VsZiwgYXJncywgY2FsbHRocm91Z2gpO1xufTtcblxuU3RhdGUucHJvdG90eXBlLmdldEFjdGl2ZVNwYW4gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuYWN0aXZlU3Bhbk9ySm9pbklEc1N0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBzcGFuID0gdGhpcy5hY3RpdmVTcGFuT3JKb2luSURzU3RhY2tbaV07XG4gICAgICAgIGlmIChzcGFuX2hhbmRsZS5pc1NwYW5IYW5kbGUoc3BhbikgJiYgc3Bhbi52YWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3BhbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbi8vIFJldHVybiB0aGUgYWN0aXZlIGpvaW4gSURzLlxuLy9cblN0YXRlLnByb3RvdHlwZS5nZXRBY3RpdmVKb2luSWRzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSB0aGlzLmFjdGl2ZVNwYW5PckpvaW5JRHNTdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgc3BhbiA9IHRoaXMuYWN0aXZlU3Bhbk9ySm9pbklEc1N0YWNrW2ldO1xuXG4gICAgICAgIC8vIFNwYW5IYW5kbGUgb2JqZWN0cyBuZWVkIHRvIGJlIHZhbGlkKCk7IG90aGVyd2lzZSwgYXNzdW1lZCBpdCdzIGFcbiAgICAgICAgLy8ga2V5LXZhbHVlIGpvaW5JRCBtYXAgYW5kIHJldHVybiBpdC4gSXQgaXMgcG9zc2libGUgZm9yIHNwYW5zIHRvXG4gICAgICAgIC8vIGJlIGVuZGVkIGJlZm9yZSBpdCBpcyBwb3BwZWQgZnJvbSB0aGUgYWN0aXZlIHN0YWNrIGFuZCBpdCBwcm9kdWNlc1xuICAgICAgICAvLyBtb3JlIGFjY3VyYXRlIHRyYWNlcyB0byBhY2NvdW50IGZvciB0aGF0LiAgQWxzbywgY2hlY2tpbmcgaGVyZSBpc1xuICAgICAgICAvLyBpbmNyZW1lbnRhbGx5IGVhc2llciB0aGFuIGhhdmluZyBzcGFucyBjaGVja1xuICAgICAgICBpZiAoIXNwYW5faGFuZGxlLmlzU3BhbkhhbmRsZShzcGFuKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgICAgIH0gZWxzZSBpZiAoc3Bhbi52YWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3Bhbi5qb2luSWRzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHt9O1xufTtcblxuLy8gSW50ZXJuYWwgdXRpbGl0eTogbm90IGludGVuZGVkIHRvIGJlIGV4cG9zZWQgdG8gdGhlIGNsaWVudCBBUEkuXG5TdGF0ZS5wcm90b3R5cGUuZ2V0QWN0aXZlSm9pbklkc1N0YWNrID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWN0aXZlU3Bhbk9ySm9pbklEc1N0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzcGFuID0gdGhpcy5hY3RpdmVTcGFuT3JKb2luSURzU3RhY2tbaV07XG4gICAgICAgIGlmICghc3Bhbl9oYW5kbGUuaXNTcGFuSGFuZGxlKHNwYW4pKSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKHNwYW4pO1xuICAgICAgICB9IGVsc2UgaWYgKHNwYW4udmFsaWQoKSkge1xuICAgICAgICAgICAgc3RhY2sucHVzaChzcGFuLmpvaW5JZHMoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YWNrO1xufTtcblxuLy8gQ3JlYXRlIHRoZSBzcGFuIHJlY29yZFxuU3RhdGUucHJvdG90eXBlLnJhd1NwYW5CZWdpbiA9IGZ1bmN0aW9uIChuYW1lLCBqb2luSWRLZXlWYWx1ZXMpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gcG9vbC5zcGFuUmVjb3Jkcy5hY3F1aXJlKCk7XG4gICAgcmVjb3JkLnNwYW5fZ3VpZCAgICAgPSBwbGF0Zm9ybS5nZW5lcmF0ZUdVSUQoKTtcbiAgICByZWNvcmQucnVudGltZV9ndWlkICA9IHRoaXMucnVudGltZS5ndWlkO1xuICAgIHJlY29yZC5zcGFuX25hbWUgICAgID0gbmFtZTtcbiAgICByZWNvcmQub2xkZXN0X21pY3JvcyA9IHRoaXMubm93TWljcm9zKCk7XG4gICAgcmVjb3JkLnlvdW5nZXN0X21pY3JvcyA9IG51bGw7XG4gICAgcmVjb3JkLmpvaW5faWRzICAgICAgPSBbXTtcbiAgICByZWNvcmQuYXR0cmlidXRlcyAgICA9IFtdO1xuXG4gICAgdGhpcy5tZXJnZUpvaW5JZE1hcEludG9TcGFuUmVjb3JkKHJlY29yZCwgam9pbklkS2V5VmFsdWVzKTtcblxuICAgIGlmICh0aGlzLnZlcmJvc2UpIHtcbiAgICAgICAgdGhpcy5sb2dSZWNvcmQoe1xuICAgICAgICAgICAgc3RhYmxlX25hbWUgOiBcImNyL3NwYW5fYmVnaW5cIixcbiAgICAgICAgICAgIG1lc3NhZ2UgICAgIDogbmFtZSxcbiAgICAgICAgICAgIHBheWxvYWQgICAgIDoge1xuICAgICAgICAgICAgICAgIG5hbWUgICAgICAgICAgICAgIDogbmFtZSxcbiAgICAgICAgICAgICAgICBndWlkICAgICAgICAgICAgICA6IHJlY29yZC5zcGFuX2d1aWQsXG4gICAgICAgICAgICAgICAgZXhwbGljaXRfam9pbl9pZHMgOiBqb2luSWRLZXlWYWx1ZXMsXG4gICAgICAgICAgICAgICAgbWVyZ2VkX2pvaW5faWRzICAgOiByZWNvcmQuam9pbl9pZHMsXG4gICAgICAgICAgICAgICAgam9pbl9pZF9zdGFjayAgICAgOiB0aGlzLmdldEFjdGl2ZUpvaW5JZHNTdGFjaygpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0YWNrX2ZyYW1lcyA6IHRoaXMucGxhdGZvcm0uc3RhY2tUcmFjZSgwLCB0cnVlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZWNvcmQ7XG59O1xuXG4vLyBNZXJnZSBhIEpTIG1hcCBvZiBrZXktdmFsdWUgcGFpcnMgaW50byB0aGUgc3BhbiByZWNvcmQncyB0aHJpZnQgam9pbiBpZHNcbi8vIHN0cnVjdHVyZXMuICBVc2UgdGhpcyBtZXRob2QgcmF0aGVyIHRoYW4gZG9pbmcgdGhpcyBtYW51YWxseSB0byBlbnN1cmUgdGhlXG4vLyBvYmplY3QgcG9vbGluZyBpcyB1dGlsaXplZC5cbi8vXG5TdGF0ZS5wcm90b3R5cGUubWVyZ2VKb2luSWRNYXBJbnRvU3BhblJlY29yZCA9IGZ1bmN0aW9uKHNwYW5SZWNvcmQsIGpvaW5JZE1hcCkge1xuICAgIGlmICgham9pbklkTWFwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTY2FuIGZvciBkdXBsaWNhdGUga2V5cyB0aGF0IG5lZWQgdG8gYmUgcmVwbGFjZWQuICBUaGlzIGlzIGEgbGl0dGxlIGF3a3dhcmRcbiAgICAvLyBzaW5jZSB0aGUgdGhyaWZ0IHN0cnVjdHVyZSBpcyBhIGxpc3Qgb2YgcGFpcnMsIGV2ZW4gdGhvdWdoIGNvbmNlcHR1YWxseSBpdFxuICAgIC8vIGlzIGEgbWFwIHdpdGggdW5pcXVlIGtleXMuXG4gICAgdmFyIHJlcGxhY2VkS2V5cyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BhblJlY29yZC5qb2luX2lkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXhpc3RpbmdLZXkgPSBzcGFuUmVjb3JkLmpvaW5faWRzW2ldLlRyYWNlS2V5O1xuICAgICAgICBpZiAoIShleGlzdGluZ0tleSBpbiBqb2luSWRNYXApKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3VmFsdWUgPSBqb2luSWRNYXBbZXhpc3RpbmdLZXldO1xuICAgICAgICByZXBsYWNlZEtleXNbZXhpc3RpbmdLZXldID0gdHJ1ZTtcbiAgICAgICAgc3BhblJlY29yZC5qb2luX2lkc1tpXS5WYWx1ZSA9IFN0cmluZyhuZXdWYWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gQXBwZW5kIGFueSBuZXcga2V5c1xuICAgIGZvciAodmFyIGtleSBpbiBqb2luSWRNYXApIHtcbiAgICAgICAgaWYgKHJlcGxhY2VkS2V5c1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGpvaW5JZE1hcFtrZXldO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBqb2luSWQgPSBwb29sLnRyYWNlSm9pbklkcy5hY3F1aXJlKCk7XG4gICAgICAgICAgICBqb2luSWQuVHJhY2VLZXkgPSBTdHJpbmcoa2V5KTtcbiAgICAgICAgICAgIGpvaW5JZC5WYWx1ZSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICBzcGFuUmVjb3JkLmpvaW5faWRzLnB1c2goam9pbklkKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vIFJldHVybnMgbnVsbCBpZiB0aGUgdmFsdWUgc2hvdWxkIGJlIHNraXBwZWQsIG90aGVyd2lzZSBhIHZhbGlkXG4vLyAoYnV0IHBvdGVudGlhbGx5IGVtcHR5KSBzdHJpbmcuXG5mdW5jdGlvbiBjb252ZXJ0QXR0cmlidXRlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHZhbHVlVHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICBpZiAodmFsdWVUeXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBkZWZhdWx0IGNvbnZlcnNpb24gaWYgSlNPTiBlbmNvZGluZyBmYWlsc1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG59XG5cblN0YXRlLnByb3RvdHlwZS5tZXJnZUF0dHJpYnV0ZXNJbnRvU3BhblJlY29yZCA9IGZ1bmN0aW9uKHNwYW5SZWNvcmQsIGF0dHJNYXApIHtcbiAgICBpZiAoIWF0dHJNYXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNjYW4gZm9yIGR1cGxpY2F0ZSBrZXlzIHRoYXQgbmVlZCB0byBiZSByZXBsYWNlZC4gIFRoaXMgaXMgYSBsaXR0bGUgYXdrd2FyZFxuICAgIC8vIHNpbmNlIHRoZSB0aHJpZnQgc3RydWN0dXJlIGlzIGEgbGlzdCBvZiBwYWlycywgZXZlbiB0aG91Z2ggY29uY2VwdHVhbGx5IGl0XG4gICAgLy8gaXMgYSBtYXAgd2l0aCB1bmlxdWUga2V5cy5cbiAgICB2YXIgcmVwbGFjZWRLZXlzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFuUmVjb3JkLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGV4aXN0aW5nS2V5ID0gc3BhblJlY29yZC5hdHRyaWJ1dGVzW2ldLktleTtcbiAgICAgICAgaWYgKCEoZXhpc3RpbmdLZXkgaW4gYXR0ck1hcCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IGNvbnZlcnRBdHRyaWJ1dGVWYWx1ZShhdHRyTWFwW2V4aXN0aW5nS2V5XSk7XG4gICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVwbGFjZWRLZXlzW2V4aXN0aW5nS2V5XSA9IHRydWU7XG4gICAgICAgIHNwYW5SZWNvcmQuYXR0cmlidXRlc1tpXS5WYWx1ZSA9IFN0cmluZyhuZXdWYWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gQXBwZW5kIGFueSBuZXcga2V5c1xuICAgIGZvciAodmFyIGtleSBpbiBhdHRyTWFwKSB7XG4gICAgICAgIGlmIChrZXkgPT09IG51bGwgfHwga2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXBsYWNlZEtleXNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBjb252ZXJ0QXR0cmlidXRlVmFsdWUoYXR0ck1hcFtrZXldKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBhaXIgPSBwb29sLmtleVZhbHVlLmFjcXVpcmUoKTtcbiAgICAgICAgICAgIHBhaXIuS2V5ID0gU3RyaW5nKGtleSk7XG4gICAgICAgICAgICBwYWlyLlZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBzcGFuUmVjb3JkLmF0dHJpYnV0ZXMucHVzaChwYWlyKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vIENyZWF0ZSB0aGUgXCJoYW5kbGVcIiBvYmplY3QgZm9yIGEgZ2l2ZW4gc3BhbiByZWNvcmQuXG5TdGF0ZS5wcm90b3R5cGUuY3JlYXRlU3BhbkhhbmRsZSA9IGZ1bmN0aW9uIChzcGFuUmVjb3JkKSB7XG4gICAgcmV0dXJuIHNwYW5faGFuZGxlLmFjcXVpcmUodGhpcywgc3BhblJlY29yZCk7XG59O1xuXG4vLyBTdGFydCBhIG5ldyBzcGFuIGFuZCByZXR1cm4gYSBoYW5kbGUgaW50ZXJmYWNlIGZvciBjb250cm9sbGluZyB0aGUgc3Bhbi5cbi8vXG4vLyBWYWxpZCBzaWduYXR1cmVzOlxuLy9cbi8vIHZhciBoYW5kbGUgPSBjci5zcGFuKFwibXlfc3Bhbl9uYW1lXCIpO1xuLy8gdmFyIGhhbmRsZSA9IGNyLnNwYW4oXCJteV9zcGFuX25hbWVcIiwgeyBteV9rZXkgOiBcIm15X3ZhbHVlXCIgfSk7XG4vLyB2YXIgcmVzdWx0ID0gY3Iuc3BhbihcIm15X3NwYW5fbmFtZVwiLCB7IG15X2tleSA6IFwibXlfdmFsdWVcIiB9LCBmdW5jdGlvbihoYW5kbGUpIHtcbi8vICAgICAgcmV0dXJuIDQyLjA7XG4vLyB9KTtcbi8vXG4vLyBUaGUgdGhpcmQgc2lnbmF0dXJlIHdpbGwgYXV0b21hdGljYWxseSBzZXQgdGhlIHNwYW4gYXMgYWN0aXZlIGZvciB0aGVcbi8vIGR1cmF0aW9uIG9mIHRoZSBjYWxsdGhyb3VnaDsgaXQgZG9lcyAqbm90KiwgaG93ZXZlciwgYXV0b21hdGljYWxseSBjYWxsXG4vLyBlbmQoKSBvbiB0aGUgc3Bhbi5cbi8vXG4vLyBUaGUgbmV3bHkgY3JlYXRlZCBzcGFuIHdpdGggaW5oZXJpdCBhbnkgZ2xvYmFsbHkgc2V0IGpvaW4gSURzIGFzIHdlbGwgYXNcbi8vIHRoZSBqb2luIElEcyBvZiB0aGUgbmVhcmVzdCBhY3RpdmUgc3Bhbi5cbi8vXG5TdGF0ZS5wcm90b3R5cGUuc3BhbiA9IGZ1bmN0aW9uIChuYW1lLCBqb2luSWRLZXlWYWx1ZXMsIGNhbGx0aHJvdWdoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIGpvaW5JZEtleVZhbHVlcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGx0aHJvdWdoID0gam9pbklkS2V5VmFsdWVzO1xuICAgICAgICBqb2luSWRLZXlWYWx1ZXMgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBoYW5kbGU7XG5cbiAgICBpZiAoIXRoaXMuZW5hYmxlZCkge1xuICAgICAgICBoYW5kbGUgPSBzcGFuX2hhbmRsZS5nZXROb09wSGFuZGxlKCk7XG4gICAgICAgIGlmIChjYWxsdGhyb3VnaCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGx0aHJvdWdoKGhhbmRsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICB9XG5cbiAgICAvLyBBbHdheXMgaW5oZXJpdCB0aGUgam9pbiBJRHMgZnJvbSB0aGUgdG9wLW1vc3QgYWN0aXZlIHNwYW4uXG4gICAgLy9cbiAgICAvLyBOb3RlOiBtZXJnZSBpbnRvIHRoZSBhY3RpdmVTcGFuIGpvaW5JZHMgb2JqZWN0IHRvIGF2b2lkIG1vZGlmeWluZ1xuICAgIC8vIHRoZSBpbmNvbWluZyBhcmd1bWVudCAtLSBsZXNzIHJpc2sgb2YgdW5pbnRlbmRlZCBzaWRlLWVmZmVjdHMuXG4gICAgdmFyIGFjdGl2ZUpvaW5JZHMgPSB0aGlzLmdldEFjdGl2ZUpvaW5JZHMoKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gam9pbklkS2V5VmFsdWVzKSB7XG4gICAgICAgIGFjdGl2ZUpvaW5JZHNba2V5XSA9IGpvaW5JZEtleVZhbHVlc1trZXldO1xuICAgIH1cbiAgICBqb2luSWRLZXlWYWx1ZXMgPSBhY3RpdmVKb2luSWRzO1xuXG4gICAgdmFyIHJlY29yZCA9IHRoaXMucmF3U3BhbkJlZ2luKG5hbWUsIGpvaW5JZEtleVZhbHVlcyk7XG4gICAgaGFuZGxlID0gdGhpcy5jcmVhdGVTcGFuSGFuZGxlKHJlY29yZCk7XG4gICAgaWYgKGNhbGx0aHJvdWdoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldEFjdGl2ZVNwYW4oaGFuZGxlLCBudWxsLCBbIGhhbmRsZSBdLCBjYWxsdGhyb3VnaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICB9XG59O1xuXG4vLyBXcmFwIGEgc3luY2hyb25vdXMgZnVuY3Rpb24gaW5zaWRlIGEgc3BhbiBhbmQgcmV0dXJuIHRoZSB3cmFwcGVyIGZ1bmN0aW9uLlxuLy8gQSBtYXAgb2Ygam9pbiBpZHMgY2FuIG9wdGlvbmFsbHkgYmUgcGFzc2VkIGluIGFzIGEgc2Vjb25kIGFyZ3VtZW50LiAgTm90ZVxuLy8gdGhpcyB3aWxsIG5vdCB3b3JrIGFzIGV4cGVjdGVkIHdpdGggYXN5bmNocm9ub3VzIGZ1bmN0aW9ucyB0aGF0IHNpZ25hbFxuLy8gY29tcGxldGlvbiB2aWEgYW4gcHJvbWlzZSwgZXZlbnQsIG9yIGNhbGxiYWNrLlxuLy9cbi8vIGZ1bmN0aW9uIGFkZCh4LCB5KSB7IHJldHVybiB4ICsgeTsgfVxuLy9cbi8vIHZhciBhZGQgPSBjci5zcGFuV3JhcChcImFkZFwiLCBhZGQpO1xuLy8gdmFyIHogPSBhZGQoMSwgMik7XG4vL1xuU3RhdGUucHJvdG90eXBlLnNwYW5XcmFwID0gZnVuY3Rpb24gKG5hbWUsIGpvaW5JZEtleVZhbHVlcywgZikge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpIHtcbiAgICAgICAgZiA9IGpvaW5JZEtleVZhbHVlcztcbiAgICAgICAgam9pbklkS2V5VmFsdWVzID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaGFuZGxlID0gc2VsZi5zcGFuKG5hbWUsIGpvaW5JZEtleVZhbHVlcyk7XG4gICAgICAgIHZhciByO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgciA9IGYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgc2VsZi5sb2dFeGNlcHRpb24oZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaGFuZGxlLmVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG59O1xuXG4vLyBXcmFwIGEgYmxvY2sgb2Ygc3luY2hyb25vdXMgY29kZSBpbnNpZGUgYSBzcGFuLiAgVGhlIGNvZGUgd2lsbCBiZSBleGVjdXRlZFxuLy8gaW1tZWRpYXRlbHkuICBUaGlzIGlzIGFuIGFsdGVybmF0aXZlIHRvIGV4cGxpY2l0bHkgc3Vycm91bmRpbmcgdGhlIGJsb2NrXG4vLyBvZiBjb2RlIHdpdGggc3BhbiBjcmVhdGlvbiBhbmQgZW5kKCkgY2FsbCB0aGF0IHdpbGwgYXV0b21hdGljYWxseSBjYXRjaFxuLy8gYW5kIGxvZyBleGNlcHRpb25zIGJlZm9yZSByZXRocm93aW5nIHRoZW0uXG4vL1xuLy8gdmFyIHogPSAwO1xuLy8gY3Iuc3BhblNlY3Rpb24oXCJpbm5lcl9jb21wdXRhdGlvblwiLCBmdW5jdGlvbigpIHtcbi8vICAgICAgeiA9IDQgKiAyO1xuLy8gfSk7XG4vL1xuU3RhdGUucHJvdG90eXBlLnNwYW5TZWN0aW9uID0gZnVuY3Rpb24gKG5hbWUsIGpvaW5JZEtleVZhbHVlcywgZikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGYgPSBqb2luSWRLZXlWYWx1ZXM7XG4gICAgICAgIGpvaW5JZEtleVZhbHVlcyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBoYW5kbGUgPSB0aGlzLnNwYW4obmFtZSwgam9pbklkS2V5VmFsdWVzKTtcbiAgICB2YXIgcjtcbiAgICB0cnkge1xuICAgICAgICByID0gZigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5sb2dFeGNlcHRpb24oZSk7XG4gICAgICAgIHRocm93IGU7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaGFuZGxlLmVuZCgpO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbn07XG5cbi8vIEEgbWFudWFsbHkgY3JlYXRlZCBzcGFuLlxuU3RhdGUucHJvdG90eXBlLnNwYW5NYW51YWwgPSBmdW5jdGlvbiAobmFtZSwgb2xkZXN0TWljcm9zLCB5b3VuZ2VzdE1pY3Jvcykge1xuICAgIGlmICghdGhpcy5lbmFibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHJlY29yZCA9IHRoaXMucmF3U3BhbkJlZ2luKG5hbWUpO1xuICAgIHJlY29yZC5vbGRlc3RfbWljcm9zID0gb2xkZXN0TWljcm9zO1xuICAgIHJlY29yZC55b3VuZ2VzdF9taWNyb3MgPSB5b3VuZ2VzdE1pY3JvcztcbiAgICB0aGlzLnB1c2hTcGFuUmVjb3JkKHJlY29yZCk7XG4gICAgcmV0dXJuIHJlY29yZC5zcGFuX2d1aWQ7XG59O1xuXG5TdGF0ZS5wcm90b3R5cGUuc3BhbkFwcGx5SW1wID0gZnVuY3Rpb24gKG9wZXJhdGlvbiwgam9pbklkcywgYXN5bmMsIGYsIHNlbGZBcmcsIGNhbGxBcmdzKSB7XG5cbiAgICB2YXIgaGFuZGxlID0gdGhpcy5zcGFuKG9wZXJhdGlvbiwgam9pbklkcyk7XG5cbiAgICAvLyBBc3N1bWUgdGhlIGNvbnZlbnRpb24gdGhhdCB0aGUgbGFzdCBhcmd1bWVudCBpcyB0aGUgXCJkb25lXCIgLyBcIm5leHRcIiBjYWxsYmFjay5cbiAgICBpZiAoYXN5bmMpIHtcbiAgICAgICAgdmFyIGRvbmUgPSBjYWxsQXJnc1tjYWxsQXJncy5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAodHlwZW9mIGRvbmUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudDogZXhwZWN0ZWQgbGFzdCBhcmd1bWVudCB0byBiZSBvZiB0eXBlIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FsbEFyZ3NbY2FsbEFyZ3MubGVuZ3RoIC0gMV0gPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlLmVycm9yKFwiRXJyb3IgcGFzc2VkIHRvIGNhbGxiYWNrXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgOiBlcnIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kbGUubG9nKFwiQ2FsbGJhY2sgaW52b2tlZFwiLCB7XG4gICAgICAgICAgICAgICAgXCJlcnJvclwiICAgICA6IGVycixcbiAgICAgICAgICAgICAgICBcImFyZ3VtZW50c1wiIDogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBoYW5kbGUuZW5kKCk7XG5cbiAgICAgICAgICAgIHJldHVybiBkb25lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hY3RpdmVTcGFuT3JKb2luSURzU3RhY2sucHVzaChoYW5kbGUpO1xuICAgIH1cblxuXG4gICAgdmFyIHJldDtcbiAgICB0cnkge1xuICAgICAgICBoYW5kbGUubG9nKFwiQ2FsbCBpbnZva2VkXCIsIHtcbiAgICAgICAgICAgIFwidGhpc1wiICAgICAgOiBzZWxmQXJnLFxuICAgICAgICAgICAgXCJhcmd1bWVudHNcIiA6IGNhbGxBcmdzLFxuICAgICAgICB9KTtcblxuICAgICAgICByZXQgPSBmLmFwcGx5KHNlbGZBcmcsIGNhbGxBcmdzKTtcblxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5sb2dFeGNlcHRpb24oZSk7XG4gICAgICAgIHRocm93IGU7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKCFhc3luYykge1xuICAgICAgICAgICAgaGFuZGxlLmVuZCgpO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVTcGFuT3JKb2luSURzU3RhY2sucG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlLmxvZyhcIkNhbGwgcmV0dXJuZWRcIiwge1xuICAgICAgICBcInZhbHVlXCIgOiByZXQsXG4gICAgfSk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblN0YXRlLnByb3RvdHlwZS5jYWxsU3luYyA9IGZ1bmN0aW9uIChvcGVyYXRpb24sIGpvaW5JZHMsIGYsIHNlbGZBcmcpIHtcbiAgICAvLyBOb3JtYWxpemUgYXJndW1lbnRzXG4gICAgdmFyIGNhbGxBcmdzO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG51bWJlciBvZiBhcmd1bWVudHNcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygam9pbklkcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAzKTtcbiAgICAgICAgc2VsZkFyZyA9IGY7XG4gICAgICAgIGYgPSBqb2luSWRzO1xuICAgICAgICBqb2luSWRzID0ge307XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbEFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zcGFuQXBwbHlJbXAob3BlcmF0aW9uLCBqb2luSWRzLCBmYWxzZSwgZiwgc2VsZkFyZywgY2FsbEFyZ3MpO1xufTtcblxuU3RhdGUucHJvdG90eXBlLmFwcGx5U3luYyA9IGZ1bmN0aW9uIChvcGVyYXRpb24sIGpvaW5JZHMsIGYsIHNlbGZBcmcsIGNhbGxBcmdzKSB7XG4gICAgLy8gTm9ybWFsaXplIGFyZ3VtZW50c1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG51bWJlciBvZiBhcmd1bWVudHNcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygam9pbklkcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxBcmdzID0gc2VsZkFyZztcbiAgICAgICAgc2VsZkFyZyA9IGY7XG4gICAgICAgIGYgPSBqb2luSWRzO1xuICAgICAgICBqb2luSWRzID0ge307XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNwYW5BcHBseUltcChvcGVyYXRpb24sIGpvaW5JZHMsIGZhbHNlLCBmLCBzZWxmQXJnLCBjYWxsQXJncyk7XG59O1xuXG5TdGF0ZS5wcm90b3R5cGUuY2FsbEFzeW5jID0gZnVuY3Rpb24gKG9wZXJhdGlvbiwgam9pbklkcywgZiwgc2VsZkFyZykge1xuICAgIC8vIE5vcm1hbGl6ZSBhcmd1bWVudHNcbiAgICB2YXIgY2FsbEFyZ3M7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50c1wiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBqb2luSWRzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbEFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpO1xuICAgICAgICBzZWxmQXJnID0gZjtcbiAgICAgICAgZiA9IGpvaW5JZHM7XG4gICAgICAgIGpvaW5JZHMgPSB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgNCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNwYW5BcHBseUltcChvcGVyYXRpb24sIGpvaW5JZHMsIHRydWUsIGYsIHNlbGZBcmcsIGNhbGxBcmdzKTtcbn07XG5cblN0YXRlLnByb3RvdHlwZS5hcHBseUFzeW5jID0gZnVuY3Rpb24gKG9wZXJhdGlvbiwgam9pbklkcywgZiwgc2VsZkFyZywgY2FsbEFyZ3MpIHtcbiAgICAvLyBOb3JtYWxpemUgYXJndW1lbnRzXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50c1wiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBqb2luSWRzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbEFyZ3MgPSBzZWxmQXJnO1xuICAgICAgICBzZWxmQXJnID0gZjtcbiAgICAgICAgZiA9IGpvaW5JZHM7XG4gICAgICAgIGpvaW5JZHMgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3BhbkFwcGx5SW1wKG9wZXJhdGlvbiwgam9pbklkcywgdHJ1ZSwgZiwgc2VsZkFyZywgY2FsbEFyZ3MpO1xufTtcblxuLy8gQWRkIGEgc3BhbiByZWNvcmQgdG8gdGhlIGludGVybmFsIGJ1ZmZlclxuU3RhdGUucHJvdG90eXBlLnB1c2hTcGFuUmVjb3JkID0gZnVuY3Rpb24ocmVjb3JkKSB7XG4gICAgLy8gTWVyZ2UgaW4gYW55IGdsb2JhbCBqb2luIGlkcyAtLSBkbyB0aGlzIGF0IHRoZSBlbmQgb2YgdGhlIHNwYW4gYXNcbiAgICAvLyB0aGlzIGFsbG93cyBzb21lIHNwYW5zIHRoYXQgbWF5IGhhdmUgYmVlbiBhdXRvbWF0aWNhbGx5IGNyZWF0ZWRcbiAgICAvLyBieSB0aGUgY3J1bnRpbWUgYmVmb3JlIHRoZSB1c2VyIHNldCB0aGUgZ2xvYmFsIGpvaW4gaWRzIHRvIHN0aWxsXG4gICAgLy8gY2FwdHVyZSB0aG9zZSBnbG9iYWwgam9pbiBpZHMuXG4gICAgdGhpcy5tZXJnZUpvaW5JZE1hcEludG9TcGFuUmVjb3JkKHJlY29yZCwgdGhpcy5qb2luSWRzKTtcblxuICAgIC8vIFRPRE86IHRoZSBUaHJpZnQgZmllbGRzIG9uIHRoZSByZWNvcmQgc2hvdWxkIGJlIGNoZWNrZWQgaGVyZSB0byBiZVxuICAgIC8vIHN1cmUgdGhleSdyZSB0aGUgcmlnaHQgZGF0YSB0eXBlIG9yIGVsc2UgdGhyaWZ0IHdpbGwgdGhyb3cgYW5cbiAgICAvLyBleGNlcHRpb24uXG5cbiAgICBpZiAodGhpcy5zcGFucy5sZW5ndGggPj0gdGhpcy5idWZmZXJNYXhTcGFuUmVjb3Jkcykge1xuICAgICAgICAvLyBUcmVhdCB0aGlzIGxpa2UgYSByYW5kb20gc2FtcGxpbmcgYW5kIHJlcGxhY2UgYSByZWNvcmQgYXQgcmFuZG9tLlxuICAgICAgICAvLyBUaGlzIGlzIG5vdCB0cnVseSByYW5kb20gaW4gbWF0aGVtYXRpY2FsIHNlbnNlIGZvciBhIG51bWJlciBvZiByZWFzb25zLFxuICAgICAgICAvLyBidXQgdGhlIGFzc3VtcHRpb24gdGhpcyBpcyBwcm92aWRlcyBtb3JlIHVzZWZ1bCBpbmZvcm1hdGlvbiB0aGFuXG4gICAgICAgIC8vIGRyb3BwaW5nIGFsbCByZWNvcmRzIG9uY2UgdGhlIG1heCBpcyBoaXQuXG4gICAgICAgIHZhciBpbmRleCA9IE1hdGguZmxvb3IodGhpcy5zcGFucy5sZW5ndGggKiBNYXRoLnJhbmRvbSgpKTtcbiAgICAgICAgcmVsZWFzZVNwYW5SZWNvcmQodGhpcy5zcGFuc1tpbmRleF0pO1xuICAgICAgICB0aGlzLnNwYW5zW2luZGV4XSA9IHJlY29yZDtcbiAgICAgICAgdGhpcy5jb3VudGVycy5kcm9wcGVkX3NwYW5zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zcGFucy5wdXNoKHJlY29yZCk7XG4gICAgfVxufTtcblxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuLy8gU3RhdHNcbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cblxuLy8gUHJpbWFyaWx5IGludGVuZGVkIGZvciBkZWJ1Z2dpbmdcblN0YXRlLnByb3RvdHlwZS5yZXBvcnRCdWZmZXJTdGF0cyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIHJ1bnRpbWVBdHRycyA9IHt9O1xuICAgIGlmICh0aGlzLnJ1bnRpbWUuYXR0cnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJ1bnRpbWUuYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBhdHRyID0gdGhpcy5ydW50aW1lLmF0dHJzW2ldO1xuICAgICAgICAgICAgcnVudGltZUF0dHJzW2F0dHIuS2V5XSA9IGF0dHIuVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAvLyBCYXNpYyBjb25maWd1cmF0aW9uXG4gICAgICAgIHNlcnZpY2VfaG9zdCAgICAgICAgOiB0aGlzLnNlcnZpY2VIb3N0LFxuICAgICAgICBzZXJ2aWNlX3BvcnQgICAgICAgIDogdGhpcy5zZXJ2aWNlUG9ydCxcbiAgICAgICAgcnVudGltZSAgICAgICAgICAgICA6IHRoaXMucnVudGltZSxcbiAgICAgICAgYXV0aCAgICAgICAgICAgICAgICA6IHRoaXMuYXV0aCxcblxuICAgICAgICAvLyBSdW50aW1lIGF0dHJpYnV0ZXNcbiAgICAgICAgcnVudGltZV9hdHRyaWJ1dGVzICA6IHJ1bnRpbWVBdHRycyxcbiAgICAgICAgc3RhdGlzdGljcyAgICAgICAgICA6IHRoaXMuc3RhdHMsXG5cbiAgICAgICAgLy8gQ3VycmVudCBidWZmZXIgc3RhdHNcbiAgICAgICAgcXVldWVkX2xvZ3MgICAgICAgICA6IHRoaXMubG9ncy5sZW5ndGgsXG4gICAgICAgIHF1ZXVlZF9zcGFucyAgICAgICAgOiB0aGlzLnNwYW5zLmxlbmd0aCxcbiAgICAgICAgbWF4X2xvZ19yZWNvcmRzICAgICA6IHRoaXMuYnVmZmVyTWF4TG9nUmVjb3JkcyxcbiAgICAgICAgbWF4X3NwYW5fcmVjb3JkcyAgICA6IHRoaXMuYnVmZmVyTWF4U3BhblJlY29yZHMsXG5cbiAgICAgICAgLy8gTWVtb3J5IHBvb2xpbmcgc3RhdHNcbiAgICAgICAgbG9nX3JlY29yZHNfYWxsb2NhdGVkICA6IHBvb2wubG9nUmVjb3Jkcy5hbGxvY2F0aW9uQ291bnQsXG4gICAgICAgIGxvZ19yZWNvcmRzX2FjcXVpcmVkICAgOiBwb29sLmxvZ1JlY29yZHMuYWNxdWlyZUNvdW50LFxuICAgICAgICBsb2dfcmVjb3Jkc19yZWxlYXNlZCAgIDogcG9vbC5sb2dSZWNvcmRzLnJlbGVhc2VDb3VudCxcbiAgICAgICAgbG9nX3JlY29yZHNfYWN0aXZlICAgICA6IHBvb2wubG9nUmVjb3Jkcy5hbGxvY2F0aW9uQ291bnQgLSBwb29sLmxvZ1JlY29yZHMuZnJlZUxpc3QubGVuZ3RoLFxuXG4gICAgICAgIHNwYW5fcmVjb3Jkc19hbGxvY2F0ZWQgOiBwb29sLnNwYW5SZWNvcmRzLmFsbG9jYXRpb25Db3VudCxcbiAgICAgICAgc3Bhbl9yZWNvcmRzX2FjcXVpcmVkICA6IHBvb2wuc3BhblJlY29yZHMuYWNxdWlyZUNvdW50LFxuICAgICAgICBzcGFuX3JlY29yZHNfcmVsZWFzZWQgIDogcG9vbC5zcGFuUmVjb3Jkcy5yZWxlYXNlQ291bnQsXG4gICAgICAgIHNwYW5fcmVjb3Jkc19hY3RpdmUgICAgOiBwb29sLnNwYW5SZWNvcmRzLmFsbG9jYXRpb25Db3VudCAtIHBvb2wuc3BhblJlY29yZHMuZnJlZUxpc3QubGVuZ3RoLFxuXG4gICAgICAgIGpvaW5faWRzX2FsbG9jYXRlZCAgICAgOiBwb29sLnRyYWNlSm9pbklkcy5hbGxvY2F0aW9uQ291bnQsXG4gICAgICAgIGpvaW5faWRzX2FjcXVpcmVkICAgICAgOiBwb29sLnRyYWNlSm9pbklkcy5hY3F1aXJlQ291bnQsXG4gICAgICAgIGpvaW5faWRzX3JlbGVhc2VkICAgICAgOiBwb29sLnRyYWNlSm9pbklkcy5yZWxlYXNlQ291bnQsXG4gICAgICAgIGpvaW5faWRzX2FjdGl2ZSAgICAgICAgOiBwb29sLnRyYWNlSm9pbklkcy5hbGxvY2F0aW9uQ291bnQgLSBwb29sLnRyYWNlSm9pbklkcy5mcmVlTGlzdC5sZW5ndGgsXG4gICAgfTtcbn07XG5cbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cbi8vIEV4cG9ydHNcbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZTtcbiIsIi8vIEEgZml4ZWQgc2l6ZSBidWZmZXIgc3RvcmluZyBzYW1wbGUgY291bnRzIG92ZXIgYSBzZXQgb2YgdGltZSByYW5nZXMuXG4vL1xuLy8gVGhpcyBpcyBzcGVjaWZpY2FsbHkgYmVpbmcgdXNlZCBmb3IgcmVjb3JkIGFwcHJveGltYXRlbHkgaG93IG1hbnkgbG9nL3NwYW5cbi8vIHJlY29yZHMgd2VyZSBkaXNjYXJkZWQgb3ZlciBhIGdpdmVuIHBlcmlvZCBvZiB0aW1lLiAgVGhpcyBwcm92aWRlcyB0aGVcbi8vIHNlcnZlciB3aXRoIHNvbWUgbm90aW9uIG9mIHdoYXQgd2FzICpub3QqIHJlcG9ydGVkIHdpdGhvdXQgY29uc3VtaW5nIGFcbi8vIGxvdCBvZiBiYW5kd2lkdGguXG4vL1xuLy8gQXJndW1lbnRzOlxuLy9cbi8vIG1heEJ1Y2tldHMgICAtLSB0aGUgbWF4aW11bSBudW1iZXIgb2YgYnVja2V0cyB0byB1c2UgcmVnYXJkbGVzcyBvZiB0b3RhbFxuLy8gICAgICAgICAgICAgICAgIHNhbXBsZSBjb3VudFxuLy8gZ3JhbnVsYXJpdHkgIC0tIHRoZSBidWNrZXQgc2l6ZSBleHByZXNzZWQgYXMgYmFzZS0xMCBleHBvbmVudCwgaS5lLiBhc3N1bWluZ1xuLy8gICAgICAgICAgICAgICAgIG1pY3Jvc2Vjb25kIHNhbXBsZXMsIHRoZSBpbml0aWFsIGdyYW51bGFyaXR5IHZhbHVlcyBtYXAgYXM6XG4vLyAgICAgICAgICAgICAgICAgMCA9PiBtaWNyb3NlY29uZHNcbi8vICAgICAgICAgICAgICAgICAzID0+IG1pbGxpc2Vjb25kc1xuLy8gICAgICAgICAgICAgICAgIDYgPT4gc2Vjb25kc1xuLy9cbi8vIFRoZSBpbXBsZW1lbnRhdGlvbiBpdHNlbGYgaGFzIHR3byBwcmltYXJ5IG9iamVjdGl2ZXM6XG4vL1xuLy8gKDEpIFVzZSBhIGZpeGVkIG1heGltdW0gYW1vdW50IG9mIG1lbW9yeSByZWdhcmRsZXNzIG9mICMgb2Ygc2FtcGxlcyBhZGRlZFxuLy8gICAgIHRvIHRoZSBidWZmZXIuXG4vLyAoMikgS2VlcCB0aGUgaW1wbGVtZW50YXRpb24gdmVyeSBzaW1wbGUgc28gaXQncyBub3QgYWRkaW5nIGFueSBzb3VyY2Ugb2Zcbi8vICAgICBjb2RlIGNvbXBsZXhpdHkgYW5kL29yIGRlZmVjdHMuXG4vL1xuZnVuY3Rpb24gVGltZXN0YW1wU2FtcGxlcyhtYXhCdWNrZXRzLCBncmFudWxhcml0eSkge1xuICAgIHRoaXMubWF4QnVja2V0cyAgID0gbWF4QnVja2V0cztcbiAgICB0aGlzLm1pbk1hZ25pdHVkZSA9IE1hdGgucG93KDEwLCBncmFudWxhcml0eSk7XG5cbiAgICAvLyBOb3RlOiB0aGlzIHdpbGwgaW5pdGlhbGl6ZSB0aGUgcmVzdCBvZiB0aGUgb2JqZWN0IGZpZWxkc1xuICAgIHRoaXMuY2xlYXIoKTtcbn1cblxuVGltZXN0YW1wU2FtcGxlcy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5idWNrZXRzICAgICA9IHt9O1xuICAgIHRoaXMuYnVja2V0Q291bnQgPSAwO1xuICAgIHRoaXMuc2FtcGxlQ291bnQgPSAwO1xuICAgIHRoaXMubWFnbml0dWRlICAgPSB0aGlzLm1pbk1hZ25pdHVkZTtcbn07XG5cblRpbWVzdGFtcFNhbXBsZXMucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh0aW1lc3RhbXApIHtcbiAgICB2YXIga2V5ID0gTWF0aC5mbG9vcih0aW1lc3RhbXAgLyB0aGlzLm1hZ25pdHVkZSk7XG5cbiAgICAvLyBUaGVyZSdzIGFuIGV4aXN0aW5nIGJ1Y2tldCBmb3IgdGhpcyBzYW1wbGUsIGp1c3QgYWRkIHRvXG4gICAgLy8gdGhlIHRvdGFsLlxuICAgIGlmICh0aGlzLmJ1Y2tldHNba2V5XSkge1xuICAgICAgICB0aGlzLmJ1Y2tldHNba2V5XSsrO1xuICAgICAgICB0aGlzLnNhbXBsZUNvdW50Kys7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUaGVyZSdzIG5vIGV4aXN0aW5nIGJ1Y2tldCwgYnV0IHRoZXJlJ3Mgc3RpbGwgY2FwYWNpdHkgZm9yXG4gICAgLy8gYSBuZXcgYnVja2V0IHRvIGJlIGNyZWF0ZWRcbiAgICAvL1xuICAgIC8vIFRoZSBtaW4gZm9yIGEgYnVja2V0IGlzIGltcGxpY2l0bHkgKGtleSAqIG1hZ25pdHVkZSkuXG4gICAgLy8gVGhlIG1heCBmb3IgYSBidWNrZXQgaXMgaW1wbGljaXRseSAoa2V5ICogbWFnbml0dWRlIC0gMSkuXG4gICAgaWYgKHRoaXMuYnVja2V0Q291bnQgPCB0aGlzLm1heEJ1Y2tldHMpIHtcbiAgICAgICAgdGhpcy5idWNrZXRzW2tleV0gPSAxO1xuICAgICAgICB0aGlzLmJ1Y2tldENvdW50Kys7XG4gICAgICAgIHRoaXMuc2FtcGxlQ291bnQrKztcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vXG4gICAgLy8gUmVkaXN0cmlidXRlIHRoZSBidWNrZXRzIGF0IDEweCBsZXNzIGdyYW51bGFyaXR5XG4gICAgLy8gdGhlbiBhZGQoKS5cbiAgICAvL1xuICAgIHZhciBuZXdCdWNrZXRzID0ge307XG4gICAgdmFyIG5ld0J1Y2tldENvdW50ID0gMDtcbiAgICBmb3IgKHZhciBidWNrZXRLZXkgaW4gdGhpcy5idWNrZXRzKSB7XG4gICAgICAgIHZhciBvbGRCdWNrZXQgPSB0aGlzLmJ1Y2tldHNbYnVja2V0S2V5XTtcbiAgICAgICAgdmFyIG5ld0tleSA9IE1hdGguZmxvb3IoYnVja2V0S2V5IC8gMTApO1xuXG4gICAgICAgIGlmIChuZXdCdWNrZXRzW25ld0tleV0pIHtcbiAgICAgICAgICAgIG5ld0J1Y2tldHNbbmV3S2V5XSArPSBvbGRCdWNrZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdCdWNrZXRzW25ld0tleV0gPSBvbGRCdWNrZXQ7XG4gICAgICAgICAgICBuZXdCdWNrZXRDb3VudCArKztcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmJ1Y2tldHMgPSBuZXdCdWNrZXRzO1xuICAgIHRoaXMuYnVja2V0Q291bnQgPSBuZXdCdWNrZXRDb3VudDtcbiAgICB0aGlzLm1hZ25pdHVkZSAqPSAxMDtcblxuICAgIHRoaXMuYWRkKHRpbWVzdGFtcCk7XG59O1xuXG5UaW1lc3RhbXBTYW1wbGVzLnByb3RvdHlwZS5idWNrZXRBdCA9IGZ1bmN0aW9uKHRpbWVzdGFtcCkge1xuICAgIHZhciBrZXkgPSBNYXRoLmZsb29yKHRpbWVzdGFtcCAvIHRoaXMubWFnbml0dWRlKTtcbiAgICB2YXIgYnVja2V0ID0gdGhpcy5idWNrZXRzW2tleV07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWluICAgOiBrZXkgKiB0aGlzLm1hZ25pdHVkZSxcbiAgICAgICAgbWF4ICAgOiBrZXkgKiB0aGlzLm1hZ25pdHVkZSAtIDEsXG4gICAgICAgIGNvdW50IDogYnVja2V0IHx8IDAsXG4gICAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVGltZXN0YW1wU2FtcGxlcztcbiIsIi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuLy8gRXZlbnRFbWl0dGVyXG4vL1xuLy8gU2ltcGxlIHN1YnNldCBvZiBodHRwOi8vbm9kZWpzLm9yZy9hcGkvZXZlbnRzLmh0bWxcbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZ0LCBsaXN0ZW5lcikge1xuICAgIGNvbnNvbGUuYXNzZXJ0KHR5cGVvZiBsaXN0ZW5lciA9PT0gXCJmdW5jdGlvblwiLCBcInR5cGVvZiBsaXN0ZW5lciBpbmNvcnJlY3Q6IFwiICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgICB2YXIgYXJyID0gdGhpcy5fbGlzdGVuZXJzW2V2dF07XG4gICAgaWYgKCFhcnIpIHtcbiAgICAgICAgYXJyID0gdGhpcy5fbGlzdGVuZXJzW2V2dF0gPSBbXTtcbiAgICB9XG4gICAgYXJyLnB1c2gobGlzdGVuZXIpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChldnQsIGxpc3RlbmVyKSB7XG4gICAgdmFyIHVwZGF0ZWQgPSBbXTtcbiAgICB2YXIgZXhpc3RpbmcgPSB0aGlzLl9saXN0ZW5lcnNbZXZ0XTtcbiAgICBpZiAoIWV4aXN0aW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleGlzdGluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZXhpc3RpbmdbaV0gIT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHVwZGF0ZWQucHVzaChleGlzdGluZ1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fbGlzdGVuZXJzW2V2dF0gPSB1cGRhdGVkO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gKGV2dCwgbGlzdGVuZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHdyYXBwZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbGlzdGVuZXIuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICAgICAgc2VsZi5yZW1vdmVMaXN0ZW5lcih3cmFwcGVyKTtcbiAgICB9O1xuICAgIHNlbGYub24oZXZ0LCB3cmFwcGVyKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW2V2dF07XG4gICAgaWYgKCFsaXN0ZW5lcnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgbGlzdCA9IHRoaXMuX2xpc3RlbmVyc1tldnRdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBsaXN0W2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gKGV2dCkge1xuICAgIHJldHVybiB0aGlzLl9saXN0ZW5lcnNbZXZ0XTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgZXZ0KSB7XG4gICAgaWYgKCFlbWl0dGVyKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICB2YXIgZXZ0TGlzdGVuZXJzID0gZW1pdHRlci5saXN0ZW5lcnMoZXZ0KTtcbiAgICBpZiAoIWV2dExpc3RlbmVycykge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIGV2dExpc3RlbmVycy5sZW5ndGg7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vc3JjL3Byb2Nlc3MuanNcIik7XG4iLCIvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXG4vLyBQb2x5ZmlsbFxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuXG52YXIgaXNBcnJheSA9IChmdW5jdGlvbigpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShvYmopO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSBcIltvYmplY3QgQXJyYXldXCI7XG4gICAgICAgIH07XG4gICAgfVxufSkoKTtcblxuZnVuY3Rpb24gaXNSZWdFeHAgKG9iaikge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IFJlZ0V4cF1cIjtcbn1cblxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuLy8gUHJvY2Vzc29yXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXG5cbmZ1bmN0aW9uIFByb2Nlc3NvcihvcHRzKSB7XG4gICAgdGhpcy5vcHRzID0gb3B0cyB8fCB7fTtcbiAgICB0aGlzLnZhbHVlQ291bnQgPSAwO1xuICAgIHRoaXMuc2VlbiA9IFtdO1xuXG4gICAgdGhpcy5saW1pdFZhbHVlQ291bnQgICAgPSB0aGlzLm9wdHMubGltaXRfdmFsdWVfY291bnQgfHwgNjQ7XG4gICAgdGhpcy5saW1pdFN0cmluZ0xlbmd0aCAgPSB0aGlzLm9wdHMubGltaXRfc3RyaW5nX2xlbmd0aCB8fCA1MTI7XG4gICAgdGhpcy5saW1pdEFycmF5TGVuZ3RoICAgPSB0aGlzLm9wdHMubGltaXRfYXJyYXlfbGVuZ3RoIHx8IDI0O1xuICAgIHRoaXMuYXJyYXlQZWVrTGVuZ3RoICAgID0gdGhpcy5vcHRzLmFycmF5X3BlZWtfbGVuZ3RoIHx8IDU7XG59XG5cblByb2Nlc3Nvci5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uKHZhbHVlLCBvcHRzKSB7XG5cbiAgICAvLyBSZXNldCB0aGUgb2JqZWN0IHN0YXRlXG4gICAgUHJvY2Vzc29yLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgICB2YXIgcGFpciA9IHRoaXMucHJvY2Vzc0Zhc3RQYXRoKHZhbHVlKTtcbiAgICBpZiAocGFpci5vaykge1xuICAgICAgICByZXR1cm4gcGFpci5yZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1Nsb3dQYXRoKHZhbHVlKTtcbiAgICB9XG59O1xuXG4vLyBDaGVjayB0aGUgaXMgdGhlIG9iamVjdCBpcyBcInNpbXBsZVwiIGVub3VnaCB0byBqdXN0IHJlbHkgb25cbi8vIEpTT04uc3RyaW5naWZ5LiBGb3IgYnJldml0eSwgdGhlIHJldHVybiB2YWx1ZSBpcyB0aGUgZmllbGRcbi8vIGNvdW50IC0tIHdoaWNoIHdpbGwgYmUgZ3JlYXRlciB0aGFuIGxpbWl0IGlmIGl0IGlzIG5vdCBhXG4vLyBzaW1wbGUgdmFsdWUuXG5Qcm9jZXNzb3IucHJvdG90eXBlLmlzU2ltcGxlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgc2VsZiAgICAgICAgID0gdGhpcztcbiAgICB2YXIgbGltaXQgICAgICAgID0gc2VsZi5saW1pdFZhbHVlQ291bnQ7XG4gICAgdmFyIGV4Y2VlZHNMaW1pdCA9IGxpbWl0ICsgMTtcbiAgICB2YXIgc2VlbiAgICAgICAgID0gW107XG5cbiAgICByZXR1cm4gaXNTaW1wbGUoMCwgdmFsdWUsIGxpbWl0KTtcblxuICAgIC8vIFJlY3Vyc2l2ZSB3b3JrZXIgZnVuY3Rpb25cbiAgICBmdW5jdGlvbiBpc1NpbXBsZShjb3VudCwgdmFsdWUsIGxpbWl0KSB7XG5cbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cbiAgICAgICAgLy8gRmlyc3QgY2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXNcbiAgICAgICAgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGlmIChzZWVuLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBleGNlZWRzTGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWVuLnB1c2godmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIpIHtcblxuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IHNlbGYubGltaXRTdHJpbmdMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhjZWVkc0xpbWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvdW50ICsgMTtcblxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwibnVtYmVyXCIpIHtcblxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBleGNlZWRzTGltaXQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhjZWVkc0xpbWl0O1xuICAgICAgICAgICAgfSBlbHNlIGlmICghKHZhbHVlID09PSB2YWx1ZSkpIHsgIC8vIDwtLSBOYU4gcmV0dXJucyBmYWxzZSBmb3IgYW55IGNvbXBhcmlzb25cbiAgICAgICAgICAgICAgICByZXR1cm4gZXhjZWVkc0xpbWl0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY291bnQgKyAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBleGNlZWRzTGltaXQ7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSBcIm9iamVjdFwiKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBjb3VudCArIDE7XG5cbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xuXG4gICAgICAgICAgICBpZiAoY291bnQgKyB2YWx1ZS5sZW5ndGggPiBsaW1pdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBleGNlZWRzTGltaXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBrZXlDb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBrZXlDb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleUNvdW50ICE9PSB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhjZWVkc0xpbWl0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY291bnQgKz0gaXNTaW1wbGUoY291bnQsIHZhbHVlW2ldLCBsaW1pdCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID4gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4Y2VlZHNMaW1pdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY291bnQ7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgdmFyIHByb3BzID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvdW50ICsgcHJvcHMgPiBsaW1pdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBleGNlZWRzTGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ID0gaXNTaW1wbGUoY291bnQsIHZhbHVlW2tleV0sIGxpbWl0KTtcbiAgICAgICAgICAgICAgICBpZiAoY291bnQgKyBwcm9wcyA+IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleGNlZWRzTGltaXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBXZSBtYWtlIHNvbWUgdW52ZXJpZmllZCBhc3N1bXB0aW9ucyBoZXJlLCBuYW1lbHkuLi5cbi8vXG4vLyAoMSkgbWFueSB1c2VyIHBheWxvYWRzIHdpbGwgYmUgc21hbGwsIHNpbXBsZSwgYW5kIGRpcmVjdGx5XG4vLyBKU09OLnN0cmluZ2lmeS1hYmxlLlxuLy9cbi8vICgyKSBKU09OLnN0cmluZ2lmeSgpIGlzIGltcGxlbWVudGVkIG5hdGl2ZWx5IGJ5IHRoZSBKUyBwbGF0Zm9ybSBhbmQgd2lsbFxuLy8gdGh1cyBiZSBlZmZpY2llbnQgaW4gdGVybXMgb2YgcmF3IHBlcmZvcm1hbmNlIGFuZCwgcGVyaGFwcyBtb3JlXG4vLyBpbXBvcnRhbnRseSwgbWluaW1hbCBHQyBoZWFwIHRocmFzaGluZyB3aXRoIHRlbXBvcmFyaWVzLlxuLy9cbi8vICgzKSBFZmZpY2llbmN5IGlzIG1vcmUgaW1wb3J0YW50IHRoYW4gZXhhY3Qgc2l6ZSBjb25zdHJhaW50cyBpbiB0aGVcbi8vIHZhbHVlIGNvbnZlcnNpb24uXG4vL1xuLy8gVGh1cyB3ZSBhc3N1bWUgaXQncyBvdmVyYWxseSBxdWlja2VyIHRvIGFsd2F5cyB0cnkgc3RyaW5naWZ5aW5nIHRoZVxuLy8gb2JqZWN0IC0tIGFuZCBmYWxsYmFjayB0byBvdXIgbW9yZSBpbnZvbHZlZCwgcHJvY2Vzc2luZywgR0Ncbi8vIHRocmFzaGluZyBoZWF2eSBzaW1wbGZpY2lhdGlvbiBhbGdvcml0aG0gaWYgYW5kIG9ubHkgaWYgdGhhdCBuYXRpdmVcbi8vIHN0cmluZ2lmaWNhdGlvbiBmYWlsZWQuXG5Qcm9jZXNzb3IucHJvdG90eXBlLnByb2Nlc3NGYXN0UGF0aCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIG9iamVjdCBpcyBjbGVhcmx5IHRvbyBsYXJnZSBiZWZvcmUgYXR0ZW1wdGluZyB0aGUgbmF0aXZlXG4gICAgLy8gc3RyaW5naWZpY2F0aW9uLlxuICAgIGlmICh0aGlzLmlzU2ltcGxlKHZhbHVlKSA+IHRoaXMubGltaXRWYWx1ZUNvdW50KSB7XG4gICAgICAgIHJldHVybiB7IG9rIDogZmFsc2UgfTtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICAgIC8vIFVzZSBhIEpTT04gcm91bmQtdHJpcCB0byBpbXBsaWNpdGx5IGNsb25lIHRoZSBvYmplY3RcbiAgICAgICAgdmFyIGpzb24gPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB7IG9rIDogdHJ1ZSwgcmVzdWx0IDogSlNPTi5wYXJzZShqc29uKSB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHsgb2sgOiBmYWxzZSB9O1xuICAgIH1cbn07XG5cblByb2Nlc3Nvci5wcm90b3R5cGUucHJvY2Vzc1Nsb3dQYXRoID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5wb3N0UHJvY2Vzc1ZhbHVlKHRoaXMucHJvY2Vzc1ZhbHVlKHZhbHVlKSk7XG59O1xuXG5Qcm9jZXNzb3IucHJvdG90eXBlLnRydW5jYXRlU3RyaW5nID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgbGltaXQgPSB0aGlzLmxpbWl0U3RyaW5nTGVuZ3RoO1xuICAgIGlmICh2YWx1ZS5sZW5ndGggPiBsaW1pdCkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIGxpbWl0IC0gMSkgKyBcIuKAplwiO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG4vLyBEbyBhIGJyZWFkdGgtZmlyc3QgZXhwYW5zaW9uIG9mIHRoZSBwcm9jZXNzZWQgdmFsdWVzLiAgVGhlIGluY29taW5nIHZhbHVlXG4vLyBpcyBhbHdheXMgZ29pbmcgdG8gYmUgZWl0aGVyIGEgcHJpbWl0aXZlIG9yIGEgZnVuY3Rpb24gdG8gZXhwYW5kIGFuXG4vLyBvYmplY3QgaW50byBpdCdzIHByaW1pdGl2ZXMgKGFuZCBwb3NzaWJseSBpdHMgY29ycmVzcG9uZGluZyBuZXN0ZWQgZXhwYW5zaW9uXG4vLyBmdW5jdGlvbnMpLlxuUHJvY2Vzc29yLnByb3RvdHlwZS5wb3N0UHJvY2Vzc1ZhbHVlID0gZnVuY3Rpb24odmFsdWUpIHtcblxuICAgIC8vIFRPRE86IG1ha2UgdGhpcyBjb25maWd1cmFibGVcbiAgICB2YXIgdmFsdWVMaW1pdCA9IHRoaXMubGltaXRWYWx1ZUNvdW50O1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciByb290ID0ge1xuICAgICAgICB2YWx1ZSA6IHZhbHVlLFxuICAgIH07XG4gICAgdmFyIGluZGljZXMgPSBbIFwidmFsdWVcIiBdO1xuICAgIHZhciBwYXJlbnRzID0gWyByb290IF07XG5cbiAgICAvLyBUaGUgdmFsdWUgY291bnQgaXMgaW5jcmVtZW50IG9uIGFkZGl0aW9uIHRvIHRoZSBxdWV1ZVxuICAgIHRoaXMudmFsdWVDb3VudCsrO1xuXG4gICAgd2hpbGUgKHBhcmVudHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRzLnNoaWZ0KCk7XG4gICAgICAgIHZhciBpbmRleCAgPSBpbmRpY2VzLnNoaWZ0KCk7XG4gICAgICAgIHZhciB2YWx1ZSAgPSBwYXJlbnRbaW5kZXhdO1xuXG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBub24tcHJpbWl0aXZlIHZhbHVlIGV4cGFuZCBpdCBvdXRcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBwYXJlbnRbaW5kZXhdID0gdmFsdWUgPSB2YWx1ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gTmVlZCB0byByZXNldCB0aGUgYXJyYXkgaGVyZSBzaW5jZSB3ZSBzdGlsbCBoYXZlIHRoZSByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICAvLyB0byB0aGUgcGFyZW50IG9iamVjdCBoZXJlLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlQ291bnQgKyB2YWx1ZS5sZW5ndGggPj0gdmFsdWVMaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRbaW5kZXhdID0gdmFsdWUgPSBbXCI8dHJ1bmNhdGVkPlwiXTtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50cy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKDApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVucXVldWUoaSwgdmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBvYmplY3QgY2FzZSBpcyBlYXNpZXIgYXMgd2UgY2FuIGRlbGV0ZSB0aGUgb3Zlci1saW1pdFxuICAgICAgICAgICAgICAgIC8vIGZpZWxkcyBpbiB0aGUgZW5xdWV1ZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbnF1ZXVlKGtleSwgdmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVucXVldWUgKGtleSwgdmFsdWUsIGlzT2JqZWN0KSB7XG4gICAgICAgIGlmIChzZWxmLnZhbHVlQ291bnQgPCB2YWx1ZUxpbWl0KSB7XG4gICAgICAgICAgICBwYXJlbnRzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGtleSk7XG4gICAgICAgICAgICBzZWxmLnZhbHVlQ291bnQrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc09iamVjdCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGYudmFsdWVDb3VudCA9PT0gdmFsdWVMaW1pdCkge1xuICAgICAgICAgICAgcGFyZW50cy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGluZGljZXMucHVzaChcIuKAplwiKTtcbiAgICAgICAgICAgIHZhbHVlW1wi4oCmXCJdID0gXCI8dHJ1bmNhdGVkPlwiO1xuICAgICAgICAgICAgc2VsZi52YWx1ZUNvdW50Kys7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcm9vdC52YWx1ZTtcbn07XG5cblxuLy8gUmVkdWNlcyBhIGdpdmVuIEpTIHZhbHVlIHN1Y2ggdGhhdC4uLlxuLy9cbi8vIElmIHRoZSB2YWx1ZSBpcyBhIHByaW1pdGl2ZSwgYSB2YWx1ZSB0byB1c2UgZm9yIHRoZSBKU09OIHBheWxvYWQgaXNcbi8vIHJldHVybi5cbi8vXG4vLyBFbHNlLCByZXR1cm4gYSBmdW5jdGlvbiB0byBleHBhbmQgdGhlIG9iamVjdCBvbmUtbGV2ZWwgaW50byBhIHNldCBvZlxuLy8gcGF5bG9hZHMgcHJpbWl0aXZlcyBhbmQgZnV0aGVyIGV4cGFuc2lvbiBmdW5jdGlvbnMgKGZvciB1c2UgaW4gYVxuLy8gYnJlYWR0aC1maXJzdCBleHBhbnNpb24pLlxuLy9cbi8vIFRPRE86IE5vZGUuanMgYnVmZmVycyBmb3IgdGhlIG5vZGUgc2lkZSBvZiB0aGluZ3Ncbi8vXG5Qcm9jZXNzb3IucHJvdG90eXBlLnByb2Nlc3NWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuXG4gICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICByZXR1cm4gdmFsdWU7XG5cbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICByZXR1cm4gdmFsdWU7XG5cbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIHJldHVybiB0aGlzLnRydW5jYXRlU3RyaW5nKHZhbHVlKTtcblxuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgaWYgKHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiPGluZmluaXR5PlwiO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBcIjwtaW5maW5pdHk+XCI7XG4gICAgICAgIH0gZWxzZSBpZiAoISh2YWx1ZSA9PT0gdmFsdWUpKSB7ICAvLyA8LS0gTmFOIHJldHVybnMgZmFsc2UgZm9yIGFueSBjb21wYXJpc29uXG4gICAgICAgICAgICByZXR1cm4gXCI8TmFOPlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICBjYXNlIFwib2JqZWN0XCI6XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblxuICAgICAgICB9IGVsc2UgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuXG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMudHJ1bmNhdGVTdHJpbmcodmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICByZXR1cm4gXCI8cmVnZXhwOiBcIiArIHZhbHVlICsgXCI+XCI7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNlZW4uaW5kZXhPZih2YWx1ZSkgIT09IC0xKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBcIjxjaXJjdWxhcj5cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoaXMgaXMgbm90IGEgcHJpbWl0aXZlIG9iamVjdCAtLSByZWNvcmQgdGhhdCB3ZSd2ZVxuICAgICAgICAvLyBzZWVuIGl0IHRvIGF2b2lkIGNpcmN1bGFyIHJlZmVyZW5jZXMuXG4gICAgICAgIHRoaXMuc2Vlbi5wdXNoKHZhbHVlKTtcblxuICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcblxuICAgICAgICAgICAgLy8gVE9ETzogbWFrZSB0aGlzIGxpbWl0IGFuIG9wdGlvblxuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IHRoaXMubGltaXRBcnJheUxlbmd0aCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiBzbGljZSgpIGNsYW1wcyBvdXQgb2YgcmFuZ2UgaW5kZXhpbmcsIHNvIHRoZXJlJ3Mgbm8gbmVlZCB0byB3b3JyeSBhYm91dFxuICAgICAgICAgICAgICAgICAgICAvLyBhcnJheVBlZWtMZW5ndGggYW5kIGxpbWl0QXJyYXlMZW5ndGggYmVpbmcgc2V0IGlycmF0aW9uYWxseS5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiJHR5cGVcIiA6IFwiPHRydW5jYXRlZF9hcnJheT5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCAgOiB2YWx1ZS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkICAgIDogc2VsZi5wcm9jZXNzVmFsdWUodmFsdWUuc2xpY2UoMCwgc2VsZi5hcnJheVBlZWtMZW5ndGgpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhaWwgICAgOiBzZWxmLnByb2Nlc3NWYWx1ZSh2YWx1ZS5zbGljZSh2YWx1ZS5sZW5ndGggLSBzZWxmLmFycmF5UGVla0xlbmd0aCkpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgdGhlIHVudXN1YWwgY2FzZSBvZiBhcnJheXMgdGhhdCBhbHNvIGhhdmUgZmllbGRzXG4gICAgICAgICAgICAgICAgICAgIC8vIChlLmcuIGpRdWVyeSBvYmplY3RzKS4gIE5vcm1hbGl6ZSB0aGVzZSB0byBhbiBhc3NvY2lhdGl2ZVxuICAgICAgICAgICAgICAgICAgICAvLyBhcnJheSB3aXRoIHN0cmluZyBrZXlzIG9ubHkuXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IHRoZXJlIGRvZXNuJ3Qgc2VlbSB0byBiZSBhIGNsZWFuLCBjcm9zcy1KUy12YXJpYXRpb25zIHdheSB0byBkZXRlY3RcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlc2UgY29tcGxleCBvYmplY3RzIGRlZmluaXRpdmVseS4gIEhlcmUgdGhlIGFzc3VtcHRpb24gbWFkZSBpcyBpZiB0aGUgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIC8vIGhhcyBhIFwibGVuZ3RoXCIgcHJvcGVydHkgYW5kIHRoZSBudW1iZXIgb2Yga2V5cyBpcyBlcXVhbCB0byB0aGF0IGxlbmd0aCBBTkRcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgaGFzIGFscmVhZHkgcGFzc2VkIHRoZSBpc0FycmF5KCkgdGVzdCwgdGhlbiBpdCdzIG1vc3QgbGlrZWx5IGEgbm9ybWFsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFycmF5LiAgSW4gdGhlIHVubGlrZWx5IGNhc2UgdGhhdCB0aGUgb2JqZWN0IGhhcyBhIGxlbmd0aCBwcm9wZXJ0aWVzIHRoYXQnc1xuICAgICAgICAgICAgICAgICAgICAvLyBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGtleXMgQlVUIGFsc28gaGFzIG5vbi1udW1lcmljIGtleXMsIHRob3NlIG5vbi1udW1lcmljXG4gICAgICAgICAgICAgICAgICAgIC8vIGtleXMgd29uJ3QgZW5kIHVwIGluIHRoZSBKU09OOiBzbyBiZSBpdC5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleUNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5Q291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5Q291bnQgPT0gdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IG5ldyBBcnJheSh2YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFbaV0gPSBzZWxmLnByb2Nlc3NWYWx1ZSh2YWx1ZVtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNsb25lS2V5VmFsdWVzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNsb25lS2V5VmFsdWVzKHZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICByZXR1cm4gXCI8ZnVuY3Rpb24+XCI7XG5cbiAgICAvLyBFQ01BU2NyaXB0IDZcbiAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgIHJldHVybiBcIjxzeW1ib2w+XCI7XG5cbiAgICB9XG59O1xuXG4vLyBEdXBsaWNhdGUgYWxsIHRoZSBrZXktdmFsdWUgcGFpcnMgaW4gYW4gb2JqZWN0LCByZXNwZWN0aW5nIHRoZSBjdXJyZW50XG4vLyBwcm9jZXNzb3Igb3B0aW9ucy5cblByb2Nlc3Nvci5wcm90b3R5cGUuY2xvbmVLZXlWYWx1ZXMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgb2JqID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIHZhciBlbGVtVHlwZSA9ICh0eXBlb2YgdmFsdWVba2V5XSk7XG4gICAgICAgIGlmICh0aGlzLm9wdHMuZXhjbHVkZV9mdW5jdGlvbnMgJiYgZWxlbVR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgb2JqW2tleV0gPSB0aGlzLnByb2Nlc3NWYWx1ZSh2YWx1ZVtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cblxuLy8gVXNlIGEgZ2xvYmFsIHNpbmdsZXRvbiB0byByZWR1Y2UgdGhlIEdDIGltcGFjdC5cbnZhciBnUHJvY2Vzc29yID0gbmV3IFByb2Nlc3NvcigpO1xuXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXG4vLyBFeHBvcnRzXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXG5cbi8vIEdpdmVuIGFuIGFyYml0YXJ5IEpTIHZhbHVlIHJldHVybiBhIG5ldyBKUyB2YWx1ZSB0aGF0IGNhbiBzdHJpbmdpZmllZCB3aXRoXG4vLyBKU09OLnN0cmluZ2lmeSgpLlxuLy9cbi8vIC0gQ2lyY3VsYXIgcmVmZXJlbmNlcyBhcmUgcmVtb3ZlZC5cbi8vIC0gVGhlIHJlc3VsdGluZyBvYmplY3QgZG9lcyBub3QgbmVlZCB0byBzdXBwb3J0IHJvdW5kLXRyaXBwaW5nXG4vLyAtIFRvdGFsIHNpemUgYW5kIG1heCBkZXB0aCBjYW4gYmUgbGltaXRlZFxuLy9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsdWUsIG9wdHMpIHtcbiAgICByZXR1cm4gZ1Byb2Nlc3Nvci5wcm9jZXNzKHZhbHVlLCBvcHRzKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3NyYy9zY3J1YmJlci5qc1wiKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS42LjNcbnZhciBkZWVwQ2xvbmUsIGRlZXBEZWxldGUsIGRlZXBFeHRlbmQsIGRlZXBGcm9tRmxhdCwgZGVlcEtleXMsIGRlZXBNYXBWYWx1ZXMsIGlzUGxhaW5PYmplY3QsIG1hcEtleXMsIG1hcFZhbHVlcywgXztcblxuXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlZXBLZXlzOiBkZWVwS2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChvYmopKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkZWVwS2V5cyBtdXN0IGJlIGNhbGxlZCBvbiBhbiBvYmplY3QsIG5vdCAnXCIgKyBvYmogKyBcIidcIik7XG4gICAgfVxuICAgIHJldHVybiBfLmZsYXR0ZW4oXy5tYXAob2JqLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICBpZiAoaXNQbGFpbk9iamVjdCh2KSAmJiAhXy5pc0VtcHR5KHYpKSB7XG4gICAgICAgIHJldHVybiBfLm1hcChkZWVwS2V5cyh2KSwgZnVuY3Rpb24oc3Via2V5KSB7XG4gICAgICAgICAgcmV0dXJuIFwiXCIgKyBrICsgXCIuXCIgKyBzdWJrZXk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtrXTtcbiAgICAgIH1cbiAgICB9KSk7XG4gIH0sXG4gIGRlZXBDbG9uZTogZGVlcENsb25lID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIHR5cGUsIF9pLCBfbGVuLCBfcmVmO1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gICAgX3JlZiA9IFtEYXRlLCBOdW1iZXIsIFN0cmluZywgQm9vbGVhbl07XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICB0eXBlID0gX3JlZltfaV07XG4gICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgdHlwZSkge1xuICAgICAgICByZXR1cm4gbmV3IHR5cGUob2JqZWN0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKF8ob2JqZWN0KS5pc0FycmF5KCkpIHtcbiAgICAgIHJldHVybiBfKG9iamVjdCkubWFwKGRlZXBDbG9uZSk7XG4gICAgfVxuICAgIGlmICghXyhvYmplY3QpLmlzT2JqZWN0KCkpIHtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICAgIGlmIChvYmplY3Qubm9kZVR5cGUgJiYgXyhvYmplY3QuY2xvbmVOb2RlKS5pc0Z1bmN0aW9uKCkpIHtcbiAgICAgIHJldHVybiBvYmplY3QuY2xvbmVOb2RlKHRydWUpO1xuICAgIH1cbiAgICBpZiAob2JqZWN0LmNvbnN0cnVjdG9yICE9PSB7fS5jb25zdHJ1Y3Rvcikge1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gICAgcmV0dXJuIG1hcFZhbHVlcyhvYmplY3QsIGRlZXBDbG9uZSk7XG4gIH0sXG4gIGRlZXBIYXM6IGZ1bmN0aW9uKG9iaiwga2V5cykge1xuICAgIHZhciBoZWxwZXI7XG4gICAgaGVscGVyID0gZnVuY3Rpb24ob2JqLCBrZXlzKSB7XG4gICAgICBpZiAoKGtleXMubGVuZ3RoID09PSAwKSB8fCAoIV8uaXNPYmplY3Qob2JqKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChrZXlzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gXy5maXJzdChrZXlzKSBpbiBvYmo7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaGVscGVyKG9ialtfLmZpcnN0KGtleXMpXSwgXy5yZXN0KGtleXMpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBoZWxwZXIob2JqLCBfLmlzQXJyYXkoa2V5cykgPyBrZXlzIDoga2V5cy5zcGxpdCgnLicpKTtcbiAgfSxcbiAgZGVlcE9taXQ6IGZ1bmN0aW9uKG9iaiwga2V5cykge1xuICAgIHZhciBkZWVwT21pdE9uZTtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3Qob2JqKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGVlcE9taXQgbXVzdCBiZSBjYWxsZWQgb24gYW4gb2JqZWN0LCBub3QgJ1wiICsgb2JqICsgXCInXCIpO1xuICAgIH1cbiAgICBkZWVwT21pdE9uZSA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgICB2YXIgaGVscGVyO1xuICAgICAgaGVscGVyID0gZnVuY3Rpb24ob2JqLCBrZXlfYXJyKSB7XG4gICAgICAgIHN3aXRjaCAoZmFsc2UpIHtcbiAgICAgICAgICBjYXNlICFfLmlzRW1wdHkoa2V5X2Fycik6XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgIGNhc2Uga2V5X2Fyci5sZW5ndGggIT09IDE6XG4gICAgICAgICAgICByZXR1cm4gXy5vbWl0KG9iaiwgXy5maXJzdChrZXlfYXJyKSk7XG4gICAgICAgICAgY2FzZSAhIWlzUGxhaW5PYmplY3Qob2JqW18uZmlyc3Qoa2V5X2FycildKTpcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBfLmV4dGVuZCh7fSwgb2JqLCBfLm9iamVjdChbXy5maXJzdChrZXlfYXJyKV0sIFtoZWxwZXIob2JqW18uZmlyc3Qoa2V5X2FycildLCBfLnJlc3Qoa2V5X2FycikpXSkpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGhlbHBlcihvYmosIGtleS5zcGxpdCgnLicpKTtcbiAgICB9O1xuICAgIHJldHVybiBfLnJlZHVjZShrZXlzLCBkZWVwT21pdE9uZSwgb2JqKTtcbiAgfSxcbiAgZGVlcFBpY2s6IChmdW5jdGlvbigpIHtcbiAgICB2YXIgZGVlcEdldDtcbiAgICBkZWVwR2V0ID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICAgIHZhciBoZWxwZXI7XG4gICAgICBoZWxwZXIgPSBmdW5jdGlvbihvYmosIGtleV9hcnIpIHtcbiAgICAgICAgaWYgKGtleV9hcnIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIG9iaiAhPSBudWxsID8gb2JqW18uZmlyc3Qoa2V5X2FycildIDogdm9pZCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBoZWxwZXIob2JqW18uZmlyc3Qoa2V5X2FycildLCBfLnJlc3Qoa2V5X2FycikpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGhlbHBlcihvYmosIGtleS5zcGxpdCgnLicpKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGtleXMpIHtcbiAgICAgIHZhciBmbGF0X25ld19vYmo7XG4gICAgICBpZiAoIWlzUGxhaW5PYmplY3Qob2JqKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkZWVwUGljayBtdXN0IGJlIGNhbGxlZCBvbiBhbiBvYmplY3QsIG5vdCAnXCIgKyBvYmogKyBcIidcIik7XG4gICAgICB9XG4gICAgICBmbGF0X25ld19vYmogPSBfLnJlZHVjZShrZXlzLCBmdW5jdGlvbihuZXdfb2JqLCBrZXkpIHtcbiAgICAgICAgdmFyIHZhbDtcbiAgICAgICAgdmFsID0gZGVlcEdldChvYmosIGtleSk7XG4gICAgICAgIGlmICh2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgIG5ld19vYmpba2V5XSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3X29iajtcbiAgICAgIH0sIHt9KTtcbiAgICAgIHJldHVybiBkZWVwRnJvbUZsYXQoZmxhdF9uZXdfb2JqKTtcbiAgICB9O1xuICB9KSgpLFxuICBkZWVwRGVsZXRlOiBkZWVwRGVsZXRlID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICBpZiAoKGtleSA9PSBudWxsKSB8fCAob2JqID09IG51bGwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghXyhrZXkpLmlzQXJyYXkoKSkge1xuICAgICAga2V5ID0ga2V5LnNwbGl0KCcuJyk7XG4gICAgfVxuICAgIGlmIChrZXkubGVuZ3RoID09PSAxKSB7XG4gICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBkZWVwRGVsZXRlKG9ialtrZXlbMF1dLCBrZXkuc2xpY2UoMSwga2V5Lmxlbmd0aCkpO1xuICB9LFxuICBkZWVwRXh0ZW5kOiBkZWVwRXh0ZW5kID0gZnVuY3Rpb24ob2JqLCBleHQsIG11dGF0ZSkge1xuICAgIHJldHVybiBfLnJlZHVjZShleHQsIGZ1bmN0aW9uKGFjYywgdmFsLCBrZXkpIHtcbiAgICAgIGFjY1trZXldID0gKGtleSBpbiBvYmopICYmIGlzUGxhaW5PYmplY3Qob2JqW2tleV0pICYmIGlzUGxhaW5PYmplY3QodmFsKSA/IGRlZXBFeHRlbmQob2JqW2tleV0sIHZhbCkgOiB2YWw7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIG11dGF0ZSA/IG9iaiA6IF8uY2xvbmUob2JqKSk7XG4gIH0sXG4gIGlzUGxhaW5PYmplY3Q6IGlzUGxhaW5PYmplY3QgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgIT0gbnVsbCA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdm9pZCAwKSA9PT0ge30uY29uc3RydWN0b3I7XG4gIH0sXG4gIGRlZXBUb0ZsYXQ6IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciByZWN1cnNlLCByZXM7XG4gICAgcmVzID0ge307XG4gICAgcmVjdXJzZSA9IGZ1bmN0aW9uKG9iaiwgY3VycmVudCkge1xuICAgICAgdmFyIGtleSwgbmV3S2V5LCB2YWx1ZSwgX3Jlc3VsdHM7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIHZhbHVlID0gb2JqW2tleV07XG4gICAgICAgIG5ld0tleSA9IChjdXJyZW50ID8gY3VycmVudCArIFwiLlwiICsga2V5IDoga2V5KTtcbiAgICAgICAgaWYgKHZhbHVlICYmIGlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaChyZWN1cnNlKHZhbHVlLCBuZXdLZXkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKHJlc1tuZXdLZXldID0gdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcbiAgICByZWN1cnNlKG9iaik7XG4gICAgcmV0dXJuIHJlcztcbiAgfSxcbiAgZGVlcEZyb21GbGF0OiBkZWVwRnJvbUZsYXQgPSBmdW5jdGlvbihvKSB7XG4gICAgdmFyIGssIGtleSwgb28sIHBhcnQsIHBhcnRzLCB0O1xuICAgIG9vID0ge307XG4gICAgdCA9IHZvaWQgMDtcbiAgICBwYXJ0cyA9IHZvaWQgMDtcbiAgICBwYXJ0ID0gdm9pZCAwO1xuICAgIGZvciAoayBpbiBvKSB7XG4gICAgICB0ID0gb287XG4gICAgICBwYXJ0cyA9IGsuc3BsaXQoXCIuXCIpO1xuICAgICAga2V5ID0gcGFydHMucG9wKCk7XG4gICAgICB3aGlsZSAocGFydHMubGVuZ3RoKSB7XG4gICAgICAgIHBhcnQgPSBwYXJ0cy5zaGlmdCgpO1xuICAgICAgICB0ID0gdFtwYXJ0XSA9IHRbcGFydF0gfHwge307XG4gICAgICB9XG4gICAgICB0W2tleV0gPSBvW2tdO1xuICAgIH1cbiAgICByZXR1cm4gb287XG4gIH0sXG4gIG1hcFZhbHVlczogbWFwVmFsdWVzID0gZnVuY3Rpb24ob2JqLCBmX3ZhbCkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChvYmopKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYXBWYWx1ZXMgbXVzdCBiZSBjYWxsZWQgb24gYW4gb2JqZWN0LCBub3QgJ1wiICsgb2JqICsgXCInXCIpO1xuICAgIH1cbiAgICByZXR1cm4gXy5vYmplY3QoXy5rZXlzKG9iaiksIF8ubWFwKG9iaiwgZl92YWwpKTtcbiAgfSxcbiAgZGVlcE1hcFZhbHVlczogZGVlcE1hcFZhbHVlcyA9IGZ1bmN0aW9uKG9iaiwgZikge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChvYmopKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkZWVwTWFwVmFsdWVzIG11c3QgYmUgY2FsbGVkIG9uIGFuIG9iamVjdCwgbm90ICdcIiArIG9iaiArIFwiJ1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcFZhbHVlcyhvYmosIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgIGlmIChpc1BsYWluT2JqZWN0KHYpKSB7XG4gICAgICAgIHJldHVybiBkZWVwTWFwVmFsdWVzKHYsIGZ1bmN0aW9uKHN1YnYsIHN1YmspIHtcbiAgICAgICAgICByZXR1cm4gZihzdWJ2LCBcIlwiICsgayArIFwiLlwiICsgc3Viayk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGYodiwgayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIG1hcEtleXM6IG1hcEtleXMgPSBmdW5jdGlvbihvYmosIGZfdmFsKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KG9iaikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm1hcEtleXMgbXVzdCBiZSBjYWxsZWQgb24gYW4gb2JqZWN0LCBub3QgJ1wiICsgb2JqICsgXCInXCIpO1xuICAgIH1cbiAgICByZXR1cm4gXy5vYmplY3QoXy5tYXAob2JqLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICByZXR1cm4gZl92YWwoaywgdik7XG4gICAgfSksIF8udmFsdWVzKG9iaikpO1xuICB9XG59O1xuIiwiLy8gICAgIFVuZGVyc2NvcmUuanMgMS44LjNcbi8vICAgICBodHRwOi8vdW5kZXJzY29yZWpzLm9yZ1xuLy8gICAgIChjKSAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbi8vICAgICBVbmRlcnNjb3JlIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLy8gQmFzZWxpbmUgc2V0dXBcbiAgLy8gLS0tLS0tLS0tLS0tLS1cblxuICAvLyBFc3RhYmxpc2ggdGhlIHJvb3Qgb2JqZWN0LCBgd2luZG93YCBpbiB0aGUgYnJvd3Nlciwgb3IgYGV4cG9ydHNgIG9uIHRoZSBzZXJ2ZXIuXG4gIHZhciByb290ID0gdGhpcztcblxuICAvLyBTYXZlIHRoZSBwcmV2aW91cyB2YWx1ZSBvZiB0aGUgYF9gIHZhcmlhYmxlLlxuICB2YXIgcHJldmlvdXNVbmRlcnNjb3JlID0gcm9vdC5fO1xuXG4gIC8vIFNhdmUgYnl0ZXMgaW4gdGhlIG1pbmlmaWVkIChidXQgbm90IGd6aXBwZWQpIHZlcnNpb246XG4gIHZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLCBPYmpQcm90byA9IE9iamVjdC5wcm90b3R5cGUsIEZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuICAvLyBDcmVhdGUgcXVpY2sgcmVmZXJlbmNlIHZhcmlhYmxlcyBmb3Igc3BlZWQgYWNjZXNzIHRvIGNvcmUgcHJvdG90eXBlcy5cbiAgdmFyXG4gICAgcHVzaCAgICAgICAgICAgICA9IEFycmF5UHJvdG8ucHVzaCxcbiAgICBzbGljZSAgICAgICAgICAgID0gQXJyYXlQcm90by5zbGljZSxcbiAgICB0b1N0cmluZyAgICAgICAgID0gT2JqUHJvdG8udG9TdHJpbmcsXG4gICAgaGFzT3duUHJvcGVydHkgICA9IE9ialByb3RvLmhhc093blByb3BlcnR5O1xuXG4gIC8vIEFsbCAqKkVDTUFTY3JpcHQgNSoqIG5hdGl2ZSBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbnMgdGhhdCB3ZSBob3BlIHRvIHVzZVxuICAvLyBhcmUgZGVjbGFyZWQgaGVyZS5cbiAgdmFyXG4gICAgbmF0aXZlSXNBcnJheSAgICAgID0gQXJyYXkuaXNBcnJheSxcbiAgICBuYXRpdmVLZXlzICAgICAgICAgPSBPYmplY3Qua2V5cyxcbiAgICBuYXRpdmVCaW5kICAgICAgICAgPSBGdW5jUHJvdG8uYmluZCxcbiAgICBuYXRpdmVDcmVhdGUgICAgICAgPSBPYmplY3QuY3JlYXRlO1xuXG4gIC8vIE5ha2VkIGZ1bmN0aW9uIHJlZmVyZW5jZSBmb3Igc3Vycm9nYXRlLXByb3RvdHlwZS1zd2FwcGluZy5cbiAgdmFyIEN0b3IgPSBmdW5jdGlvbigpe307XG5cbiAgLy8gQ3JlYXRlIGEgc2FmZSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciB1c2UgYmVsb3cuXG4gIHZhciBfID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIF8pIHJldHVybiBvYmo7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIF8pKSByZXR1cm4gbmV3IF8ob2JqKTtcbiAgICB0aGlzLl93cmFwcGVkID0gb2JqO1xuICB9O1xuXG4gIC8vIEV4cG9ydCB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yICoqTm9kZS5qcyoqLCB3aXRoXG4gIC8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZvciB0aGUgb2xkIGByZXF1aXJlKClgIEFQSS4gSWYgd2UncmUgaW5cbiAgLy8gdGhlIGJyb3dzZXIsIGFkZCBgX2AgYXMgYSBnbG9iYWwgb2JqZWN0LlxuICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfO1xuICAgIH1cbiAgICBleHBvcnRzLl8gPSBfO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuXyA9IF87XG4gIH1cblxuICAvLyBDdXJyZW50IHZlcnNpb24uXG4gIF8uVkVSU0lPTiA9ICcxLjguMyc7XG5cbiAgLy8gSW50ZXJuYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGVmZmljaWVudCAoZm9yIGN1cnJlbnQgZW5naW5lcykgdmVyc2lvblxuICAvLyBvZiB0aGUgcGFzc2VkLWluIGNhbGxiYWNrLCB0byBiZSByZXBlYXRlZGx5IGFwcGxpZWQgaW4gb3RoZXIgVW5kZXJzY29yZVxuICAvLyBmdW5jdGlvbnMuXG4gIHZhciBvcHRpbWl6ZUNiID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCwgYXJnQ291bnQpIHtcbiAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSByZXR1cm4gZnVuYztcbiAgICBzd2l0Y2ggKGFyZ0NvdW50ID09IG51bGwgPyAzIDogYXJnQ291bnQpIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUpO1xuICAgICAgfTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBvdGhlcik7XG4gICAgICB9O1xuICAgICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQSBtb3N0bHktaW50ZXJuYWwgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgY2FsbGJhY2tzIHRoYXQgY2FuIGJlIGFwcGxpZWRcbiAgLy8gdG8gZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiwgcmV0dXJuaW5nIHRoZSBkZXNpcmVkIHJlc3VsdCDigJQgZWl0aGVyXG4gIC8vIGlkZW50aXR5LCBhbiBhcmJpdHJhcnkgY2FsbGJhY2ssIGEgcHJvcGVydHkgbWF0Y2hlciwgb3IgYSBwcm9wZXJ0eSBhY2Nlc3Nvci5cbiAgdmFyIGNiID0gZnVuY3Rpb24odmFsdWUsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBfLmlkZW50aXR5O1xuICAgIGlmIChfLmlzRnVuY3Rpb24odmFsdWUpKSByZXR1cm4gb3B0aW1pemVDYih2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpO1xuICAgIGlmIChfLmlzT2JqZWN0KHZhbHVlKSkgcmV0dXJuIF8ubWF0Y2hlcih2YWx1ZSk7XG4gICAgcmV0dXJuIF8ucHJvcGVydHkodmFsdWUpO1xuICB9O1xuICBfLml0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gY2IodmFsdWUsIGNvbnRleHQsIEluZmluaXR5KTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYXNzaWduZXIgZnVuY3Rpb25zLlxuICB2YXIgY3JlYXRlQXNzaWduZXIgPSBmdW5jdGlvbihrZXlzRnVuYywgdW5kZWZpbmVkT25seSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCA8IDIgfHwgb2JqID09IG51bGwpIHJldHVybiBvYmo7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdLFxuICAgICAgICAgICAga2V5cyA9IGtleXNGdW5jKHNvdXJjZSksXG4gICAgICAgICAgICBsID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKCF1bmRlZmluZWRPbmx5IHx8IG9ialtrZXldID09PSB2b2lkIDApIG9ialtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSBhbm90aGVyLlxuICB2YXIgYmFzZUNyZWF0ZSA9IGZ1bmN0aW9uKHByb3RvdHlwZSkge1xuICAgIGlmICghXy5pc09iamVjdChwcm90b3R5cGUpKSByZXR1cm4ge307XG4gICAgaWYgKG5hdGl2ZUNyZWF0ZSkgcmV0dXJuIG5hdGl2ZUNyZWF0ZShwcm90b3R5cGUpO1xuICAgIEN0b3IucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgIHZhciByZXN1bHQgPSBuZXcgQ3RvcjtcbiAgICBDdG9yLnByb3RvdHlwZSA9IG51bGw7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgcHJvcGVydHkgPSBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09IG51bGwgPyB2b2lkIDAgOiBvYmpba2V5XTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEhlbHBlciBmb3IgY29sbGVjdGlvbiBtZXRob2RzIHRvIGRldGVybWluZSB3aGV0aGVyIGEgY29sbGVjdGlvblxuICAvLyBzaG91bGQgYmUgaXRlcmF0ZWQgYXMgYW4gYXJyYXkgb3IgYXMgYW4gb2JqZWN0XG4gIC8vIFJlbGF0ZWQ6IGh0dHA6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvbGVuZ3RoXG4gIC8vIEF2b2lkcyBhIHZlcnkgbmFzdHkgaU9TIDggSklUIGJ1ZyBvbiBBUk0tNjQuICMyMDk0XG4gIHZhciBNQVhfQVJSQVlfSU5ERVggPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuICB2YXIgZ2V0TGVuZ3RoID0gcHJvcGVydHkoJ2xlbmd0aCcpO1xuICB2YXIgaXNBcnJheUxpa2UgPSBmdW5jdGlvbihjb2xsZWN0aW9uKSB7XG4gICAgdmFyIGxlbmd0aCA9IGdldExlbmd0aChjb2xsZWN0aW9uKTtcbiAgICByZXR1cm4gdHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyAmJiBsZW5ndGggPj0gMCAmJiBsZW5ndGggPD0gTUFYX0FSUkFZX0lOREVYO1xuICB9O1xuXG4gIC8vIENvbGxlY3Rpb24gRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gVGhlIGNvcm5lcnN0b25lLCBhbiBgZWFjaGAgaW1wbGVtZW50YXRpb24sIGFrYSBgZm9yRWFjaGAuXG4gIC8vIEhhbmRsZXMgcmF3IG9iamVjdHMgaW4gYWRkaXRpb24gdG8gYXJyYXktbGlrZXMuIFRyZWF0cyBhbGxcbiAgLy8gc3BhcnNlIGFycmF5LWxpa2VzIGFzIGlmIHRoZXkgd2VyZSBkZW5zZS5cbiAgXy5lYWNoID0gXy5mb3JFYWNoID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGksIGxlbmd0aDtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtpXSwgaSwgb2JqKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlcmF0ZWUob2JqW2tleXNbaV1dLCBrZXlzW2ldLCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0ZWUgdG8gZWFjaCBlbGVtZW50LlxuICBfLm1hcCA9IF8uY29sbGVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0cyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIHJlc3VsdHNbaW5kZXhdID0gaXRlcmF0ZWUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDcmVhdGUgYSByZWR1Y2luZyBmdW5jdGlvbiBpdGVyYXRpbmcgbGVmdCBvciByaWdodC5cbiAgZnVuY3Rpb24gY3JlYXRlUmVkdWNlKGRpcikge1xuICAgIC8vIE9wdGltaXplZCBpdGVyYXRvciBmdW5jdGlvbiBhcyB1c2luZyBhcmd1bWVudHMubGVuZ3RoXG4gICAgLy8gaW4gdGhlIG1haW4gZnVuY3Rpb24gd2lsbCBkZW9wdGltaXplIHRoZSwgc2VlICMxOTkxLlxuICAgIGZ1bmN0aW9uIGl0ZXJhdG9yKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGtleXMsIGluZGV4LCBsZW5ndGgpIHtcbiAgICAgIGZvciAoOyBpbmRleCA+PSAwICYmIGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSBkaXIpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgICAgbWVtbyA9IGl0ZXJhdGVlKG1lbW8sIG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBtZW1vLCBjb250ZXh0KSB7XG4gICAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQsIDQpO1xuICAgICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aCxcbiAgICAgICAgICBpbmRleCA9IGRpciA+IDAgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgIC8vIERldGVybWluZSB0aGUgaW5pdGlhbCB2YWx1ZSBpZiBub25lIGlzIHByb3ZpZGVkLlxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgICAgIG1lbW8gPSBvYmpba2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXhdO1xuICAgICAgICBpbmRleCArPSBkaXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0b3Iob2JqLCBpdGVyYXRlZSwgbWVtbywga2V5cywgaW5kZXgsIGxlbmd0aCk7XG4gICAgfTtcbiAgfVxuXG4gIC8vICoqUmVkdWNlKiogYnVpbGRzIHVwIGEgc2luZ2xlIHJlc3VsdCBmcm9tIGEgbGlzdCBvZiB2YWx1ZXMsIGFrYSBgaW5qZWN0YCxcbiAgLy8gb3IgYGZvbGRsYC5cbiAgXy5yZWR1Y2UgPSBfLmZvbGRsID0gXy5pbmplY3QgPSBjcmVhdGVSZWR1Y2UoMSk7XG5cbiAgLy8gVGhlIHJpZ2h0LWFzc29jaWF0aXZlIHZlcnNpb24gb2YgcmVkdWNlLCBhbHNvIGtub3duIGFzIGBmb2xkcmAuXG4gIF8ucmVkdWNlUmlnaHQgPSBfLmZvbGRyID0gY3JlYXRlUmVkdWNlKC0xKTtcblxuICAvLyBSZXR1cm4gdGhlIGZpcnN0IHZhbHVlIHdoaWNoIHBhc3NlcyBhIHRydXRoIHRlc3QuIEFsaWFzZWQgYXMgYGRldGVjdGAuXG4gIF8uZmluZCA9IF8uZGV0ZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIga2V5O1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopKSB7XG4gICAgICBrZXkgPSBfLmZpbmRJbmRleChvYmosIHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IF8uZmluZEtleShvYmosIHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgfVxuICAgIGlmIChrZXkgIT09IHZvaWQgMCAmJiBrZXkgIT09IC0xKSByZXR1cm4gb2JqW2tleV07XG4gIH07XG5cbiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBwYXNzIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgc2VsZWN0YC5cbiAgXy5maWx0ZXIgPSBfLnNlbGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGxpc3QpKSByZXN1bHRzLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGZvciB3aGljaCBhIHRydXRoIHRlc3QgZmFpbHMuXG4gIF8ucmVqZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm5lZ2F0ZShjYihwcmVkaWNhdGUpKSwgY29udGV4dCk7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgYWxsIG9mIHRoZSBlbGVtZW50cyBtYXRjaCBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYGFsbGAuXG4gIF8uZXZlcnkgPSBfLmFsbCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgaWYgKCFwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiBhdCBsZWFzdCBvbmUgZWxlbWVudCBpbiB0aGUgb2JqZWN0IG1hdGNoZXMgYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbnlgLlxuICBfLnNvbWUgPSBfLmFueSA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgaWYgKHByZWRpY2F0ZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaikpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBhcnJheSBvciBvYmplY3QgY29udGFpbnMgYSBnaXZlbiBpdGVtICh1c2luZyBgPT09YCkuXG4gIC8vIEFsaWFzZWQgYXMgYGluY2x1ZGVzYCBhbmQgYGluY2x1ZGVgLlxuICBfLmNvbnRhaW5zID0gXy5pbmNsdWRlcyA9IF8uaW5jbHVkZSA9IGZ1bmN0aW9uKG9iaiwgaXRlbSwgZnJvbUluZGV4LCBndWFyZCkge1xuICAgIGlmICghaXNBcnJheUxpa2Uob2JqKSkgb2JqID0gXy52YWx1ZXMob2JqKTtcbiAgICBpZiAodHlwZW9mIGZyb21JbmRleCAhPSAnbnVtYmVyJyB8fCBndWFyZCkgZnJvbUluZGV4ID0gMDtcbiAgICByZXR1cm4gXy5pbmRleE9mKG9iaiwgaXRlbSwgZnJvbUluZGV4KSA+PSAwO1xuICB9O1xuXG4gIC8vIEludm9rZSBhIG1ldGhvZCAod2l0aCBhcmd1bWVudHMpIG9uIGV2ZXJ5IGl0ZW0gaW4gYSBjb2xsZWN0aW9uLlxuICBfLmludm9rZSA9IGZ1bmN0aW9uKG9iaiwgbWV0aG9kKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGlzRnVuYyA9IF8uaXNGdW5jdGlvbihtZXRob2QpO1xuICAgIHJldHVybiBfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzRnVuYyA/IG1ldGhvZCA6IHZhbHVlW21ldGhvZF07XG4gICAgICByZXR1cm4gZnVuYyA9PSBudWxsID8gZnVuYyA6IGZ1bmMuYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYG1hcGA6IGZldGNoaW5nIGEgcHJvcGVydHkuXG4gIF8ucGx1Y2sgPSBmdW5jdGlvbihvYmosIGtleSkge1xuICAgIHJldHVybiBfLm1hcChvYmosIF8ucHJvcGVydHkoa2V5KSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgZmlsdGVyYDogc2VsZWN0aW5nIG9ubHkgb2JqZWN0c1xuICAvLyBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLndoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbHRlcihvYmosIF8ubWF0Y2hlcihhdHRycykpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbmRgOiBnZXR0aW5nIHRoZSBmaXJzdCBvYmplY3RcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5maW5kV2hlcmUgPSBmdW5jdGlvbihvYmosIGF0dHJzKSB7XG4gICAgcmV0dXJuIF8uZmluZChvYmosIF8ubWF0Y2hlcihhdHRycykpO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbWF4aW11bSBlbGVtZW50IChvciBlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbiAgXy5tYXggPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IC1JbmZpbml0eSwgbGFzdENvbXB1dGVkID0gLUluZmluaXR5LFxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgJiYgb2JqICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgaWYgKHZhbHVlID4gcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPiBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IC1JbmZpbml0eSAmJiByZXN1bHQgPT09IC1JbmZpbml0eSkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1pbmltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWluID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSBJbmZpbml0eSwgbGFzdENvbXB1dGVkID0gSW5maW5pdHksXG4gICAgICAgIHZhbHVlLCBjb21wdXRlZDtcbiAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCAmJiBvYmogIT0gbnVsbCkge1xuICAgICAgb2JqID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gb2JqW2ldO1xuICAgICAgICBpZiAodmFsdWUgPCByZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgbGlzdCk7XG4gICAgICAgIGlmIChjb21wdXRlZCA8IGxhc3RDb21wdXRlZCB8fCBjb21wdXRlZCA9PT0gSW5maW5pdHkgJiYgcmVzdWx0ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBTaHVmZmxlIGEgY29sbGVjdGlvbiwgdXNpbmcgdGhlIG1vZGVybiB2ZXJzaW9uIG9mIHRoZVxuICAvLyBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVy4oCTWWF0ZXNfc2h1ZmZsZSkuXG4gIF8uc2h1ZmZsZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBzZXQgPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0gc2V0Lmxlbmd0aDtcbiAgICB2YXIgc2h1ZmZsZWQgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMCwgcmFuZDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHJhbmQgPSBfLnJhbmRvbSgwLCBpbmRleCk7XG4gICAgICBpZiAocmFuZCAhPT0gaW5kZXgpIHNodWZmbGVkW2luZGV4XSA9IHNodWZmbGVkW3JhbmRdO1xuICAgICAgc2h1ZmZsZWRbcmFuZF0gPSBzZXRbaW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gc2h1ZmZsZWQ7XG4gIH07XG5cbiAgLy8gU2FtcGxlICoqbioqIHJhbmRvbSB2YWx1ZXMgZnJvbSBhIGNvbGxlY3Rpb24uXG4gIC8vIElmICoqbioqIGlzIG5vdCBzcGVjaWZpZWQsIHJldHVybnMgYSBzaW5nbGUgcmFuZG9tIGVsZW1lbnQuXG4gIC8vIFRoZSBpbnRlcm5hbCBgZ3VhcmRgIGFyZ3VtZW50IGFsbG93cyBpdCB0byB3b3JrIHdpdGggYG1hcGAuXG4gIF8uc2FtcGxlID0gZnVuY3Rpb24ob2JqLCBuLCBndWFyZCkge1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHtcbiAgICAgIGlmICghaXNBcnJheUxpa2Uob2JqKSkgb2JqID0gXy52YWx1ZXMob2JqKTtcbiAgICAgIHJldHVybiBvYmpbXy5yYW5kb20ob2JqLmxlbmd0aCAtIDEpXTtcbiAgICB9XG4gICAgcmV0dXJuIF8uc2h1ZmZsZShvYmopLnNsaWNlKDAsIE1hdGgubWF4KDAsIG4pKTtcbiAgfTtcblxuICAvLyBTb3J0IHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24gcHJvZHVjZWQgYnkgYW4gaXRlcmF0ZWUuXG4gIF8uc29ydEJ5ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHJldHVybiBfLnBsdWNrKF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgY3JpdGVyaWE6IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgbGlzdClcbiAgICAgIH07XG4gICAgfSkuc29ydChmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgdmFyIGEgPSBsZWZ0LmNyaXRlcmlhO1xuICAgICAgdmFyIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICAgIGlmIChhICE9PSBiKSB7XG4gICAgICAgIGlmIChhID4gYiB8fCBhID09PSB2b2lkIDApIHJldHVybiAxO1xuICAgICAgICBpZiAoYSA8IGIgfHwgYiA9PT0gdm9pZCAwKSByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVmdC5pbmRleCAtIHJpZ2h0LmluZGV4O1xuICAgIH0pLCAndmFsdWUnKTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiB1c2VkIGZvciBhZ2dyZWdhdGUgXCJncm91cCBieVwiIG9wZXJhdGlvbnMuXG4gIHZhciBncm91cCA9IGZ1bmN0aW9uKGJlaGF2aW9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHZhciBrZXkgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIG9iaik7XG4gICAgICAgIGJlaGF2aW9yKHJlc3VsdCwgdmFsdWUsIGtleSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBHcm91cHMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbi4gUGFzcyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlXG4gIC8vIHRvIGdyb3VwIGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY3JpdGVyaW9uLlxuICBfLmdyb3VwQnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICBpZiAoXy5oYXMocmVzdWx0LCBrZXkpKSByZXN1bHRba2V5XS5wdXNoKHZhbHVlKTsgZWxzZSByZXN1bHRba2V5XSA9IFt2YWx1ZV07XG4gIH0pO1xuXG4gIC8vIEluZGV4ZXMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbiwgc2ltaWxhciB0byBgZ3JvdXBCeWAsIGJ1dCBmb3JcbiAgLy8gd2hlbiB5b3Uga25vdyB0aGF0IHlvdXIgaW5kZXggdmFsdWVzIHdpbGwgYmUgdW5pcXVlLlxuICBfLmluZGV4QnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICB9KTtcblxuICAvLyBDb3VudHMgaW5zdGFuY2VzIG9mIGFuIG9iamVjdCB0aGF0IGdyb3VwIGJ5IGEgY2VydGFpbiBjcml0ZXJpb24uIFBhc3NcbiAgLy8gZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZSB0byBjb3VudCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gIC8vIGNyaXRlcmlvbi5cbiAgXy5jb3VudEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKF8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0rKzsgZWxzZSByZXN1bHRba2V5XSA9IDE7XG4gIH0pO1xuXG4gIC8vIFNhZmVseSBjcmVhdGUgYSByZWFsLCBsaXZlIGFycmF5IGZyb20gYW55dGhpbmcgaXRlcmFibGUuXG4gIF8udG9BcnJheSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghb2JqKSByZXR1cm4gW107XG4gICAgaWYgKF8uaXNBcnJheShvYmopKSByZXR1cm4gc2xpY2UuY2FsbChvYmopO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopKSByZXR1cm4gXy5tYXAob2JqLCBfLmlkZW50aXR5KTtcbiAgICByZXR1cm4gXy52YWx1ZXMob2JqKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiBhbiBvYmplY3QuXG4gIF8uc2l6ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIDA7XG4gICAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iaikgPyBvYmoubGVuZ3RoIDogXy5rZXlzKG9iaikubGVuZ3RoO1xuICB9O1xuXG4gIC8vIFNwbGl0IGEgY29sbGVjdGlvbiBpbnRvIHR3byBhcnJheXM6IG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgc2F0aXNmeSB0aGUgZ2l2ZW5cbiAgLy8gcHJlZGljYXRlLCBhbmQgb25lIHdob3NlIGVsZW1lbnRzIGFsbCBkbyBub3Qgc2F0aXNmeSB0aGUgcHJlZGljYXRlLlxuICBfLnBhcnRpdGlvbiA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIgcGFzcyA9IFtdLCBmYWlsID0gW107XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqKSB7XG4gICAgICAocHJlZGljYXRlKHZhbHVlLCBrZXksIG9iaikgPyBwYXNzIDogZmFpbCkucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtwYXNzLCBmYWlsXTtcbiAgfTtcblxuICAvLyBBcnJheSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gR2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYGhlYWRgIGFuZCBgdGFrZWAuIFRoZSAqKmd1YXJkKiogY2hlY2tcbiAgLy8gYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLlxuICBfLmZpcnN0ID0gXy5oZWFkID0gXy50YWtlID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkgcmV0dXJuIGFycmF5WzBdO1xuICAgIHJldHVybiBfLmluaXRpYWwoYXJyYXksIGFycmF5Lmxlbmd0aCAtIG4pO1xuICB9O1xuXG4gIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGxhc3QgZW50cnkgb2YgdGhlIGFycmF5LiBFc3BlY2lhbGx5IHVzZWZ1bCBvblxuICAvLyB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiBhbGwgdGhlIHZhbHVlcyBpblxuICAvLyB0aGUgYXJyYXksIGV4Y2x1ZGluZyB0aGUgbGFzdCBOLlxuICBfLmluaXRpYWwgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgMCwgTWF0aC5tYXgoMCwgYXJyYXkubGVuZ3RoIC0gKG4gPT0gbnVsbCB8fCBndWFyZCA/IDEgOiBuKSkpO1xuICB9O1xuXG4gIC8vIEdldCB0aGUgbGFzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBsYXN0IE5cbiAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS5cbiAgXy5sYXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBfLnJlc3QoYXJyYXksIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIG4pKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBmaXJzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYHRhaWxgIGFuZCBgZHJvcGAuXG4gIC8vIEVzcGVjaWFsbHkgdXNlZnVsIG9uIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nIGFuICoqbioqIHdpbGwgcmV0dXJuXG4gIC8vIHRoZSByZXN0IE4gdmFsdWVzIGluIHRoZSBhcnJheS5cbiAgXy5yZXN0ID0gXy50YWlsID0gXy5kcm9wID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIG4gPT0gbnVsbCB8fCBndWFyZCA/IDEgOiBuKTtcbiAgfTtcblxuICAvLyBUcmltIG91dCBhbGwgZmFsc3kgdmFsdWVzIGZyb20gYW4gYXJyYXkuXG4gIF8uY29tcGFjdCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBfLmlkZW50aXR5KTtcbiAgfTtcblxuICAvLyBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiBhIHJlY3Vyc2l2ZSBgZmxhdHRlbmAgZnVuY3Rpb24uXG4gIHZhciBmbGF0dGVuID0gZnVuY3Rpb24oaW5wdXQsIHNoYWxsb3csIHN0cmljdCwgc3RhcnRJbmRleCkge1xuICAgIHZhciBvdXRwdXQgPSBbXSwgaWR4ID0gMDtcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleCB8fCAwLCBsZW5ndGggPSBnZXRMZW5ndGgoaW5wdXQpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IGlucHV0W2ldO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJiAoXy5pc0FycmF5KHZhbHVlKSB8fCBfLmlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICAgICAgLy9mbGF0dGVuIGN1cnJlbnQgbGV2ZWwgb2YgYXJyYXkgb3IgYXJndW1lbnRzIG9iamVjdFxuICAgICAgICBpZiAoIXNoYWxsb3cpIHZhbHVlID0gZmxhdHRlbih2YWx1ZSwgc2hhbGxvdywgc3RyaWN0KTtcbiAgICAgICAgdmFyIGogPSAwLCBsZW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIG91dHB1dC5sZW5ndGggKz0gbGVuO1xuICAgICAgICB3aGlsZSAoaiA8IGxlbikge1xuICAgICAgICAgIG91dHB1dFtpZHgrK10gPSB2YWx1ZVtqKytdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFzdHJpY3QpIHtcbiAgICAgICAgb3V0cHV0W2lkeCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xuXG4gIC8vIEZsYXR0ZW4gb3V0IGFuIGFycmF5LCBlaXRoZXIgcmVjdXJzaXZlbHkgKGJ5IGRlZmF1bHQpLCBvciBqdXN0IG9uZSBsZXZlbC5cbiAgXy5mbGF0dGVuID0gZnVuY3Rpb24oYXJyYXksIHNoYWxsb3cpIHtcbiAgICByZXR1cm4gZmxhdHRlbihhcnJheSwgc2hhbGxvdywgZmFsc2UpO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHZlcnNpb24gb2YgdGhlIGFycmF5IHRoYXQgZG9lcyBub3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIHZhbHVlKHMpLlxuICBfLndpdGhvdXQgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmRpZmZlcmVuY2UoYXJyYXksIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgdGhlIGFycmF5LiBJZiB0aGUgYXJyYXkgaGFzIGFscmVhZHlcbiAgLy8gYmVlbiBzb3J0ZWQsIHlvdSBoYXZlIHRoZSBvcHRpb24gb2YgdXNpbmcgYSBmYXN0ZXIgYWxnb3JpdGhtLlxuICAvLyBBbGlhc2VkIGFzIGB1bmlxdWVgLlxuICBfLnVuaXEgPSBfLnVuaXF1ZSA9IGZ1bmN0aW9uKGFycmF5LCBpc1NvcnRlZCwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpZiAoIV8uaXNCb29sZWFuKGlzU29ydGVkKSkge1xuICAgICAgY29udGV4dCA9IGl0ZXJhdGVlO1xuICAgICAgaXRlcmF0ZWUgPSBpc1NvcnRlZDtcbiAgICAgIGlzU29ydGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpdGVyYXRlZSAhPSBudWxsKSBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIHNlZW4gPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpXSxcbiAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUsIGksIGFycmF5KSA6IHZhbHVlO1xuICAgICAgaWYgKGlzU29ydGVkKSB7XG4gICAgICAgIGlmICghaSB8fCBzZWVuICE9PSBjb21wdXRlZCkgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICBzZWVuID0gY29tcHV0ZWQ7XG4gICAgICB9IGVsc2UgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIGlmICghXy5jb250YWlucyhzZWVuLCBjb21wdXRlZCkpIHtcbiAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghXy5jb250YWlucyhyZXN1bHQsIHZhbHVlKSkge1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSB1bmlvbjogZWFjaCBkaXN0aW5jdCBlbGVtZW50IGZyb20gYWxsIG9mXG4gIC8vIHRoZSBwYXNzZWQtaW4gYXJyYXlzLlxuICBfLnVuaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8udW5pcShmbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSkpO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyBldmVyeSBpdGVtIHNoYXJlZCBiZXR3ZWVuIGFsbCB0aGVcbiAgLy8gcGFzc2VkLWluIGFycmF5cy5cbiAgXy5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBhcnJheVtpXTtcbiAgICAgIGlmIChfLmNvbnRhaW5zKHJlc3VsdCwgaXRlbSkpIGNvbnRpbnVlO1xuICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBhcmdzTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKCFfLmNvbnRhaW5zKGFyZ3VtZW50c1tqXSwgaXRlbSkpIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGogPT09IGFyZ3NMZW5ndGgpIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFRha2UgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBvbmUgYXJyYXkgYW5kIGEgbnVtYmVyIG9mIG90aGVyIGFycmF5cy5cbiAgLy8gT25seSB0aGUgZWxlbWVudHMgcHJlc2VudCBpbiBqdXN0IHRoZSBmaXJzdCBhcnJheSB3aWxsIHJlbWFpbi5cbiAgXy5kaWZmZXJlbmNlID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdCA9IGZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlLCB0cnVlLCAxKTtcbiAgICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgIHJldHVybiAhXy5jb250YWlucyhyZXN0LCB2YWx1ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gWmlwIHRvZ2V0aGVyIG11bHRpcGxlIGxpc3RzIGludG8gYSBzaW5nbGUgYXJyYXkgLS0gZWxlbWVudHMgdGhhdCBzaGFyZVxuICAvLyBhbiBpbmRleCBnbyB0b2dldGhlci5cbiAgXy56aXAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXy51bnppcChhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIENvbXBsZW1lbnQgb2YgXy56aXAuIFVuemlwIGFjY2VwdHMgYW4gYXJyYXkgb2YgYXJyYXlzIGFuZCBncm91cHNcbiAgLy8gZWFjaCBhcnJheSdzIGVsZW1lbnRzIG9uIHNoYXJlZCBpbmRpY2VzXG4gIF8udW56aXAgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSAmJiBfLm1heChhcnJheSwgZ2V0TGVuZ3RoKS5sZW5ndGggfHwgMDtcbiAgICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBfLnBsdWNrKGFycmF5LCBpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gQ29udmVydHMgbGlzdHMgaW50byBvYmplY3RzLiBQYXNzIGVpdGhlciBhIHNpbmdsZSBhcnJheSBvZiBgW2tleSwgdmFsdWVdYFxuICAvLyBwYWlycywgb3IgdHdvIHBhcmFsbGVsIGFycmF5cyBvZiB0aGUgc2FtZSBsZW5ndGggLS0gb25lIG9mIGtleXMsIGFuZCBvbmUgb2ZcbiAgLy8gdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICBfLm9iamVjdCA9IGZ1bmN0aW9uKGxpc3QsIHZhbHVlcykge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGxpc3QpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgcmVzdWx0W2xpc3RbaV1dID0gdmFsdWVzW2ldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2xpc3RbaV1bMF1dID0gbGlzdFtpXVsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBHZW5lcmF0b3IgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBmaW5kSW5kZXggYW5kIGZpbmRMYXN0SW5kZXggZnVuY3Rpb25zXG4gIGZ1bmN0aW9uIGNyZWF0ZVByZWRpY2F0ZUluZGV4RmluZGVyKGRpcikge1xuICAgIHJldHVybiBmdW5jdGlvbihhcnJheSwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgICAgdmFyIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7XG4gICAgICB2YXIgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGluZGV4IG9uIGFuIGFycmF5LWxpa2UgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdFxuICBfLmZpbmRJbmRleCA9IGNyZWF0ZVByZWRpY2F0ZUluZGV4RmluZGVyKDEpO1xuICBfLmZpbmRMYXN0SW5kZXggPSBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcigtMSk7XG5cbiAgLy8gVXNlIGEgY29tcGFyYXRvciBmdW5jdGlvbiB0byBmaWd1cmUgb3V0IHRoZSBzbWFsbGVzdCBpbmRleCBhdCB3aGljaFxuICAvLyBhbiBvYmplY3Qgc2hvdWxkIGJlIGluc2VydGVkIHNvIGFzIHRvIG1haW50YWluIG9yZGVyLiBVc2VzIGJpbmFyeSBzZWFyY2guXG4gIF8uc29ydGVkSW5kZXggPSBmdW5jdGlvbihhcnJheSwgb2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQsIDEpO1xuICAgIHZhciB2YWx1ZSA9IGl0ZXJhdGVlKG9iaik7XG4gICAgdmFyIGxvdyA9IDAsIGhpZ2ggPSBnZXRMZW5ndGgoYXJyYXkpO1xuICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICB2YXIgbWlkID0gTWF0aC5mbG9vcigobG93ICsgaGlnaCkgLyAyKTtcbiAgICAgIGlmIChpdGVyYXRlZShhcnJheVttaWRdKSA8IHZhbHVlKSBsb3cgPSBtaWQgKyAxOyBlbHNlIGhpZ2ggPSBtaWQ7XG4gICAgfVxuICAgIHJldHVybiBsb3c7XG4gIH07XG5cbiAgLy8gR2VuZXJhdG9yIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgaW5kZXhPZiBhbmQgbGFzdEluZGV4T2YgZnVuY3Rpb25zXG4gIGZ1bmN0aW9uIGNyZWF0ZUluZGV4RmluZGVyKGRpciwgcHJlZGljYXRlRmluZCwgc29ydGVkSW5kZXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGlkeCkge1xuICAgICAgdmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpO1xuICAgICAgaWYgKHR5cGVvZiBpZHggPT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGRpciA+IDApIHtcbiAgICAgICAgICAgIGkgPSBpZHggPj0gMCA/IGlkeCA6IE1hdGgubWF4KGlkeCArIGxlbmd0aCwgaSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZW5ndGggPSBpZHggPj0gMCA/IE1hdGgubWluKGlkeCArIDEsIGxlbmd0aCkgOiBpZHggKyBsZW5ndGggKyAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNvcnRlZEluZGV4ICYmIGlkeCAmJiBsZW5ndGgpIHtcbiAgICAgICAgaWR4ID0gc29ydGVkSW5kZXgoYXJyYXksIGl0ZW0pO1xuICAgICAgICByZXR1cm4gYXJyYXlbaWR4XSA9PT0gaXRlbSA/IGlkeCA6IC0xO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW0gIT09IGl0ZW0pIHtcbiAgICAgICAgaWR4ID0gcHJlZGljYXRlRmluZChzbGljZS5jYWxsKGFycmF5LCBpLCBsZW5ndGgpLCBfLmlzTmFOKTtcbiAgICAgICAgcmV0dXJuIGlkeCA+PSAwID8gaWR4ICsgaSA6IC0xO1xuICAgICAgfVxuICAgICAgZm9yIChpZHggPSBkaXIgPiAwID8gaSA6IGxlbmd0aCAtIDE7IGlkeCA+PSAwICYmIGlkeCA8IGxlbmd0aDsgaWR4ICs9IGRpcikge1xuICAgICAgICBpZiAoYXJyYXlbaWR4XSA9PT0gaXRlbSkgcmV0dXJuIGlkeDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICB9XG5cbiAgLy8gUmV0dXJuIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhbiBpdGVtIGluIGFuIGFycmF5LFxuICAvLyBvciAtMSBpZiB0aGUgaXRlbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIGFycmF5LlxuICAvLyBJZiB0aGUgYXJyYXkgaXMgbGFyZ2UgYW5kIGFscmVhZHkgaW4gc29ydCBvcmRlciwgcGFzcyBgdHJ1ZWBcbiAgLy8gZm9yICoqaXNTb3J0ZWQqKiB0byB1c2UgYmluYXJ5IHNlYXJjaC5cbiAgXy5pbmRleE9mID0gY3JlYXRlSW5kZXhGaW5kZXIoMSwgXy5maW5kSW5kZXgsIF8uc29ydGVkSW5kZXgpO1xuICBfLmxhc3RJbmRleE9mID0gY3JlYXRlSW5kZXhGaW5kZXIoLTEsIF8uZmluZExhc3RJbmRleCk7XG5cbiAgLy8gR2VuZXJhdGUgYW4gaW50ZWdlciBBcnJheSBjb250YWluaW5nIGFuIGFyaXRobWV0aWMgcHJvZ3Jlc3Npb24uIEEgcG9ydCBvZlxuICAvLyB0aGUgbmF0aXZlIFB5dGhvbiBgcmFuZ2UoKWAgZnVuY3Rpb24uIFNlZVxuICAvLyBbdGhlIFB5dGhvbiBkb2N1bWVudGF0aW9uXShodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvZnVuY3Rpb25zLmh0bWwjcmFuZ2UpLlxuICBfLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICBpZiAoc3RvcCA9PSBudWxsKSB7XG4gICAgICBzdG9wID0gc3RhcnQgfHwgMDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgc3RlcCA9IHN0ZXAgfHwgMTtcblxuICAgIHZhciBsZW5ndGggPSBNYXRoLm1heChNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSwgMCk7XG4gICAgdmFyIHJhbmdlID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyssIHN0YXJ0ICs9IHN0ZXApIHtcbiAgICAgIHJhbmdlW2lkeF0gPSBzdGFydDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG5cbiAgLy8gRnVuY3Rpb24gKGFoZW0pIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gZXhlY3V0ZSBhIGZ1bmN0aW9uIGFzIGEgY29uc3RydWN0b3JcbiAgLy8gb3IgYSBub3JtYWwgZnVuY3Rpb24gd2l0aCB0aGUgcHJvdmlkZWQgYXJndW1lbnRzXG4gIHZhciBleGVjdXRlQm91bmQgPSBmdW5jdGlvbihzb3VyY2VGdW5jLCBib3VuZEZ1bmMsIGNvbnRleHQsIGNhbGxpbmdDb250ZXh0LCBhcmdzKSB7XG4gICAgaWYgKCEoY2FsbGluZ0NvbnRleHQgaW5zdGFuY2VvZiBib3VuZEZ1bmMpKSByZXR1cm4gc291cmNlRnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB2YXIgc2VsZiA9IGJhc2VDcmVhdGUoc291cmNlRnVuYy5wcm90b3R5cGUpO1xuICAgIHZhciByZXN1bHQgPSBzb3VyY2VGdW5jLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIGlmIChfLmlzT2JqZWN0KHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgZnVuY3Rpb24gYm91bmQgdG8gYSBnaXZlbiBvYmplY3QgKGFzc2lnbmluZyBgdGhpc2AsIGFuZCBhcmd1bWVudHMsXG4gIC8vIG9wdGlvbmFsbHkpLiBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgRnVuY3Rpb24uYmluZGAgaWZcbiAgLy8gYXZhaWxhYmxlLlxuICBfLmJpbmQgPSBmdW5jdGlvbihmdW5jLCBjb250ZXh0KSB7XG4gICAgaWYgKG5hdGl2ZUJpbmQgJiYgZnVuYy5iaW5kID09PSBuYXRpdmVCaW5kKSByZXR1cm4gbmF0aXZlQmluZC5hcHBseShmdW5jLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIGlmICghXy5pc0Z1bmN0aW9uKGZ1bmMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdCaW5kIG11c3QgYmUgY2FsbGVkIG9uIGEgZnVuY3Rpb24nKTtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICB2YXIgYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIGNvbnRleHQsIHRoaXMsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9O1xuXG4gIC8vIFBhcnRpYWxseSBhcHBseSBhIGZ1bmN0aW9uIGJ5IGNyZWF0aW5nIGEgdmVyc2lvbiB0aGF0IGhhcyBoYWQgc29tZSBvZiBpdHNcbiAgLy8gYXJndW1lbnRzIHByZS1maWxsZWQsIHdpdGhvdXQgY2hhbmdpbmcgaXRzIGR5bmFtaWMgYHRoaXNgIGNvbnRleHQuIF8gYWN0c1xuICAvLyBhcyBhIHBsYWNlaG9sZGVyLCBhbGxvd2luZyBhbnkgY29tYmluYXRpb24gb2YgYXJndW1lbnRzIHRvIGJlIHByZS1maWxsZWQuXG4gIF8ucGFydGlhbCA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICB2YXIgYm91bmRBcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHZhciBib3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvc2l0aW9uID0gMCwgbGVuZ3RoID0gYm91bmRBcmdzLmxlbmd0aDtcbiAgICAgIHZhciBhcmdzID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJnc1tpXSA9IGJvdW5kQXJnc1tpXSA9PT0gXyA/IGFyZ3VtZW50c1twb3NpdGlvbisrXSA6IGJvdW5kQXJnc1tpXTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChwb3NpdGlvbiA8IGFyZ3VtZW50cy5sZW5ndGgpIGFyZ3MucHVzaChhcmd1bWVudHNbcG9zaXRpb24rK10pO1xuICAgICAgcmV0dXJuIGV4ZWN1dGVCb3VuZChmdW5jLCBib3VuZCwgdGhpcywgdGhpcywgYXJncyk7XG4gICAgfTtcbiAgICByZXR1cm4gYm91bmQ7XG4gIH07XG5cbiAgLy8gQmluZCBhIG51bWJlciBvZiBhbiBvYmplY3QncyBtZXRob2RzIHRvIHRoYXQgb2JqZWN0LiBSZW1haW5pbmcgYXJndW1lbnRzXG4gIC8vIGFyZSB0aGUgbWV0aG9kIG5hbWVzIHRvIGJlIGJvdW5kLiBVc2VmdWwgZm9yIGVuc3VyaW5nIHRoYXQgYWxsIGNhbGxiYWNrc1xuICAvLyBkZWZpbmVkIG9uIGFuIG9iamVjdCBiZWxvbmcgdG8gaXQuXG4gIF8uYmluZEFsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBpLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLCBrZXk7XG4gICAgaWYgKGxlbmd0aCA8PSAxKSB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBbGwgbXVzdCBiZSBwYXNzZWQgZnVuY3Rpb24gbmFtZXMnKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIG9ialtrZXldID0gXy5iaW5kKG9ialtrZXldLCBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIE1lbW9pemUgYW4gZXhwZW5zaXZlIGZ1bmN0aW9uIGJ5IHN0b3JpbmcgaXRzIHJlc3VsdHMuXG4gIF8ubWVtb2l6ZSA9IGZ1bmN0aW9uKGZ1bmMsIGhhc2hlcikge1xuICAgIHZhciBtZW1vaXplID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICB2YXIgY2FjaGUgPSBtZW1vaXplLmNhY2hlO1xuICAgICAgdmFyIGFkZHJlc3MgPSAnJyArIChoYXNoZXIgPyBoYXNoZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGtleSk7XG4gICAgICBpZiAoIV8uaGFzKGNhY2hlLCBhZGRyZXNzKSkgY2FjaGVbYWRkcmVzc10gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gY2FjaGVbYWRkcmVzc107XG4gICAgfTtcbiAgICBtZW1vaXplLmNhY2hlID0ge307XG4gICAgcmV0dXJuIG1lbW9pemU7XG4gIH07XG5cbiAgLy8gRGVsYXlzIGEgZnVuY3Rpb24gZm9yIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCBhbmQgdGhlbiBjYWxsc1xuICAvLyBpdCB3aXRoIHRoZSBhcmd1bWVudHMgc3VwcGxpZWQuXG4gIF8uZGVsYXkgPSBmdW5jdGlvbihmdW5jLCB3YWl0KSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0sIHdhaXQpO1xuICB9O1xuXG4gIC8vIERlZmVycyBhIGZ1bmN0aW9uLCBzY2hlZHVsaW5nIGl0IHRvIHJ1biBhZnRlciB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhc1xuICAvLyBjbGVhcmVkLlxuICBfLmRlZmVyID0gXy5wYXJ0aWFsKF8uZGVsYXksIF8sIDEpO1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIG9ubHkgYmUgdHJpZ2dlcmVkIGF0IG1vc3Qgb25jZVxuICAvLyBkdXJpbmcgYSBnaXZlbiB3aW5kb3cgb2YgdGltZS4gTm9ybWFsbHksIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gd2lsbCBydW5cbiAgLy8gYXMgbXVjaCBhcyBpdCBjYW4sIHdpdGhvdXQgZXZlciBnb2luZyBtb3JlIHRoYW4gb25jZSBwZXIgYHdhaXRgIGR1cmF0aW9uO1xuICAvLyBidXQgaWYgeW91J2QgbGlrZSB0byBkaXNhYmxlIHRoZSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmcgZWRnZSwgcGFzc1xuICAvLyBge2xlYWRpbmc6IGZhbHNlfWAuIFRvIGRpc2FibGUgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlLCBkaXR0by5cbiAgXy50aHJvdHRsZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgY29udGV4dCwgYXJncywgcmVzdWx0O1xuICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXMgPSAwO1xuICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IF8ubm93KCk7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBub3cgPSBfLm5vdygpO1xuICAgICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSBwcmV2aW91cyA9IG5vdztcbiAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdFxuICAvLyBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXG4gIC8vIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuICAvLyBsZWFkaW5nIGVkZ2UsIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLlxuICBfLmRlYm91bmNlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xuXG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGFzdCA9IF8ubm93KCkgLSB0aW1lc3RhbXA7XG5cbiAgICAgIGlmIChsYXN0IDwgd2FpdCAmJiBsYXN0ID49IDApIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdGltZXN0YW1wID0gXy5ub3coKTtcbiAgICAgIHZhciBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xuICAgICAgaWYgKCF0aW1lb3V0KSB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgICBpZiAoY2FsbE5vdykge1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBmdW5jdGlvbiBwYXNzZWQgYXMgYW4gYXJndW1lbnQgdG8gdGhlIHNlY29uZCxcbiAgLy8gYWxsb3dpbmcgeW91IHRvIGFkanVzdCBhcmd1bWVudHMsIHJ1biBjb2RlIGJlZm9yZSBhbmQgYWZ0ZXIsIGFuZFxuICAvLyBjb25kaXRpb25hbGx5IGV4ZWN1dGUgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxuICBfLndyYXAgPSBmdW5jdGlvbihmdW5jLCB3cmFwcGVyKSB7XG4gICAgcmV0dXJuIF8ucGFydGlhbCh3cmFwcGVyLCBmdW5jKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgbmVnYXRlZCB2ZXJzaW9uIG9mIHRoZSBwYXNzZWQtaW4gcHJlZGljYXRlLlxuICBfLm5lZ2F0ZSA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgYSBsaXN0IG9mIGZ1bmN0aW9ucywgZWFjaFxuICAvLyBjb25zdW1pbmcgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gdGhhdCBmb2xsb3dzLlxuICBfLmNvbXBvc2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgc3RhcnQgPSBhcmdzLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGkgPSBzdGFydDtcbiAgICAgIHZhciByZXN1bHQgPSBhcmdzW3N0YXJ0XS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgd2hpbGUgKGktLSkgcmVzdWx0ID0gYXJnc1tpXS5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIG9uIGFuZCBhZnRlciB0aGUgTnRoIGNhbGwuXG4gIF8uYWZ0ZXIgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzIDwgMSkge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIHVwIHRvIChidXQgbm90IGluY2x1ZGluZykgdGhlIE50aCBjYWxsLlxuICBfLmJlZm9yZSA9IGZ1bmN0aW9uKHRpbWVzLCBmdW5jKSB7XG4gICAgdmFyIG1lbW87XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKC0tdGltZXMgPiAwKSB7XG4gICAgICAgIG1lbW8gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICBpZiAodGltZXMgPD0gMSkgZnVuYyA9IG51bGw7XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYXQgbW9zdCBvbmUgdGltZSwgbm8gbWF0dGVyIGhvd1xuICAvLyBvZnRlbiB5b3UgY2FsbCBpdC4gVXNlZnVsIGZvciBsYXp5IGluaXRpYWxpemF0aW9uLlxuICBfLm9uY2UgPSBfLnBhcnRpYWwoXy5iZWZvcmUsIDIpO1xuXG4gIC8vIE9iamVjdCBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEtleXMgaW4gSUUgPCA5IHRoYXQgd29uJ3QgYmUgaXRlcmF0ZWQgYnkgYGZvciBrZXkgaW4gLi4uYCBhbmQgdGh1cyBtaXNzZWQuXG4gIHZhciBoYXNFbnVtQnVnID0gIXt0b1N0cmluZzogbnVsbH0ucHJvcGVydHlJc0VudW1lcmFibGUoJ3RvU3RyaW5nJyk7XG4gIHZhciBub25FbnVtZXJhYmxlUHJvcHMgPSBbJ3ZhbHVlT2YnLCAnaXNQcm90b3R5cGVPZicsICd0b1N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJ2hhc093blByb3BlcnR5JywgJ3RvTG9jYWxlU3RyaW5nJ107XG5cbiAgZnVuY3Rpb24gY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpIHtcbiAgICB2YXIgbm9uRW51bUlkeCA9IG5vbkVudW1lcmFibGVQcm9wcy5sZW5ndGg7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gb2JqLmNvbnN0cnVjdG9yO1xuICAgIHZhciBwcm90byA9IChfLmlzRnVuY3Rpb24oY29uc3RydWN0b3IpICYmIGNvbnN0cnVjdG9yLnByb3RvdHlwZSkgfHwgT2JqUHJvdG87XG5cbiAgICAvLyBDb25zdHJ1Y3RvciBpcyBhIHNwZWNpYWwgY2FzZS5cbiAgICB2YXIgcHJvcCA9ICdjb25zdHJ1Y3Rvcic7XG4gICAgaWYgKF8uaGFzKG9iaiwgcHJvcCkgJiYgIV8uY29udGFpbnMoa2V5cywgcHJvcCkpIGtleXMucHVzaChwcm9wKTtcblxuICAgIHdoaWxlIChub25FbnVtSWR4LS0pIHtcbiAgICAgIHByb3AgPSBub25FbnVtZXJhYmxlUHJvcHNbbm9uRW51bUlkeF07XG4gICAgICBpZiAocHJvcCBpbiBvYmogJiYgb2JqW3Byb3BdICE9PSBwcm90b1twcm9wXSAmJiAhXy5jb250YWlucyhrZXlzLCBwcm9wKSkge1xuICAgICAgICBrZXlzLnB1c2gocHJvcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0cmlldmUgdGhlIG5hbWVzIG9mIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzLlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgT2JqZWN0LmtleXNgXG4gIF8ua2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgaWYgKG5hdGl2ZUtleXMpIHJldHVybiBuYXRpdmVLZXlzKG9iaik7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgICAvLyBBaGVtLCBJRSA8IDkuXG4gICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSBhbGwgdGhlIHByb3BlcnR5IG5hbWVzIG9mIGFuIG9iamVjdC5cbiAgXy5hbGxLZXlzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBbXTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICAgIC8vIEFoZW0sIElFIDwgOS5cbiAgICBpZiAoaGFzRW51bUJ1ZykgY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpO1xuICAgIHJldHVybiBrZXlzO1xuICB9O1xuXG4gIC8vIFJldHJpZXZlIHRoZSB2YWx1ZXMgb2YgYW4gb2JqZWN0J3MgcHJvcGVydGllcy5cbiAgXy52YWx1ZXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgdmFsdWVzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZXNbaV0gPSBvYmpba2V5c1tpXV07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0ZWUgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBvYmplY3RcbiAgLy8gSW4gY29udHJhc3QgdG8gXy5tYXAgaXQgcmV0dXJucyBhbiBvYmplY3RcbiAgXy5tYXBPYmplY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAgXy5rZXlzKG9iaiksXG4gICAgICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0cyA9IHt9LFxuICAgICAgICAgIGN1cnJlbnRLZXk7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGN1cnJlbnRLZXkgPSBrZXlzW2luZGV4XTtcbiAgICAgICAgcmVzdWx0c1tjdXJyZW50S2V5XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIENvbnZlcnQgYW4gb2JqZWN0IGludG8gYSBsaXN0IG9mIGBba2V5LCB2YWx1ZV1gIHBhaXJzLlxuICBfLnBhaXJzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHBhaXJzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBwYWlyc1tpXSA9IFtrZXlzW2ldLCBvYmpba2V5c1tpXV1dO1xuICAgIH1cbiAgICByZXR1cm4gcGFpcnM7XG4gIH07XG5cbiAgLy8gSW52ZXJ0IHRoZSBrZXlzIGFuZCB2YWx1ZXMgb2YgYW4gb2JqZWN0LiBUaGUgdmFsdWVzIG11c3QgYmUgc2VyaWFsaXphYmxlLlxuICBfLmludmVydCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRbb2JqW2tleXNbaV1dXSA9IGtleXNbaV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgc29ydGVkIGxpc3Qgb2YgdGhlIGZ1bmN0aW9uIG5hbWVzIGF2YWlsYWJsZSBvbiB0aGUgb2JqZWN0LlxuICAvLyBBbGlhc2VkIGFzIGBtZXRob2RzYFxuICBfLmZ1bmN0aW9ucyA9IF8ubWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24ob2JqW2tleV0pKSBuYW1lcy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lcy5zb3J0KCk7XG4gIH07XG5cbiAgLy8gRXh0ZW5kIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBwcm9wZXJ0aWVzIGluIHBhc3NlZC1pbiBvYmplY3QocykuXG4gIF8uZXh0ZW5kID0gY3JlYXRlQXNzaWduZXIoXy5hbGxLZXlzKTtcblxuICAvLyBBc3NpZ25zIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBvd24gcHJvcGVydGllcyBpbiB0aGUgcGFzc2VkLWluIG9iamVjdChzKVxuICAvLyAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnbilcbiAgXy5leHRlbmRPd24gPSBfLmFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKF8ua2V5cyk7XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3Qga2V5IG9uIGFuIG9iamVjdCB0aGF0IHBhc3NlcyBhIHByZWRpY2F0ZSB0ZXN0XG4gIF8uZmluZEtleSA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopLCBrZXk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAocHJlZGljYXRlKG9ialtrZXldLCBrZXksIG9iaikpIHJldHVybiBrZXk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCBvbmx5IGNvbnRhaW5pbmcgdGhlIHdoaXRlbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ucGljayA9IGZ1bmN0aW9uKG9iamVjdCwgb2l0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9LCBvYmogPSBvYmplY3QsIGl0ZXJhdGVlLCBrZXlzO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKG9pdGVyYXRlZSkpIHtcbiAgICAgIGtleXMgPSBfLmFsbEtleXMob2JqKTtcbiAgICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihvaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gZmxhdHRlbihhcmd1bWVudHMsIGZhbHNlLCBmYWxzZSwgMSk7XG4gICAgICBpdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikgeyByZXR1cm4ga2V5IGluIG9iajsgfTtcbiAgICAgIG9iaiA9IE9iamVjdChvYmopO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgIGlmIChpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmopKSByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgd2l0aG91dCB0aGUgYmxhY2tsaXN0ZWQgcHJvcGVydGllcy5cbiAgXy5vbWl0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGlmIChfLmlzRnVuY3Rpb24oaXRlcmF0ZWUpKSB7XG4gICAgICBpdGVyYXRlZSA9IF8ubmVnYXRlKGl0ZXJhdGVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBfLm1hcChmbGF0dGVuKGFyZ3VtZW50cywgZmFsc2UsIGZhbHNlLCAxKSwgU3RyaW5nKTtcbiAgICAgIGl0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICByZXR1cm4gIV8uY29udGFpbnMoa2V5cywga2V5KTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBfLnBpY2sob2JqLCBpdGVyYXRlZSwgY29udGV4dCk7XG4gIH07XG5cbiAgLy8gRmlsbCBpbiBhIGdpdmVuIG9iamVjdCB3aXRoIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgXy5kZWZhdWx0cyA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cywgdHJ1ZSk7XG5cbiAgLy8gQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoZSBnaXZlbiBwcm90b3R5cGUgb2JqZWN0LlxuICAvLyBJZiBhZGRpdGlvbmFsIHByb3BlcnRpZXMgYXJlIHByb3ZpZGVkIHRoZW4gdGhleSB3aWxsIGJlIGFkZGVkIHRvIHRoZVxuICAvLyBjcmVhdGVkIG9iamVjdC5cbiAgXy5jcmVhdGUgPSBmdW5jdGlvbihwcm90b3R5cGUsIHByb3BzKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VDcmVhdGUocHJvdG90eXBlKTtcbiAgICBpZiAocHJvcHMpIF8uZXh0ZW5kT3duKHJlc3VsdCwgcHJvcHMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgKHNoYWxsb3ctY2xvbmVkKSBkdXBsaWNhdGUgb2YgYW4gb2JqZWN0LlxuICBfLmNsb25lID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG4gICAgcmV0dXJuIF8uaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiBfLmV4dGVuZCh7fSwgb2JqKTtcbiAgfTtcblxuICAvLyBJbnZva2VzIGludGVyY2VwdG9yIHdpdGggdGhlIG9iaiwgYW5kIHRoZW4gcmV0dXJucyBvYmouXG4gIC8vIFRoZSBwcmltYXJ5IHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluLCBpblxuICAvLyBvcmRlciB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gaW50ZXJtZWRpYXRlIHJlc3VsdHMgd2l0aGluIHRoZSBjaGFpbi5cbiAgXy50YXAgPSBmdW5jdGlvbihvYmosIGludGVyY2VwdG9yKSB7XG4gICAgaW50ZXJjZXB0b3Iob2JqKTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybnMgd2hldGhlciBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gc2V0IG9mIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLmlzTWF0Y2ggPSBmdW5jdGlvbihvYmplY3QsIGF0dHJzKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMoYXR0cnMpLCBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHJldHVybiAhbGVuZ3RoO1xuICAgIHZhciBvYmogPSBPYmplY3Qob2JqZWN0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChhdHRyc1trZXldICE9PSBvYmpba2V5XSB8fCAhKGtleSBpbiBvYmopKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG5cbiAgLy8gSW50ZXJuYWwgcmVjdXJzaXZlIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIGBpc0VxdWFsYC5cbiAgdmFyIGVxID0gZnVuY3Rpb24oYSwgYiwgYVN0YWNrLCBiU3RhY2spIHtcbiAgICAvLyBJZGVudGljYWwgb2JqZWN0cyBhcmUgZXF1YWwuIGAwID09PSAtMGAsIGJ1dCB0aGV5IGFyZW4ndCBpZGVudGljYWwuXG4gICAgLy8gU2VlIHRoZSBbSGFybW9ueSBgZWdhbGAgcHJvcG9zYWxdKGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6ZWdhbCkuXG4gICAgaWYgKGEgPT09IGIpIHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09PSAxIC8gYjtcbiAgICAvLyBBIHN0cmljdCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGBudWxsID09IHVuZGVmaW5lZGAuXG4gICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBhID09PSBiO1xuICAgIC8vIFVud3JhcCBhbnkgd3JhcHBlZCBvYmplY3RzLlxuICAgIGlmIChhIGluc3RhbmNlb2YgXykgYSA9IGEuX3dyYXBwZWQ7XG4gICAgaWYgKGIgaW5zdGFuY2VvZiBfKSBiID0gYi5fd3JhcHBlZDtcbiAgICAvLyBDb21wYXJlIGBbW0NsYXNzXV1gIG5hbWVzLlxuICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpO1xuICAgIGlmIChjbGFzc05hbWUgIT09IHRvU3RyaW5nLmNhbGwoYikpIHJldHVybiBmYWxzZTtcbiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgLy8gU3RyaW5ncywgbnVtYmVycywgcmVndWxhciBleHByZXNzaW9ucywgZGF0ZXMsIGFuZCBib29sZWFucyBhcmUgY29tcGFyZWQgYnkgdmFsdWUuXG4gICAgICBjYXNlICdbb2JqZWN0IFJlZ0V4cF0nOlxuICAgICAgLy8gUmVnRXhwcyBhcmUgY29lcmNlZCB0byBzdHJpbmdzIGZvciBjb21wYXJpc29uIChOb3RlOiAnJyArIC9hL2kgPT09ICcvYS9pJylcbiAgICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XG4gICAgICAgIC8vIFByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHdyYXBwZXJzIGFyZSBlcXVpdmFsZW50OyB0aHVzLCBgXCI1XCJgIGlzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gYG5ldyBTdHJpbmcoXCI1XCIpYC5cbiAgICAgICAgcmV0dXJuICcnICsgYSA9PT0gJycgKyBiO1xuICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzpcbiAgICAgICAgLy8gYE5hTmBzIGFyZSBlcXVpdmFsZW50LCBidXQgbm9uLXJlZmxleGl2ZS5cbiAgICAgICAgLy8gT2JqZWN0KE5hTikgaXMgZXF1aXZhbGVudCB0byBOYU5cbiAgICAgICAgaWYgKCthICE9PSArYSkgcmV0dXJuICtiICE9PSArYjtcbiAgICAgICAgLy8gQW4gYGVnYWxgIGNvbXBhcmlzb24gaXMgcGVyZm9ybWVkIGZvciBvdGhlciBudW1lcmljIHZhbHVlcy5cbiAgICAgICAgcmV0dXJuICthID09PSAwID8gMSAvICthID09PSAxIC8gYiA6ICthID09PSArYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOlxuICAgICAgY2FzZSAnW29iamVjdCBCb29sZWFuXSc6XG4gICAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtZXJpYyBwcmltaXRpdmUgdmFsdWVzLiBEYXRlcyBhcmUgY29tcGFyZWQgYnkgdGhlaXJcbiAgICAgICAgLy8gbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zLiBOb3RlIHRoYXQgaW52YWxpZCBkYXRlcyB3aXRoIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9uc1xuICAgICAgICAvLyBvZiBgTmFOYCBhcmUgbm90IGVxdWl2YWxlbnQuXG4gICAgICAgIHJldHVybiArYSA9PT0gK2I7XG4gICAgfVxuXG4gICAgdmFyIGFyZUFycmF5cyA9IGNsYXNzTmFtZSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICBpZiAoIWFyZUFycmF5cykge1xuICAgICAgaWYgKHR5cGVvZiBhICE9ICdvYmplY3QnIHx8IHR5cGVvZiBiICE9ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIC8vIE9iamVjdHMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1aXZhbGVudCwgYnV0IGBPYmplY3RgcyBvciBgQXJyYXlgc1xuICAgICAgLy8gZnJvbSBkaWZmZXJlbnQgZnJhbWVzIGFyZS5cbiAgICAgIHZhciBhQ3RvciA9IGEuY29uc3RydWN0b3IsIGJDdG9yID0gYi5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmIChhQ3RvciAhPT0gYkN0b3IgJiYgIShfLmlzRnVuY3Rpb24oYUN0b3IpICYmIGFDdG9yIGluc3RhbmNlb2YgYUN0b3IgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmlzRnVuY3Rpb24oYkN0b3IpICYmIGJDdG9yIGluc3RhbmNlb2YgYkN0b3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICYmICgnY29uc3RydWN0b3InIGluIGEgJiYgJ2NvbnN0cnVjdG9yJyBpbiBiKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEFzc3VtZSBlcXVhbGl0eSBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWNcbiAgICAvLyBzdHJ1Y3R1cmVzIGlzIGFkYXB0ZWQgZnJvbSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLCBhYnN0cmFjdCBvcGVyYXRpb24gYEpPYC5cblxuICAgIC8vIEluaXRpYWxpemluZyBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAvLyBJdCdzIGRvbmUgaGVyZSBzaW5jZSB3ZSBvbmx5IG5lZWQgdGhlbSBmb3Igb2JqZWN0cyBhbmQgYXJyYXlzIGNvbXBhcmlzb24uXG4gICAgYVN0YWNrID0gYVN0YWNrIHx8IFtdO1xuICAgIGJTdGFjayA9IGJTdGFjayB8fCBbXTtcbiAgICB2YXIgbGVuZ3RoID0gYVN0YWNrLmxlbmd0aDtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIC8vIExpbmVhciBzZWFyY2guIFBlcmZvcm1hbmNlIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZlxuICAgICAgLy8gdW5pcXVlIG5lc3RlZCBzdHJ1Y3R1cmVzLlxuICAgICAgaWYgKGFTdGFja1tsZW5ndGhdID09PSBhKSByZXR1cm4gYlN0YWNrW2xlbmd0aF0gPT09IGI7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSBmaXJzdCBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIGFTdGFjay5wdXNoKGEpO1xuICAgIGJTdGFjay5wdXNoKGIpO1xuXG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgaWYgKGFyZUFycmF5cykge1xuICAgICAgLy8gQ29tcGFyZSBhcnJheSBsZW5ndGhzIHRvIGRldGVybWluZSBpZiBhIGRlZXAgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkuXG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICAvLyBEZWVwIGNvbXBhcmUgdGhlIGNvbnRlbnRzLCBpZ25vcmluZyBub24tbnVtZXJpYyBwcm9wZXJ0aWVzLlxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmICghZXEoYVtsZW5ndGhdLCBiW2xlbmd0aF0sIGFTdGFjaywgYlN0YWNrKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWVwIGNvbXBhcmUgb2JqZWN0cy5cbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKGEpLCBrZXk7XG4gICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IGJvdGggb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzIGJlZm9yZSBjb21wYXJpbmcgZGVlcCBlcXVhbGl0eS5cbiAgICAgIGlmIChfLmtleXMoYikubGVuZ3RoICE9PSBsZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAvLyBEZWVwIGNvbXBhcmUgZWFjaCBtZW1iZXJcbiAgICAgICAga2V5ID0ga2V5c1tsZW5ndGhdO1xuICAgICAgICBpZiAoIShfLmhhcyhiLCBrZXkpICYmIGVxKGFba2V5XSwgYltrZXldLCBhU3RhY2ssIGJTdGFjaykpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJlbW92ZSB0aGUgZmlyc3Qgb2JqZWN0IGZyb20gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIGFTdGFjay5wb3AoKTtcbiAgICBiU3RhY2sucG9wKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gUGVyZm9ybSBhIGRlZXAgY29tcGFyaXNvbiB0byBjaGVjayBpZiB0d28gb2JqZWN0cyBhcmUgZXF1YWwuXG4gIF8uaXNFcXVhbCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gZXEoYSwgYik7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiBhcnJheSwgc3RyaW5nLCBvciBvYmplY3QgZW1wdHk/XG4gIC8vIEFuIFwiZW1wdHlcIiBvYmplY3QgaGFzIG5vIGVudW1lcmFibGUgb3duLXByb3BlcnRpZXMuXG4gIF8uaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikgJiYgKF8uaXNBcnJheShvYmopIHx8IF8uaXNTdHJpbmcob2JqKSB8fCBfLmlzQXJndW1lbnRzKG9iaikpKSByZXR1cm4gb2JqLmxlbmd0aCA9PT0gMDtcbiAgICByZXR1cm4gXy5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBET00gZWxlbWVudD9cbiAgXy5pc0VsZW1lbnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PT0gMSk7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhbiBhcnJheT9cbiAgLy8gRGVsZWdhdGVzIHRvIEVDTUE1J3MgbmF0aXZlIEFycmF5LmlzQXJyYXlcbiAgXy5pc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgYW4gb2JqZWN0P1xuICBfLmlzT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2Ygb2JqO1xuICAgIHJldHVybiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGUgPT09ICdvYmplY3QnICYmICEhb2JqO1xuICB9O1xuXG4gIC8vIEFkZCBzb21lIGlzVHlwZSBtZXRob2RzOiBpc0FyZ3VtZW50cywgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGlzTnVtYmVyLCBpc0RhdGUsIGlzUmVnRXhwLCBpc0Vycm9yLlxuICBfLmVhY2goWydBcmd1bWVudHMnLCAnRnVuY3Rpb24nLCAnU3RyaW5nJywgJ051bWJlcicsICdEYXRlJywgJ1JlZ0V4cCcsICdFcnJvciddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgX1snaXMnICsgbmFtZV0gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0ICcgKyBuYW1lICsgJ10nO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIERlZmluZSBhIGZhbGxiYWNrIHZlcnNpb24gb2YgdGhlIG1ldGhvZCBpbiBicm93c2VycyAoYWhlbSwgSUUgPCA5KSwgd2hlcmVcbiAgLy8gdGhlcmUgaXNuJ3QgYW55IGluc3BlY3RhYmxlIFwiQXJndW1lbnRzXCIgdHlwZS5cbiAgaWYgKCFfLmlzQXJndW1lbnRzKGFyZ3VtZW50cykpIHtcbiAgICBfLmlzQXJndW1lbnRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gXy5oYXMob2JqLCAnY2FsbGVlJyk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIE9wdGltaXplIGBpc0Z1bmN0aW9uYCBpZiBhcHByb3ByaWF0ZS4gV29yayBhcm91bmQgc29tZSB0eXBlb2YgYnVncyBpbiBvbGQgdjgsXG4gIC8vIElFIDExICgjMTYyMSksIGFuZCBpbiBTYWZhcmkgOCAoIzE5MjkpLlxuICBpZiAodHlwZW9mIC8uLyAhPSAnZnVuY3Rpb24nICYmIHR5cGVvZiBJbnQ4QXJyYXkgIT0gJ29iamVjdCcpIHtcbiAgICBfLmlzRnVuY3Rpb24gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09ICdmdW5jdGlvbicgfHwgZmFsc2U7XG4gICAgfTtcbiAgfVxuXG4gIC8vIElzIGEgZ2l2ZW4gb2JqZWN0IGEgZmluaXRlIG51bWJlcj9cbiAgXy5pc0Zpbml0ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBpc0Zpbml0ZShvYmopICYmICFpc05hTihwYXJzZUZsb2F0KG9iaikpO1xuICB9O1xuXG4gIC8vIElzIHRoZSBnaXZlbiB2YWx1ZSBgTmFOYD8gKE5hTiBpcyB0aGUgb25seSBudW1iZXIgd2hpY2ggZG9lcyBub3QgZXF1YWwgaXRzZWxmKS5cbiAgXy5pc05hTiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBfLmlzTnVtYmVyKG9iaikgJiYgb2JqICE9PSArb2JqO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBib29sZWFuP1xuICBfLmlzQm9vbGVhbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHRydWUgfHwgb2JqID09PSBmYWxzZSB8fCB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEJvb2xlYW5dJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGVxdWFsIHRvIG51bGw/XG4gIF8uaXNOdWxsID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIHVuZGVmaW5lZD9cbiAgXy5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcbiAgfTtcblxuICAvLyBTaG9ydGN1dCBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHByb3BlcnR5IGRpcmVjdGx5XG4gIC8vIG9uIGl0c2VsZiAoaW4gb3RoZXIgd29yZHMsIG5vdCBvbiBhIHByb3RvdHlwZSkuXG4gIF8uaGFzID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG4gIH07XG5cbiAgLy8gVXRpbGl0eSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBSdW4gVW5kZXJzY29yZS5qcyBpbiAqbm9Db25mbGljdCogbW9kZSwgcmV0dXJuaW5nIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzXG4gIC8vIHByZXZpb3VzIG93bmVyLiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcm9vdC5fID0gcHJldmlvdXNVbmRlcnNjb3JlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEtlZXAgdGhlIGlkZW50aXR5IGZ1bmN0aW9uIGFyb3VuZCBmb3IgZGVmYXVsdCBpdGVyYXRlZXMuXG4gIF8uaWRlbnRpdHkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvLyBQcmVkaWNhdGUtZ2VuZXJhdGluZyBmdW5jdGlvbnMuIE9mdGVuIHVzZWZ1bCBvdXRzaWRlIG9mIFVuZGVyc2NvcmUuXG4gIF8uY29uc3RhbnQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICB9O1xuXG4gIF8ubm9vcCA9IGZ1bmN0aW9uKCl7fTtcblxuICBfLnByb3BlcnR5ID0gcHJvcGVydHk7XG5cbiAgLy8gR2VuZXJhdGVzIGEgZnVuY3Rpb24gZm9yIGEgZ2l2ZW4gb2JqZWN0IHRoYXQgcmV0dXJucyBhIGdpdmVuIHByb3BlcnR5LlxuICBfLnByb3BlcnR5T2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09IG51bGwgPyBmdW5jdGlvbigpe30gOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBwcmVkaWNhdGUgZm9yIGNoZWNraW5nIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZlxuICAvLyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5tYXRjaGVyID0gXy5tYXRjaGVzID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgICBhdHRycyA9IF8uZXh0ZW5kT3duKHt9LCBhdHRycyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIF8uaXNNYXRjaChvYmosIGF0dHJzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJ1biBhIGZ1bmN0aW9uICoqbioqIHRpbWVzLlxuICBfLnRpbWVzID0gZnVuY3Rpb24obiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgYWNjdW0gPSBBcnJheShNYXRoLm1heCgwLCBuKSk7XG4gICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykgYWNjdW1baV0gPSBpdGVyYXRlZShpKTtcbiAgICByZXR1cm4gYWNjdW07XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBtaW4gYW5kIG1heCAoaW5jbHVzaXZlKS5cbiAgXy5yYW5kb20gPSBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgIGlmIChtYXggPT0gbnVsbCkge1xuICAgICAgbWF4ID0gbWluO1xuICAgICAgbWluID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIG1pbiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSk7XG4gIH07XG5cbiAgLy8gQSAocG9zc2libHkgZmFzdGVyKSB3YXkgdG8gZ2V0IHRoZSBjdXJyZW50IHRpbWVzdGFtcCBhcyBhbiBpbnRlZ2VyLlxuICBfLm5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfTtcblxuICAgLy8gTGlzdCBvZiBIVE1MIGVudGl0aWVzIGZvciBlc2NhcGluZy5cbiAgdmFyIGVzY2FwZU1hcCA9IHtcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmI3gyNzsnLFxuICAgICdgJzogJyYjeDYwOydcbiAgfTtcbiAgdmFyIHVuZXNjYXBlTWFwID0gXy5pbnZlcnQoZXNjYXBlTWFwKTtcblxuICAvLyBGdW5jdGlvbnMgZm9yIGVzY2FwaW5nIGFuZCB1bmVzY2FwaW5nIHN0cmluZ3MgdG8vZnJvbSBIVE1MIGludGVycG9sYXRpb24uXG4gIHZhciBjcmVhdGVFc2NhcGVyID0gZnVuY3Rpb24obWFwKSB7XG4gICAgdmFyIGVzY2FwZXIgPSBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgcmV0dXJuIG1hcFttYXRjaF07XG4gICAgfTtcbiAgICAvLyBSZWdleGVzIGZvciBpZGVudGlmeWluZyBhIGtleSB0aGF0IG5lZWRzIHRvIGJlIGVzY2FwZWRcbiAgICB2YXIgc291cmNlID0gJyg/OicgKyBfLmtleXMobWFwKS5qb2luKCd8JykgKyAnKSc7XG4gICAgdmFyIHRlc3RSZWdleHAgPSBSZWdFeHAoc291cmNlKTtcbiAgICB2YXIgcmVwbGFjZVJlZ2V4cCA9IFJlZ0V4cChzb3VyY2UsICdnJyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gc3RyaW5nID09IG51bGwgPyAnJyA6ICcnICsgc3RyaW5nO1xuICAgICAgcmV0dXJuIHRlc3RSZWdleHAudGVzdChzdHJpbmcpID8gc3RyaW5nLnJlcGxhY2UocmVwbGFjZVJlZ2V4cCwgZXNjYXBlcikgOiBzdHJpbmc7XG4gICAgfTtcbiAgfTtcbiAgXy5lc2NhcGUgPSBjcmVhdGVFc2NhcGVyKGVzY2FwZU1hcCk7XG4gIF8udW5lc2NhcGUgPSBjcmVhdGVFc2NhcGVyKHVuZXNjYXBlTWFwKTtcblxuICAvLyBJZiB0aGUgdmFsdWUgb2YgdGhlIG5hbWVkIGBwcm9wZXJ0eWAgaXMgYSBmdW5jdGlvbiB0aGVuIGludm9rZSBpdCB3aXRoIHRoZVxuICAvLyBgb2JqZWN0YCBhcyBjb250ZXh0OyBvdGhlcndpc2UsIHJldHVybiBpdC5cbiAgXy5yZXN1bHQgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5LCBmYWxsYmFjaykge1xuICAgIHZhciB2YWx1ZSA9IG9iamVjdCA9PSBudWxsID8gdm9pZCAwIDogb2JqZWN0W3Byb3BlcnR5XTtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgdmFsdWUgPSBmYWxsYmFjaztcbiAgICB9XG4gICAgcmV0dXJuIF8uaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZS5jYWxsKG9iamVjdCkgOiB2YWx1ZTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpbnRlZ2VyIGlkICh1bmlxdWUgd2l0aGluIHRoZSBlbnRpcmUgY2xpZW50IHNlc3Npb24pLlxuICAvLyBVc2VmdWwgZm9yIHRlbXBvcmFyeSBET00gaWRzLlxuICB2YXIgaWRDb3VudGVyID0gMDtcbiAgXy51bmlxdWVJZCA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHZhciBpZCA9ICsraWRDb3VudGVyICsgJyc7XG4gICAgcmV0dXJuIHByZWZpeCA/IHByZWZpeCArIGlkIDogaWQ7XG4gIH07XG5cbiAgLy8gQnkgZGVmYXVsdCwgVW5kZXJzY29yZSB1c2VzIEVSQi1zdHlsZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLCBjaGFuZ2UgdGhlXG4gIC8vIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAgXy50ZW1wbGF0ZVNldHRpbmdzID0ge1xuICAgIGV2YWx1YXRlICAgIDogLzwlKFtcXHNcXFNdKz8pJT4vZyxcbiAgICBpbnRlcnBvbGF0ZSA6IC88JT0oW1xcc1xcU10rPyklPi9nLFxuICAgIGVzY2FwZSAgICAgIDogLzwlLShbXFxzXFxTXSs/KSU+L2dcbiAgfTtcblxuICAvLyBXaGVuIGN1c3RvbWl6aW5nIGB0ZW1wbGF0ZVNldHRpbmdzYCwgaWYgeW91IGRvbid0IHdhbnQgdG8gZGVmaW5lIGFuXG4gIC8vIGludGVycG9sYXRpb24sIGV2YWx1YXRpb24gb3IgZXNjYXBpbmcgcmVnZXgsIHdlIG5lZWQgb25lIHRoYXQgaXNcbiAgLy8gZ3VhcmFudGVlZCBub3QgdG8gbWF0Y2guXG4gIHZhciBub01hdGNoID0gLyguKV4vO1xuXG4gIC8vIENlcnRhaW4gY2hhcmFjdGVycyBuZWVkIHRvIGJlIGVzY2FwZWQgc28gdGhhdCB0aGV5IGNhbiBiZSBwdXQgaW50byBhXG4gIC8vIHN0cmluZyBsaXRlcmFsLlxuICB2YXIgZXNjYXBlcyA9IHtcbiAgICBcIidcIjogICAgICBcIidcIixcbiAgICAnXFxcXCc6ICAgICAnXFxcXCcsXG4gICAgJ1xccic6ICAgICAncicsXG4gICAgJ1xcbic6ICAgICAnbicsXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xuICB9O1xuXG4gIHZhciBlc2NhcGVyID0gL1xcXFx8J3xcXHJ8XFxufFxcdTIwMjh8XFx1MjAyOS9nO1xuXG4gIHZhciBlc2NhcGVDaGFyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gJ1xcXFwnICsgZXNjYXBlc1ttYXRjaF07XG4gIH07XG5cbiAgLy8gSmF2YVNjcmlwdCBtaWNyby10ZW1wbGF0aW5nLCBzaW1pbGFyIHRvIEpvaG4gUmVzaWcncyBpbXBsZW1lbnRhdGlvbi5cbiAgLy8gVW5kZXJzY29yZSB0ZW1wbGF0aW5nIGhhbmRsZXMgYXJiaXRyYXJ5IGRlbGltaXRlcnMsIHByZXNlcnZlcyB3aGl0ZXNwYWNlLFxuICAvLyBhbmQgY29ycmVjdGx5IGVzY2FwZXMgcXVvdGVzIHdpdGhpbiBpbnRlcnBvbGF0ZWQgY29kZS5cbiAgLy8gTkI6IGBvbGRTZXR0aW5nc2Agb25seSBleGlzdHMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICBfLnRlbXBsYXRlID0gZnVuY3Rpb24odGV4dCwgc2V0dGluZ3MsIG9sZFNldHRpbmdzKSB7XG4gICAgaWYgKCFzZXR0aW5ncyAmJiBvbGRTZXR0aW5ncykgc2V0dGluZ3MgPSBvbGRTZXR0aW5ncztcbiAgICBzZXR0aW5ncyA9IF8uZGVmYXVsdHMoe30sIHNldHRpbmdzLCBfLnRlbXBsYXRlU2V0dGluZ3MpO1xuXG4gICAgLy8gQ29tYmluZSBkZWxpbWl0ZXJzIGludG8gb25lIHJlZ3VsYXIgZXhwcmVzc2lvbiB2aWEgYWx0ZXJuYXRpb24uXG4gICAgdmFyIG1hdGNoZXIgPSBSZWdFeHAoW1xuICAgICAgKHNldHRpbmdzLmVzY2FwZSB8fCBub01hdGNoKS5zb3VyY2UsXG4gICAgICAoc2V0dGluZ3MuaW50ZXJwb2xhdGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmV2YWx1YXRlIHx8IG5vTWF0Y2gpLnNvdXJjZVxuICAgIF0uam9pbignfCcpICsgJ3wkJywgJ2cnKTtcblxuICAgIC8vIENvbXBpbGUgdGhlIHRlbXBsYXRlIHNvdXJjZSwgZXNjYXBpbmcgc3RyaW5nIGxpdGVyYWxzIGFwcHJvcHJpYXRlbHkuXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgc291cmNlID0gXCJfX3ArPSdcIjtcbiAgICB0ZXh0LnJlcGxhY2UobWF0Y2hlciwgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZSwgaW50ZXJwb2xhdGUsIGV2YWx1YXRlLCBvZmZzZXQpIHtcbiAgICAgIHNvdXJjZSArPSB0ZXh0LnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UoZXNjYXBlciwgZXNjYXBlQ2hhcik7XG4gICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgICAgaWYgKGVzY2FwZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGVzY2FwZSArIFwiKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXFxuJ1wiO1xuICAgICAgfSBlbHNlIGlmIChpbnRlcnBvbGF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGludGVycG9sYXRlICsgXCIpKT09bnVsbD8nJzpfX3QpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoZXZhbHVhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlICsgXCJcXG5fX3ArPSdcIjtcbiAgICAgIH1cblxuICAgICAgLy8gQWRvYmUgVk1zIG5lZWQgdGhlIG1hdGNoIHJldHVybmVkIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3Qgb2ZmZXN0LlxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAvLyBJZiBhIHZhcmlhYmxlIGlzIG5vdCBzcGVjaWZpZWQsIHBsYWNlIGRhdGEgdmFsdWVzIGluIGxvY2FsIHNjb3BlLlxuICAgIGlmICghc2V0dGluZ3MudmFyaWFibGUpIHNvdXJjZSA9ICd3aXRoKG9ianx8e30pe1xcbicgKyBzb3VyY2UgKyAnfVxcbic7XG5cbiAgICBzb3VyY2UgPSBcInZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixcIiArXG4gICAgICBcInByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XFxuXCIgK1xuICAgICAgc291cmNlICsgJ3JldHVybiBfX3A7XFxuJztcblxuICAgIHRyeSB7XG4gICAgICB2YXIgcmVuZGVyID0gbmV3IEZ1bmN0aW9uKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonLCAnXycsIHNvdXJjZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZS5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIHZhciB0ZW1wbGF0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiByZW5kZXIuY2FsbCh0aGlzLCBkYXRhLCBfKTtcbiAgICB9O1xuXG4gICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgc291cmNlIGFzIGEgY29udmVuaWVuY2UgZm9yIHByZWNvbXBpbGF0aW9uLlxuICAgIHZhciBhcmd1bWVudCA9IHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonO1xuICAgIHRlbXBsYXRlLnNvdXJjZSA9ICdmdW5jdGlvbignICsgYXJndW1lbnQgKyAnKXtcXG4nICsgc291cmNlICsgJ30nO1xuXG4gICAgcmV0dXJuIHRlbXBsYXRlO1xuICB9O1xuXG4gIC8vIEFkZCBhIFwiY2hhaW5cIiBmdW5jdGlvbi4gU3RhcnQgY2hhaW5pbmcgYSB3cmFwcGVkIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBfLmNoYWluID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGluc3RhbmNlID0gXyhvYmopO1xuICAgIGluc3RhbmNlLl9jaGFpbiA9IHRydWU7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xuXG4gIC8vIE9PUFxuICAvLyAtLS0tLS0tLS0tLS0tLS1cbiAgLy8gSWYgVW5kZXJzY29yZSBpcyBjYWxsZWQgYXMgYSBmdW5jdGlvbiwgaXQgcmV0dXJucyBhIHdyYXBwZWQgb2JqZWN0IHRoYXRcbiAgLy8gY2FuIGJlIHVzZWQgT08tc3R5bGUuIFRoaXMgd3JhcHBlciBob2xkcyBhbHRlcmVkIHZlcnNpb25zIG9mIGFsbCB0aGVcbiAgLy8gdW5kZXJzY29yZSBmdW5jdGlvbnMuIFdyYXBwZWQgb2JqZWN0cyBtYXkgYmUgY2hhaW5lZC5cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29udGludWUgY2hhaW5pbmcgaW50ZXJtZWRpYXRlIHJlc3VsdHMuXG4gIHZhciByZXN1bHQgPSBmdW5jdGlvbihpbnN0YW5jZSwgb2JqKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLl9jaGFpbiA/IF8ob2JqKS5jaGFpbigpIDogb2JqO1xuICB9O1xuXG4gIC8vIEFkZCB5b3VyIG93biBjdXN0b20gZnVuY3Rpb25zIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5taXhpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIF8uZWFjaChfLmZ1bmN0aW9ucyhvYmopLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IF9bbmFtZV0gPSBvYmpbbmFtZV07XG4gICAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IFt0aGlzLl93cmFwcGVkXTtcbiAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIGZ1bmMuYXBwbHkoXywgYXJncykpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBBZGQgYWxsIG9mIHRoZSBVbmRlcnNjb3JlIGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlciBvYmplY3QuXG4gIF8ubWl4aW4oXyk7XG5cbiAgLy8gQWRkIGFsbCBtdXRhdG9yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsncG9wJywgJ3B1c2gnLCAncmV2ZXJzZScsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9iaiA9IHRoaXMuX3dyYXBwZWQ7XG4gICAgICBtZXRob2QuYXBwbHkob2JqLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKChuYW1lID09PSAnc2hpZnQnIHx8IG5hbWUgPT09ICdzcGxpY2UnKSAmJiBvYmoubGVuZ3RoID09PSAwKSBkZWxldGUgb2JqWzBdO1xuICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLCBvYmopO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIEFkZCBhbGwgYWNjZXNzb3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICBfLmVhY2goWydjb25jYXQnLCAnam9pbicsICdzbGljZSddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByZXN1bHQodGhpcywgbWV0aG9kLmFwcGx5KHRoaXMuX3dyYXBwZWQsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIEV4dHJhY3RzIHRoZSByZXN1bHQgZnJvbSBhIHdyYXBwZWQgYW5kIGNoYWluZWQgb2JqZWN0LlxuICBfLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl93cmFwcGVkO1xuICB9O1xuXG4gIC8vIFByb3ZpZGUgdW53cmFwcGluZyBwcm94eSBmb3Igc29tZSBtZXRob2RzIHVzZWQgaW4gZW5naW5lIG9wZXJhdGlvbnNcbiAgLy8gc3VjaCBhcyBhcml0aG1ldGljIGFuZCBKU09OIHN0cmluZ2lmaWNhdGlvbi5cbiAgXy5wcm90b3R5cGUudmFsdWVPZiA9IF8ucHJvdG90eXBlLnRvSlNPTiA9IF8ucHJvdG90eXBlLnZhbHVlO1xuXG4gIF8ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICcnICsgdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxuICAvLyBBTUQgcmVnaXN0cmF0aW9uIGhhcHBlbnMgYXQgdGhlIGVuZCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIEFNRCBsb2FkZXJzXG4gIC8vIHRoYXQgbWF5IG5vdCBlbmZvcmNlIG5leHQtdHVybiBzZW1hbnRpY3Mgb24gbW9kdWxlcy4gRXZlbiB0aG91Z2ggZ2VuZXJhbFxuICAvLyBwcmFjdGljZSBmb3IgQU1EIHJlZ2lzdHJhdGlvbiBpcyB0byBiZSBhbm9ueW1vdXMsIHVuZGVyc2NvcmUgcmVnaXN0ZXJzXG4gIC8vIGFzIGEgbmFtZWQgbW9kdWxlIGJlY2F1c2UsIGxpa2UgalF1ZXJ5LCBpdCBpcyBhIGJhc2UgbGlicmFyeSB0aGF0IGlzXG4gIC8vIHBvcHVsYXIgZW5vdWdoIHRvIGJlIGJ1bmRsZWQgaW4gYSB0aGlyZCBwYXJ0eSBsaWIsIGJ1dCBub3QgYmUgcGFydCBvZlxuICAvLyBhbiBBTUQgbG9hZCByZXF1ZXN0LiBUaG9zZSBjYXNlcyBjb3VsZCBnZW5lcmF0ZSBhbiBlcnJvciB3aGVuIGFuXG4gIC8vIGFub255bW91cyBkZWZpbmUoKSBpcyBjYWxsZWQgb3V0c2lkZSBvZiBhIGxvYWRlciByZXF1ZXN0LlxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKCd1bmRlcnNjb3JlJywgW10sIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF87XG4gICAgfSk7XG4gIH1cbn0uY2FsbCh0aGlzKSk7XG4iLCIvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXG4vLyBEZXBlbmRlbmNpZXNcbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cblxudmFyIF8gID0gcmVxdWlyZShcInVuZGVyc2NvcmVcIik7XG5fLm1peGluKHJlcXVpcmUoXCJ1bmRlcnNjb3JlLmRlZXBcIikpO1xuXG52YXIgZGVmYXVsdENvbmZpZyA9IHtcbiAgICBydWxlcyA6IFtdLFxufTtcblxuZnVuY3Rpb24gaWRlbnRpdHlGdW5jICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gX3N0YXJ0c1dpdGgoc3RyLCBwcmVmaXgpIHtcbiAgICByZXR1cm4gc3RyLnN1YnN0cigwLCBwcmVmaXgubGVuZ3RoKSA9PSBwcmVmaXg7XG59XG5cbmZ1bmN0aW9uIF9lbmRzV2l0aChzdHIsIHByZWZpeCkge1xuICAgIHJldHVybiBzdHIuc3Vic3RyKC1wcmVmaXgubGVuZ3RoKSA9PSBwcmVmaXg7XG59XG5cbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cbi8vIE1hdGNoaW5nIHJ1bGVzXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXG5cbmZ1bmN0aW9uIGtleU1hdGNoZXNSdWxlRGF0YShydWxlRGF0YSwgZnVsbEtleSwga2V5KSB7XG4gICAgdmFyIGk7XG5cbiAgICAvLyBDaGVjayBrZXkgbmFtZSBtYXRjaGVzIGFnYWluc3QgKnRoaXMqIGZpZWxkIG5hbWVcbiAgICBpZiAocnVsZURhdGEua2V5U2V0W2tleV0pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBydWxlRGF0YS5rZXlQcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoX3N0YXJ0c1dpdGgoa2V5LCBydWxlRGF0YS5rZXlQcmVmaXhlc1tpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBydWxlRGF0YS5rZXlTdWZmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoX2VuZHNXaXRoKGtleSwgcnVsZURhdGEua2V5U3VmZml4ZXNbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIHBhdGggbmFtZXMgYWdhaW5zdCB0aGUgZnVsbCBkb3Qgbm90YXRpb24ga2V5IHBhdGhcbiAgICBpZiAocnVsZURhdGEucGF0aFNldFtmdWxsS2V5XSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IHJ1bGVEYXRhLnBhdGhQcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoX3N0YXJ0c1dpdGgoa2V5LCBydWxlRGF0YS5wYXRoUHJlZml4ZXNbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgcnVsZURhdGEucGF0aFN1ZmZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChfZW5kc1dpdGgoa2V5LCBydWxlRGF0YS5wYXRoU3VmZml4ZXNbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIHJlZ3VsYXIgZXhwcmVzc3Npb24gbWF0Y2hlcyBhZ2FpbnN0IHRoZSBmdWxsIGtleSBwYXRoXG4gICAgZm9yIChpID0gMDsgaSA8IHJ1bGVEYXRhLnJlZ3VsYXJFeHByZXNzaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZnVsbEtleS5tYXRjaChydWxlRGF0YS5yZWd1bGFyRXhwcmVzc2lvbnNbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIFRyYW5zZm9ybSB0aGUgcnVsZSBjb25maWcgaW50byBhIG1vcmUgcnVudGltZS11c2VmdWwgZm9ybS5cbmZ1bmN0aW9uIGJ1aWxkUnVsZURhdGEocnVsZSkge1xuICAgIHZhciBydWxlRGF0YSA9IHtcbiAgICAgICAga2V5U2V0ICAgICAgICAgIDoge30sXG4gICAgICAgIGtleVByZWZpeGVzICAgICA6IFtdLFxuICAgICAgICBrZXlTdWZmaXhlcyAgICAgOiBbXSxcblxuICAgICAgICBwYXRoU2V0ICAgICAgICAgOiB7fSxcbiAgICAgICAgcGF0aFByZWZpeGVzICAgIDogW10sXG4gICAgICAgIHBhdGhTdWZmaXhlcyAgICA6IFtdLFxuXG4gICAgICAgIHJlZ3VsYXJFeHByZXNzaW9ucyA6IFtdLFxuICAgIH07XG5cbiAgICB2YXIgaTtcbiAgICBpZiAocnVsZS5rZXlzKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBydWxlLmtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJ1bGVEYXRhLmtleVNldFtydWxlLmtleXNbaV1dID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBydWxlRGF0YS5rZXlQcmVmaXhlcyA9IHJ1bGUua2V5X3ByZWZpeGVzIHx8IFtdO1xuICAgIHJ1bGVEYXRhLmtleVN1ZmZpeGVzID0gcnVsZS5rZXlfc3VmZml4ZXMgfHwgW107XG5cbiAgICBpZiAocnVsZS5wYXRocykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcnVsZS5wYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcnVsZURhdGEucGF0aFNldFtydWxlLnBhdGhzW2ldXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcnVsZURhdGEucGF0aFByZWZpeGVzID0gcnVsZS5wYXRoX3ByZWZpeGVzIHx8IFtdO1xuICAgIHJ1bGVEYXRhLnBhdGhTdWZmaXhlcyA9IHJ1bGUucGF0aF9zdWZmaXhlcyB8fCBbXTtcblxuICAgIGlmIChydWxlLnJlZ3VsYXJfZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJ1bGUucmVndWxhcl9leHByZXNzaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcnVsZURhdGEucmVndWxhckV4cHJlc3Npb25zLnB1c2gobmV3IFJlZ0V4cChydWxlLnJlZ3VsYXJfZXhwcmVzc2lvbnNbaV0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcnVsZURhdGE7XG59XG5cbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cbi8vIEltcGxlbWVudGF0aW9uIGNvZGVcbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cblxuZnVuY3Rpb24gZGVlcE1hcFZhbHVlc09yRGlyZWN0Q2FsbChvYmosIGYpIHtcbiAgICBpZiAoXy5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG9ialtpXSA9IGRlZXBNYXBWYWx1ZXNPckRpcmVjdENhbGwob2JqW2ldLCBmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0gZWxzZSBpZiAoXy5pc09iamVjdChvYmopKSB7XG4gICAgICAgIHJldHVybiBfLmRlZXBNYXBWYWx1ZXMob2JqLCBmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZihvYmopO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZGVlcFJlbW92ZUtleXMob2JqLCBwcmVmaXgsIHJ1bGVEYXRhKSB7XG4gICAgLy8gRnVuY3Rpb25zIGFyZSBvYmplY3RzIGluIEpTIHNvIGJvdGggdGhlc2UgY2hlY2tzIGFyZSBuZWVkZWQuXG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5TWF0Y2hlc1J1bGVEYXRhKHJ1bGVEYXRhLCBwcmVmaXggKyBrZXksIGtleSkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGRlZXBSZW1vdmVLZXlzKG9ialtrZXldLCBwcmVmaXggKyBrZXkgKyBcIi5cIiwgcnVsZURhdGEpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZGVlcFJlcGxhY2VWYWx1ZXMob2JqLCBwcmVmaXgsIHJ1bGVEYXRhLCB2YWx1ZSkge1xuICAgIC8vIEZ1bmN0aW9ucyBhcmUgb2JqZWN0cyBpbiBKUyBzbyBib3RoIHRoZXNlIGNoZWNrcyBhcmUgbmVlZGVkLlxuICAgIGlmICghXy5pc09iamVjdChvYmopIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKCFvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gICAgICBcbiAgICAgICAgaWYgKGtleU1hdGNoZXNSdWxlRGF0YShydWxlRGF0YSwgcHJlZml4ICsga2V5LCBrZXkpKSB7XG4gICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9ialtrZXldICE9PSBrZXkpIHtcbiAgICAgICAgICAgIGRlZXBSZXBsYWNlVmFsdWVzKG9ialtrZXldLCBwcmVmaXggKyBrZXkgKyBcIi5cIiwgcnVsZURhdGEsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVGdW5jdGlvbkZvclJ1bGUocnVsZSkge1xuXG4gICAgdmFyIHJ1bGVEYXRhID0gYnVpbGRSdWxlRGF0YShydWxlKTtcblxuICAgIGlmIChydWxlLm1hdGNoID09IFwia2V5c1wiKSB7XG5cbiAgICAgICAgaWYgKHJ1bGUub3AgPT0gXCJyZW1vdmVcIikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZGVlcFJlbW92ZUtleXModmFsdWUsIFwiXCIsIHJ1bGVEYXRhKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocnVsZS5vcCA9PSBcInJlcGxhY2VcIikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZGVlcFJlcGxhY2VWYWx1ZXModmFsdWUsIFwiXCIsIHJ1bGVEYXRhLCBydWxlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKHJ1bGUubWF0Y2ggPT0gXCJ1cmxfcXVlcnlfc3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVlcE1hcFZhbHVlc09yRGlyZWN0Q2FsbCh2YWx1ZSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV8uaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3NRdWVyeVN0cmluZ1ZhbHVlKHJ1bGVEYXRhLCB2YWx1ZSwgcnVsZS52YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBIbW1tLi4udW5oYW5kbGVkIGNhc2VcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBydWxlOlxcblwiICsgSlNPTi5zdHJpbmdpZnkocnVsZSwgbnVsbCwgNCkpO1xufVxuXG4vLyBIYW5kbGUgYm90aCBmdWxsIHVybHMgYW5kIGp1c3QgcXVlcnkgc3RyaW5nczpcbi8vXG4vLyAgICAgIFwiaHR0cDovL3VybC5jb20vcGFnZT9wYXJhbT0xMjMmdmFsdWU9NzY1XCJcbi8vICAgICAgXCJwYXJhbT0xMjMmdmFsdWU9NzY1XCJcbi8vXG4vLyBGb3IgYnJldml0eSBvZiB0aGUgaW1wbGVtZW50YXRpb24sIHRyZWF0IFwicmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZFwiIGFzIG1lYW5pbmdcbi8vICpyZW1vdmUqIHRoZSBrZXkgYW5kIHZhbHVlLiAoSGV5LCBpdCdzIG5vdCBhIHB1YmxpYyBBUEkhKVxuLy9cbmZ1bmN0aW9uIHByb2Nlc3NRdWVyeVN0cmluZ1ZhbHVlKHJ1bGVEYXRhLCB2YWx1ZSwgcmVwbGFjZW1lbnRSYXcpIHtcblxuICAgIC8vIEVhcmx5IG91dCBpZiB0aGlzIGNsZWFybHkgaXMgbm90IGEgVVJMIHF1ZXJ5IHN0cmluZ1xuICAgIGlmICh2YWx1ZS5pbmRleE9mKFwiPVwiKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHZhciByZXBsYWNlbWVudFZhbHVlO1xuICAgIGlmIChyZXBsYWNlbWVudFJhdyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlcGxhY2VtZW50VmFsdWUgPSBlbmNvZGVVUklDb21wb25lbnQocmVwbGFjZW1lbnRSYXcpO1xuICAgIH1cblxuICAgIHZhciBsZWFkaW5nID0gXCJcIjtcbiAgICB2YXIgcGFydHMgPSB2YWx1ZS5zcGxpdChcIj9cIik7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbGVhZGluZyA9IHBhcnRzLnNoaWZ0KCkgKyBcIj9cIjtcbiAgICB9XG5cbiAgICB2YXIgcXVlcnlTdHJpbmcgPSBfLmNoYWluKHBhcnRzLmpvaW4oXCI/XCIpLnNwbGl0KFwiJlwiKSlcbiAgICAgICAgLm1hcChmdW5jdGlvbihwYXJhbSkge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gcGFyYW0uc3BsaXQoXCI9XCIpO1xuICAgICAgICAgICAgdmFyIGtleSwgdmFsdWU7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAga2V5ID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhcnRzWzBdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKF9pZ25vcmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBwYXJ0cy5zbGljZSgxKS5qb2luKFwiPVwiKTtcblxuICAgICAgICAgICAgLy8gVGhlIGtleSBpcyBhbHdheXMgYWxzbyB0aGUgXCJmdWxsIGtleVwiIGluIGEgcXVlcnkgc3RyaW5nXG4gICAgICAgICAgICBpZiAoa2V5TWF0Y2hlc1J1bGVEYXRhKHJ1bGVEYXRhLCBrZXksIGtleSkpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVwbGFjZW1lbnRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0c1swXSArIFwiPVwiICsgcmVwbGFjZW1lbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5vIG1hdGNoLCByZXR1cm4gdGhlIHVubW9kaWZpZWQgcGFpclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbih2KSB7IHJldHVybiB2Lmxlbmd0aCA+IDA7IH0pXG4gICAgICAgIC52YWx1ZSgpXG4gICAgICAgIC5qb2luKFwiJlwiKTtcblxuICAgIHJldHVybiBsZWFkaW5nICsgcXVlcnlTdHJpbmc7XG59XG5cbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cbi8vIFNjdWJiZXJcbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cblxuZnVuY3Rpb24gU2NydWJiZXIoY2ZnKSB7XG4gICAgY2ZnID0gY2ZnIHx8IGRlZmF1bHRDb25maWc7XG5cbiAgICB0aGlzLl9jb25maWcgICAgID0gY2ZnO1xuICAgIHRoaXMuX3NjcnViRnVuYyAgPSBpZGVudGl0eUZ1bmM7XG4gICAgdGhpcy5fY29uZmlndXJlKGNmZyk7XG59XG5cblNjcnViYmVyLnByb3RvdHlwZS5fY29uZmlndXJlID0gZnVuY3Rpb24oY2ZnKSB7XG4gICAgaWYgKGNmZy5ydWxlcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gU3BsaXQgYW55IG11bHRpcGxlIG1hdGNoIHR5cGVzIGludG8gaW5kaXZpZHVhbCBydWxlcyB3aXRoIGEgc2luZ2xlXG4gICAgICAgIC8vIG1hdGNoIHR5cGUuXG4gICAgICAgIHZhciBydWxlcyA9IFtdO1xuICAgICAgICBfLmVhY2goY2ZnLnJ1bGVzLCBmdW5jdGlvbiAocnVsZSkge1xuICAgICAgICAgICAgaWYgKF8uaXNBcnJheShydWxlLm1hdGNoKSkge1xuICAgICAgICAgICAgICAgIF8uZWFjaChydWxlLm1hdGNoLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1J1bGUgPSBfLmNsb25lKHJ1bGUpO1xuICAgICAgICAgICAgICAgICAgICBuZXdSdWxlLm1hdGNoID0gbWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzLnB1c2gobmV3UnVsZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJ1bGVzLnB1c2gocnVsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRPRE86IHRoaXMgaXMgcHJlc3VtYWJseSBxdWl0ZSBpbmVmZmljaWVudCBmb3IgbGFyZ2Ugb2JqZWN0cyAtLVxuICAgICAgICAvLyBjb21wb3NlKCkgaXMgbWFraW5nIHRoaXMgaW50byBOIHNjYW5zIG9mIHRoZSBmdWxsIG9iamVjdCBmb3JcbiAgICAgICAgLy8gZWFjaCBydWxlOyBwcmVzdW1hYmx5IHdhbGtpbmcgdGhlIG9iamVjdCBvbmNlIGFuZCBjaGVja2luZyBlYWNoXG4gICAgICAgIC8vIHJ1bGUgYXQgZWFjaCBzdGVwIHdvdWxkIGJlIG1vcmUgZWZmaWNpZW50LlxuICAgICAgICB2YXIgZnVuY3MgPSBfLm1hcChydWxlcywgZ2VuZXJhdGVGdW5jdGlvbkZvclJ1bGUpO1xuICAgICAgICB0aGlzLl9zY3J1YkZ1bmMgPSBfLmNvbXBvc2UuYXBwbHkoXywgZnVuY3MpO1xuICAgIH1cbn07XG5cblNjcnViYmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fc2NydWJGdW5jKF8uZGVlcENsb25lKHZhbHVlKSk7XG59O1xuXG5TY3J1YmJlci5wcm90b3R5cGUubW9kaWZ5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fc2NydWJGdW5jKHZhbHVlKTtcbn07XG5cbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cbi8vIEV4cG9ydGVkIEFQSVxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuXG52YXIgbGliID0ge307XG5cbmxpYi5tYWtlID0gZnVuY3Rpb24oY2ZnKSB7XG4gICAgcmV0dXJuIG5ldyBTY3J1YmJlcihjZmcpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBsaWI7XG4iXX0=
})();